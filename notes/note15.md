# Onboarding & Operational Guide: OutSystems to SQL Server DevOps Transition

## Introduction & Cutover Context

The organization is undergoing a **critical cutover**: all OutSystems external entities are now managed via **SQL Server Data Tools (SSDT)** projects with automated **DACPAC** deployments[\[1\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%F0%9F%8E%AF%20This%20Weekend%27s%20Context). In practical terms, this means **no more direct edits** to the database or ad-hoc SQL scripts. Instead, developers will version-control schema changes in an SSDT database project, compile them into a **DACPAC** package, and deploy through a CI/CD pipeline. **Every change is reviewed and traceable**, and OutSystems must synchronize with the new schema after each deployment[\[2\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2AWhy%20We%20Did%20This%2A%2A%3A%20,Prevents%20drift%20and%20manual%20errors). This guide serves as a comprehensive reference to help OutSystems developers (who are experienced in app development but **new to SSDT/DACPAC workflows**) smoothly transition before and after the cutover.

**Why this change?** Managing the database as code brings multiple benefits: a **single source of truth** for schema in Git, automated build and deployment (no drift between environments), and robust governance (every change is peer-reviewed and logged)[\[3\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=something%20does%20fail%2C%20you%20have,schema%20changes%20being%20deployed%20via)[\[4\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=database%20changes%2C%20similar%20to%20application,schema%20issues%20drop%20to%20zero). It also reduces production surprises - deployments become repeatable and testable, and rollbacks or history checks are possible via version control. In short, the database is no longer a mysterious black box, but a transparent part of the DevOps lifecycle[\[5\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,schema%20issues%20drop%20to%20zero)[\[6\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=note6.md%20,release%20frequency).

**Who should use this guide?** This is written for **OutSystems developers** at all levels who need to work with the new SQL DevOps process. It is both a **pre-cutover primer** (to get you ready by cutover day) and a **post-cutover operational manual** (to guide day-to-day work starting the Monday after cutover). It covers fundamental concepts, daily workflows, team responsibilities, and best practices to keep our momentum and avoid common pitfalls.

**Key mindset:** Treat the database schema like application code - plan changes, commit to Git, run builds, and deploy via pipeline. After deploying a DB change, always update OutSystems to reflect it. This guide will show you how.

## Pre-Cutover Readiness: Tools, Setup & Learning

Before cutover, there are a few must-do items to ensure you hit the ground running:

- **Install & Configure Tools:** Ensure you have **Visual Studio 2019/2022** with the **SQL Server Data Tools (SSDT)** workload installed[\[7\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=%2A%2AKey%20Activities%20and%20Skills%3A%2A%2A%20,ver17%23%3A~%3Atext%3DThe%252%200development%2520cycle%2520of%2520a%2Clocal%2520development%2520without%2520additional%2520effor). This adds database project support to VS. Also have **SQL Server Management Studio (SSMS)** (for read-only exploration or data checks) and OutSystems **Integration Studio** (to manage external entities). Verify you can connect to the Dev database and have appropriate permissions (db_owner on Dev for deployments).
- **Import the Current Schema:** Using SSDT, **import the existing database schema** into a new SQL Server Database Project[\[8\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=Properties%20and%20References%20folders.%20,server). This creates CREATE scripts for all tables, views, procedures, etc. in your project. Organize the files by schema/object type for clarity (SSDT's import can do this automatically)[\[9\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=projects%2Ftutorials%2Fcreate,the%20option%20to%20organize%20by). Building the project at this point should produce your first **DACPAC** - essentially a compiled schema snapshot (a single .dacpac file in the _bin_ folder)[\[10\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=review%20and%20ensuring%20your%20changes,and). _Think of the DACPAC as the "DLL" of your database - a packaged model of the schema that can be deployed to any environment_[\[10\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=review%20and%20ensuring%20your%20changes,and).
- **Version Control Setup:** If not already done, put the SSDT project under **Git source control**. Commit all the .sql files, the .sqlproj file, and any reference .dacpac files. From now on, treat this repo as the **source of truth** for the database schema - no schema changes happen outside it[\[11\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=reference%20,of%20database%20DevOps%3A%20the%20repo)[\[12\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=dacpac,to%20complex%20schema%20overhauls%20with). This discipline is critical: if an emergency fix is made directly in the DB (avoid if possible), it **must** be reverse-engineered into the project ASAP to prevent "drift" between code and reality.
- **Understand SSDT Workflow Basics:** At minimum, know that in SSDT you **do NOT write ALTER statements** in your create scripts. You always define the **desired end-state** (e.g. full CREATE TABLE script with the new column added). SSDT's build will compare the project schema to the target database and generate the necessary ALTERs for deployment[\[13\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,Statements%20in%20Project)[\[14\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2AWhy%20It%20Works%2A%2A%3A%20,regardless%20of%20whether%20table%20exists). In other words, you declare **what** you want, and the DACPAC deployment figures out **how** to apply it safely. This approach is called **state-based** deployment.
- **Team Training & Surveys:** We assessed the team's baseline via a readiness survey covering SQL fluency and related tools (Entity Framework, Liquibase, etc.)[\[15\]](file://file_00000000212861f88d9493c570cb38db#:~:text=,SQL%20experience)[\[16\]](file://file_00000000212861f88d9493c570cb38db#:~:text=,mappings%20between%20model%20and%20database). Based on that, resources were recommended. If you feel shaky on SQL fundamentals (e.g. complex JOINs, indexing) or haven't used migration tools before, take time **before cutover** to review those concepts. A few great resources:
- _SQL Basics:_ "SQL Fundamentals" course on Pluralsight or freeMode videos (if you only know SELECT/INSERT, a refresher is key).
- _SSDT Intro:_ Microsoft's official tutorial "Create and deploy a SQL project"[\[17\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=a%20database,be%20empty%20aside%20from%20the) - a step-by-step guide to building a database project and publishing it.
- _DACPAC Overview:_ Check out Fira S. Bouj's article on SQL schema versioning with DACPAC[\[10\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=review%20and%20ensuring%20your%20changes,and) which clearly explains how DACPAC deployments compare schema differences automatically.
- _OutSystems External Entities:_ OutSystems documentation on **Integrating with External Databases** (how to set up connections and import tables/views) - confirm you know how to use Integration Studio to connect to **External Table or View**[\[18\]](https://medium.com/noesis-low-code-solutions/external-databases-in-outsystems-environments-122e97fa2574#:~:text=Right%20clicking%20on%20%E2%80%9CEntities%E2%80%9D%20and,to%20External%20Table%20or%20View%E2%80%9D).
- **Environment Prep Checklist:** By the Friday before cutover, ensure:
- ‚òê **Tools installed** (VS + SSDT, SSMS, Integration Studio) and working.
- ‚òê **Access** to Dev/Test databases (credentials, network).
- ‚òê **Initial schema imported** into an SSDT project and project builds without errors.
- ‚òê **Hello World change** tested - e.g. add a practice column in a branch, build, and generate a script to see the ALTER[\[19\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,PhoneNumber%5D%20VARCHAR%2820%29%20NULL%3B).
- ‚òê **Slack channels** joined: #database-help for questions, #database-dev for deployment coordination, #database-emergency for urgent issues.
- ‚òê **Key guides bookmarked**: this document, and the quick reference playbooks for common tasks (adding a column, etc.).

By focusing on these items pre-cutover, you'll enter Day 1 with the tools and knowledge needed to contribute, rather than scrambling to install software or learn concepts under pressure.

## Post-Cutover Daily Workflow (Monday Onward)

Starting the Monday after cutover, our team will follow a **new daily rhythm** for database changes, centered on a **"release train"** model. The goal is a consistent, predictable workflow so everyone knows what to do and when.

### Daily Development & PR Cycle

**Morning/Afternoon Development:** Work on your OutSystems app and any required DB changes in tandem. Use a feature branch for your database project changes. When you're ready to integrate a DB change:

- **1\. Create a Pull Request (PR):** Commit your changes to your branch and open a PR in Git (e.g. Azure DevOps or GitHub). Use the PR template provided, which will prompt for details like _Why the change_, _Any breaking impact_, _OutSystems impact (do we need to refresh?)_, and _Testing done_. Tag your dev lead or assigned reviewer. **All database changes require a PR review** - no direct commits to main allowed[\[20\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,two%20people%20editing%20the).
- **2\. PR Submission Cutoff:** We follow a **2:00 PM cutoff** each day for PRs to be included in that day's deployment. This gives reviewers at least ~1 hour to review before the 3 PM deployment[\[21\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,Avoids%20blocking%20people%20first%20thing). If you miss the cutoff, your change will go out the next day (or later, depending on approvals). Plan your work accordingly - if you have a larger change, aim to submit the PR by late morning or before.
- **3\. Code Review & Approval:** A dev lead or senior dev will review your PR. They will check for things like build success, correct naming, data types, indexes on new foreign keys, idempotent scripts, etc. (see **Governance & Code Review** below). Our SLA for reviews is within 4 hours for simple changes (add column/table)[\[22\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=match%20at%20L527%20,15%20minutes) and within 1 business day for complex changes[\[23\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,60%20minutes). In practice, with the daily train, simple changes submitted by 2 PM should get same-day review. Reviewers will use a checklist to ensure consistency (e.g. no SELECT \*, no missing defaults on NOT NULL columns, etc.). _If the build is failing, the reviewer will bounce it back to you to fix before doing a full review_[\[24\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,%E2%94%9C%E2%94%80%20All%20green%3F%20%E2%86%92%20Continue)[\[25\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%94%9C%E2%94%80%20Quick%20Check%20,5%20min).
- **4\. Merge and Build:** Once approved, your PR is merged into the main branch. The continuous integration (CI) pipeline will automatically build the project and produce an updated DACPAC artifact. This CI build ensures everything still compiles on main and catches any merge issues early. Every commit to main triggers a build, so if something breaks, we know right away.

### 3:00 PM Daily Deployment (Release Train)

We batch deploy all the day's approved changes once per day at a set time. **At 3:00 PM** each workday, the designated **Deployer (Dev Lead or rotating senior dev)** will perform the **Dev environment deployment** using the latest DACPAC. The reason for batching once daily is to avoid constant interruptions and coordination overhead - one deployment = one required Integration Studio refresh for the team[\[26\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%E2%9D%8C%20Dev%20lead%20overwhelmed)[\[27\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%E2%9C%85%201%20deployment%20per%20day,Efficient%20use%20of%20time).

**Deployment process at 3:00 PM** (Dev environment): 1. **Announcement:** The deployer announces in Slack #database-dev that the deployment is starting, listing which PRs (features) are included[\[28\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2AStep%202%3A%20Pre,3%3A00%20PM)[\[29\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Duration%3A%20,). This heads-up allows everyone to prepare for the upcoming Integration Studio refresh. 2. **Pre-Deployment Checks:** The deployer ensures all merged PRs have a _green CI build_ (no failed builds), and that they have the latest code pulled. A quick deployment checklist is followed: - ‚úÖ Latest main pulled and **build succeeded** locally (no errors)[\[30\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Pre,dev)  
\- ‚úÖ All included changes have been reviewed/approved  
\- ‚úÖ Post a Slack message for visibility 3. **Generate & Review Script:** Using either Visual Studio Publish with **"Generate Script"** or the SqlPackage.exe /Action:Script command, the deployer generates the SQL diff script that will be applied[\[31\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,MyDatabase.dacpac)[\[32\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=SqlPackage.exe%20%2FAction%3AScript%20%60%20%2FSourceFile%3A,HHmm%27%29.sql%22). They **review the script** for sanity: we expect mostly ALTER TABLE ... ADD and CREATE statements for new things, _no unintended DROPs_. If they see a drop of a table or column, they double-check if it was expected (perhaps a rename) and that proper refactoring was done. This script review is a critical safety step[\[33\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,reasonable)[\[34\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,). 4. **Execute Deployment:** The deployer runs the script (or lets the publish operation execute). This updates the Dev database to match the new schema. They watch the output for any errors. Common errors could be timeouts or data issues (the pipeline sets BlockOnPossibleDataLoss=True to abort if a change would drop data without explicit override[\[35\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=If%20drift%20is%20detected%20,on%20using%20SSDT%2C%20interpreting%20schema)). If any error occurs, they stop and coordinate a fix (possibly backing out the offending change). 5. **Post-Deploy Verification:** Once the script runs with **"Publish succeeded"**, the deployer might run a few quick queries to verify changes (e.g. select top 1 from a new table, ensure a new column exists with default values, etc.). Then they post a confirmation in Slack that "Deployment completed". **Important:** the database schema is now updated, but OutSystems is not aware of these changes yet - that's the next step.

### 3:30 PM Integration Studio Refresh (External Entities)

After the DB deployment, **all OutSystems developers must refresh their external entities** to avoid runtime errors. OutSystems **caches the schema** of external database entities; if, for example, a new column was added, OutSystems will throw errors (like "Invalid attribute") when using it until the mapping is refreshed[\[36\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,Studio%20Refresh)[\[37\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=1,use%20in%20OutSystems%20%E2%9C%85). We handle this via a coordinated daily refresh:

- **3:30 PM Team Refresh:** The dev lead will send out a Slack announcement in #database-dev at 3:30 PM: _"üîî Integration Studio Refresh Time"_, listing the day's changes and which OutSystems extensions/applications are affected[\[38\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%F0%9F%94%94%20Integration%20Studio%20Refresh%20Time)[\[39\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=1,Confirm%20in%20thread%20when%20done). Everyone who works on those apps should follow along. The message outlines the steps:
- Save your work in Service Studio (so you can reconnect dependencies after).
- Open **Integration Studio**, open the relevant extension (e.g. MyApp_Database).
- For each changed entity (table), right-click and **Refresh** it[\[40\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%5BYourName%5D%22).
- Verify new columns or changes show up (new attributes in green, modified in yellow)[\[41\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=2,%5BYourName%5D%22).
- Click **Apply** and then **Publish** the extension.
- Reply in Slack thread with "‚úÖ Done - \[Name\]".
- **Dev Lead Coordination:** At 3:45 PM, the lead checks off that all affected developers have completed the refresh[\[42\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,No%20%E2%86%92%20Ping%20missing%20people). If someone is missing, they'll get pinged - it's important not to skip this if your app is impacted, or testing will fail. Once confirmed, it's "all clear" to resume normal work or testing on OutSystems.
- **Missed Refresh or Off-Hours:** If you missed the window (say you were in a meeting), you should do an **individual refresh** as soon as possible and post a note ("Refreshed X extension at 4:15 PM")[\[43\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,3.%20Test%20your%20app). We prefer the group refresh for consistency, but understand not everyone can always do 3:30. If you need to refresh at a different time (e.g. an urgent fix at 11 AM, or working late), follow the **Ad-Hoc Refresh Protocol**: announce your intent in Slack, wait a few minutes for objections (to ensure you're not disrupting someone), then proceed and announce completion[\[44\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%23%20Ad,window)[\[45\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=2,testing%20with%20old%20schema). In a true production emergency, you can skip the formalities - do the refresh needed and inform after[\[46\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,emergency).

**Never forget**: _Database changes first, OutSystems refresh second_. The pipeline deploys the DB changes, then OutSystems is updated to align[\[47\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=match%20at%20L92%20them,never%20the%20reverse). Doing the reverse (changing OutSystems before the DB) is not allowed - it will cause immediate runtime errors. Always ensure the external DB changes are deployed (or at least the script reviewed if in a testing stage) _before_ publishing any OutSystems module that depends on them.

### Working Model Summary (Mon-Fri)

Putting it together, here's the **week 1 working model**:

- **Morning Standup:** Share what DB changes you plan, any blockers with SSDT, etc. (On **Cutover Monday**, we did an extended standup with a demo of the new workflow[\[48\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=)).
- **Daytime:** Develop features as usual. When a feature requires a DB change, make the change in the SSDT project and build/test locally. Pair with others or ask in Slack if you get stuck (especially first few days).
- **By 2:00 PM:** Aim to have your PR submitted if you want it in that day's deployment. Use the PR template and double-check your build is passing.
- **2:00-3:00 PM:** Reviewers (dev leads/seniors) review incoming PRs. They may ask questions or request fixes. Be responsive; if you address feedback quickly, your change can still make the train.
- **3:00 PM:** Deployment window. Dev lead (initially) runs the batch deployment to Dev environment for all merged PRs. They narrate in Slack for transparency[\[49\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=3%3A00%20PM%3A%20First%20batch%20deployment,communicate).
- **3:30 PM:** Integration Studio refresh window. All devs participate to update external entities. After this, the apps and DB are in sync and testing can happen.
- **After 4:00 PM:** Normal work resumes. If a change missed the train or new issues were found, they go into next day's cycle. Use the late afternoon to update any documentation, assist others, or plan tomorrow's tasks.
- **End of Week Retrospective:** On the first Friday, we held a retro to adjust the process[\[50\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=). Keep an eye on team comms; improvements (e.g. adjusting PR cutoff time or SLA) may be made as we refine the workflow.

## Governance & Code Review Practices

One of the biggest shifts in this transition is **database governance** - treating schema changes with the same rigor as code changes. Every PR is a gate where we enforce standards and best practices. As a developer, knowing what reviewers look for will help you self-review your work and avoid common mistakes.

**Pull Request Requirements:** - **Build Passes:** Your SSDT project **must build without errors** before you create a PR. Committers should run a local build (Ctrl+Shift+B in Visual Studio) to verify no syntax or reference errors. The PR pipeline will also build and won't allow merging if build fails. If a PR is opened with a red ‚ùå build, the first review comment will simply be "Build failed - please fix errors and re-submit"[\[24\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,%E2%94%9C%E2%94%80%20All%20green%3F%20%E2%86%92%20Continue)[\[51\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=). - **Descriptive PR Description:** Explain the _why_ of the change, not just the _what_. Mention if the change is backward-compatible or if it requires coordination (e.g. a corresponding app change). Document any **OutSystems impact** ("Refresh Integration Studio for X extension after deploy"). This context helps reviewers and future maintainers[\[52\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=5.%20Description%3A%20,)[\[53\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=%2A%2A%E2%9A%A0%EF%B8%8F%20CRITICAL%20STEP%20,skip). - **Link Work Items:** If your team uses Azure Boards or Jira, link the user story or ticket. Every DB change should trace to a requirement - part of our governance is ensuring changes are justified and tracked[\[3\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=something%20does%20fail%2C%20you%20have,schema%20changes%20being%20deployed%20via)[\[5\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,schema%20issues%20drop%20to%20zero). - **No WIP or Draft PRs:** The daily deployment model expects that by the time you create a PR, it's ready for review and merge that day. If it's a work in progress, wait to file the PR (or clearly mark it as Draft). This avoids confusion on what's ready.

**What Reviewers Check (Code Review Checklist Highlights):** 1. **Correctness & Safety:** Does the change do what it's supposed to? Are there any unintended side effects? For example, if a column is renamed, was the SSDT **refactor/rename** feature used (so a refactor log is included) or did the dev drop and recreate the column (which would lose data - a red flag)? If a column was meant to be NOT NULL, did we ensure a default or a data migration so deployment won't fail? These logical sanity checks are top priority. 2. **Schema Conventions:** We follow standard naming and design conventions. Reviewers will flag deviations: - Table names **singular** (e.g. Customer, not Customers)[\[54\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Tables%3A%20%E2%98%90%20Singular%20noun%20,Product%20not%20tblProduct)[\[55\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Primary%20Keys%3A%20%E2%98%90%20,%E2%98%90%20NOT%20NULL%20PRIMARY%20KEY). - PascalCase for all identifiers (no snake_case, no all-lowercase)[\[56\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,Product%20not%20tblProduct)[\[57\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%9D%8C%20,). - Primary keys named TableNameId, int identity by default[\[58\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Primary%20Keys%3A%20%E2%98%90%20,%E2%98%90%20NOT%20NULL%20PRIMARY%20KEY). - Foreign key constraints named FK_Child_Parent and every FK column has an index[\[59\]\[60\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,CustomerId%5D%29%3B%20GO). - Indexes named IX_Table_Column (or IX_Table_Col1_Col2 for composite)[\[61\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Indexes%3A%20%E2%98%90%20IX_TableName_Column1_Column2%20%E2%98%90%20Example%3A,IX_Orders_CustomerId_OrderDate). - Default constraints named DF_Table_Column and check constraints CK_Table_Column. If your change introduces new tables or columns, ensure they follow these patterns. The review checklist explicitly covers naming rules and will call out issues (e.g. "please rename Orders table to Order for singular noun convention"[\[62\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=)).

- **Data Types & Sizing:** We have preferred data types:
- Use **NVARCHAR(n)** for any text that might include user input or need Unicode (names, addresses)[\[63\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%60%60%60%20%E2%98%90%20User,)[\[64\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%9D%8C%20,%E2%9D%8C). Only use VARCHAR for truly non-Unicode data (e.g. a code column or if saving space and certain input).
- Use **DATETIME2** instead of legacy DATETIME for date/time[\[63\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%60%60%60%20%E2%98%90%20User,)[\[65\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=).
- Use **DECIMAL(10,2)** for currency/amounts (avoid FLOAT due to rounding)[\[63\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%60%60%60%20%E2%98%90%20User,)[\[66\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%9D%8C%20,%E2%9D%8C%20Rounding%20errors).
- Only use NVARCHAR(MAX) or VARBINARY(MAX) if absolutely needed (they have performance and storage impacts)[\[67\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=).
- BIT for boolean flags (rather than char(1) or tinyint for true/false). Reviewers will scan new/changed columns for these. A common example: if someone uses VARCHAR(50) for a Name column, the reviewer might say "Use NVARCHAR for names to support Unicode"[\[64\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%9D%8C%20,%E2%9D%8C).
- **Nullability & Defaults:** Adding a NOT NULL column to an existing table is potentially breaking. The review will check:
- If a new column is NOT NULL, does it either have a DEFAULT value or is the table new/empty? If not, deployment will fail. Best practice is to add as NULL with a default, backfill data in a post-script, then make NOT NULL in a later deployment (two-phase)[\[68\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,deployment%20migration)[\[69\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%E2%9D%8C). Reviewers ensure no "NOT NULL without default on existing table" errors[\[70\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=).
- Are foreign keys correctly NOT NULL (if we expect a child always has a parent)? E.g. Order.CustomerId should likely be NOT NULL - a reviewer will ask if it's NULL without a good reason[\[71\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=).
- Required business fields should be NOT NULL; optional fields NULL. It's about data integrity. The checklist covers this explicitly[\[72\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,DEFAULT%20or%20migration%20plan%3F).
- **Indexes & Performance:** For any new table or significant change:
- Every foreign key column must have an index (to prevent table scan on joins)[\[73\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,CustomerId%5D%29%3B%20GO)[\[74\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=). If you add an FK, ensure you either created an index or mention that an existing index covers it.
- Consider common queries: if a new table will be queried by a certain column often, an index should be added preemptively. Reviewers might ask "Do we need an index on the IsActive flag or OrderDate for sorting?" and suggest it if missing.
- Avoid **SELECT**\* in any views or procedures - always list columns. This prevents unexpected issues when columns change. If a view is included and it uses SELECT \*, expect a request to change it to explicit column list (and ideally consider whether the view is needed or an OutSystems aggregate can suffice)[\[75\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,in%20Views%2FProcedures).
- **Scripts Idempotence:** SSDT supports pre- and post-deployment scripts for data fixes or reference data. Any such script **must be idempotent** (safe to run multiple times)[\[76\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADon%27t%20Do%20This%2A%2A%3A%20%60%60%60sql%20,2%2C%20%27Processing%27%29%3B)[\[77\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADo%20This%20Instead%2A%2A%3A%20%60%60%60sql%20,StatusId). Reviewers will scan for patterns like plain INSERTs that could cause primary key violations on re-deploy. The correct approach is to use MERGE or IF NOT EXISTS checks[\[77\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADo%20This%20Instead%2A%2A%3A%20%60%60%60sql%20,StatusId)[\[78\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%60%60%60sql%20,1%2C%20%27Pending%27%29%3B%20END). If your PR includes a data script, double-check it's re-runnable. If not, you'll get a comment to fix it.
- **OutSystems Impact:** If the change affects OutSystems, reviewers ensure there's a note (either in PR description or code comments) reminding to refresh the extension. They might not reject a PR solely for that, but it's part of our culture to always link the two. Also, for breaking changes (like removing a column that OutSystems uses), the PR should include a plan for handling the OutSystems side (perhaps deploying a new version of the app that no longer expects that column, _after_ the DB change). These need careful coordination and will get extra scrutiny in review.
- **Automated Checks:** Our pipeline and tools also enforce some quality gates:
- The build must pass (already discussed).
- We may have a Schema Comparison in PR validation that flags if your change script includes any DROP statements (which would warn of data loss). Reviewers will pay special attention to any destructive changes.
- Static code analysis (if any) for SQL code issues - for example, SSDT can warn about unresolved references or certain deprecated syntax.

**Developer Expectations:** As an OutSystems dev now doing DB work, you're expected to **self-review** against these criteria before submitting. Use the checklist format yourself:

‚òê Build succeeds with 0 errors  
‚òê Naming conventions followed (singular, PascalCase, etc.)  
‚òê Data types appropriate (NVARCHAR vs VARCHAR, etc.)  
‚òê Defaults provided for new NOT NULL columns  
‚òê Indexes on new foreign keys  
‚òê Scripts idempotent (if applicable)  
‚òê OutSystems refresh noted (if applicable)

Tick these off mentally (or literally) to ensure your PR is solid. If something is unclear - **ask!** The #database-help Slack is there, and dev leads would rather you ask a "silly" question beforehand than miss something critical and cause a deployment issue.

Finally, all PR reviews are meant to be learning opportunities, especially in the early weeks. Don't be discouraged by feedback; even senior devs get detailed reviews. The goal is to **level up everyone's SQL DevOps skills** and catch issues early. Over time, you'll incorporate these checks habitually and reviews will go quicker.

## SSDT & DACPAC Upskilling Resources

Moving from OutSystems visual development to managing a database project in Visual Studio can be daunting. This section provides targeted resources to build your fluency in SQL and SSDT:

- **SSDT Concepts Primer:** If you learn one thing, learn this: **SSDT = Visual Studio for Databases**. It lets you develop **offline** - you make changes to create scripts in a project, not directly on a live DB[\[79\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=What%20is%20SSDT%20,Data%20Tools). Key points to explore:
- _Projects & Schema Modeling:_ Understand the layout of a database project (.sqlproj). Every object (table, view, procedure) is a script file. No ALTER statements - you define the final state in CREATE scripts.
- _Build = DACPAC:_ When you build the project, SSDT compiles all those scripts into a DACPAC file[\[10\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=review%20and%20ensuring%20your%20changes,and)[\[47\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=match%20at%20L92%20them,never%20the%20reverse). The DACPAC is a binary representation of the schema. It's what we deploy to apply changes.
- _Publish & Schema Compare:_ You can publish a DACPAC to a database, which essentially does a schema diff and runs the needed alterations. SSDT's Schema Compare tool is very handy - it shows a visual diff between your project and a target DB, and you can even generate the script without applying it[\[80\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=issues%29.%20,Schema%20Compare%20result%20will%20show)[\[81\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=and%2Cany,change%20to%20the%20development%20database). Use this to preview complex changes.
- _Refactor Log:_ Learn about the refactor log (Refactor.sql file) which SSDT uses to handle renames safely. If you rename a table or column via the Visual Studio **Refactor ‚Üí Rename** command, it records a mapping so that deployment knows the change is a rename, not a drop/add. This avoids data loss on renames. Always use this for renames - never just change the object name in the CREATE script without the refactor step[\[82\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=)[\[83\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,Build%20again).
- **DACPAC Deployment Deep-Dive:** As mentioned, DACPAC deployment is state-based. It will compare the DACPAC's model to the target and generate a diff script:
- The **SqlPackage** utility is the engine under the hood (and in Azure pipelines). It has parameters to control behavior (like BlockOnPossibleDataLoss, DropObjectsNotInSource, etc.). We typically enable BlockOnPossibleDataLoss=True to _prevent_ accidental data drops[\[35\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=If%20drift%20is%20detected%20,on%20using%20SSDT%2C%20interpreting%20schema). If you do need to drop something, you either disable that (rare, for controlled situations) or do a two-step (e.g. drop in a separate deployment after migration).
- Recognize that **not all changes are trivial**: adding a column is easy (ALTER TABLE ADD), but dropping or renaming is trickier (rename becomes "create new + drop old" unless refactorlog is used). Study how SSDT handles each case. The Eitan Blumin webinar series (especially Part 4 on troubleshooting SSDT deployment issues) is a great advanced resource[\[84\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=unit%20testing,DevOps%20discuss%20cultural%20and%20process) for understanding edge cases and errors.
- **Tip:** If curious, open a DACPAC with a zip tool - it's basically an XML of the model. But you usually don't need to; Schema Compare and script generation give you the info you need.
- **SQL Fluency:** While most on the team know SQL, if you feel weaker on writing SQL or understanding execution plans:
- Use the _AdventureWorks sample database_ to practice writing queries or altering schema in a sandbox.
- Microsoft's free SQL learning resources and the classic "SQL Zoo" exercises can help sharpen your skills in a hands-on way.
- Be comfortable with writing a simple query to verify data, or an update script for a migration. We aren't expecting you to write stored procedures (OutSystems still handles most logic), but knowing T-SQL basics is important for verifying and sometimes for advanced data fixes.
- **OutSystems Integration Studio:** Make sure you can navigate Integration Studio confidently:
- **Refresh vs. Import:** We are using **Refresh** on existing entities after deployments. But sometimes you might need to bring in a brand new table to OutSystems. You do this by **"Connect to External Table or View"** in Integration Studio[\[18\]](https://medium.com/noesis-low-code-solutions/external-databases-in-outsystems-environments-122e97fa2574#:~:text=Right%20clicking%20on%20%E2%80%9CEntities%E2%80%9D%20and,to%20External%20Table%20or%20View%E2%80%9D). The wizard lets you pick the new table (or a database view) and it will be added to the extension. Then publish. If you add a table in the DB that OutSystems needs to use, coordinate with your tech lead on when to import it (likely right after it's deployed to Dev).
- **Entities vs Views (Usage Pattern):** OutSystems allows connecting to a view just like a table, which can be useful. **When to use a view?** If you want to decouple the OutSystems module from schema changes or complex joins, a view can present data in a stable format. For example, if you anticipate frequent changes to a table's structure, you might create a view that selects essential columns for OutSystems, and have OutSystems use that. This way, adding a new column to the table doesn't immediately break OutSystems - you can update the view on your timeline. The tradeoff is performance and updatability (views can be read-only depending on complexity). Generally, prefer direct table binds for simplicity, but remember the view option exists if it helps as a **safe abstraction layer**.
- **Data Type Mappings:** OutSystems will map SQL types to its own types. Most are straightforward (int ‚Üí Integer, nvarchar ‚Üí Text, bit ‚Üí Boolean)[\[85\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=4.%20%2A%2ARight,Click%20Apply). After a refresh, always check that the new/changed fields have the expected properties (Length, Mandatory vs Optional)[\[86\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=1.%20,Type%3A%20Text%20Length%3A%2020). If something looks off, you might need to adjust the SQL definition or how you imported it.
- **Integration Studio Warnings:** Sometimes after refresh, you might see warnings in TrueChange about entities. Often this is because an entity's definition changed (e.g. a field length increased) - you'll need to re-publish the consumer modules (the OutSystems applications) so they get the updated entity definition. Usually refreshing and publishing the extension is enough, but keep an eye out for any lingering warnings in Service Studio.
- **Learning Path & Further Study:** We've prepared a more detailed **Learning Path document** (Stage 1 to 3 progression) for those who want to deeply understand SQL DevOps. It covers from basic project setup to CI/CD pipeline setup to advanced topics like tSQLt (SQL unit tests) and performance tuning[\[87\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=_Study%20Resources%20for%20Stage%203%3A_,based)[\[88\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=official%20tSQLt%20site%20and%20its,DevOps%20discuss%20cultural%20and%20process). New joiners can use that as a self-study guide over the first couple of months. Highlights include:
- Stage 1: Setting up your first project, basic schema ops[\[89\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=Stage%201%3A%20Foundation%20%28Weeks%201,%E2%9C%94%EF%B8%8F)[\[90\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,Release%20folder%20for%20a).
- Stage 2: Integrating with build/release pipelines (CI/CD)[\[91\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,or%20just%20immediately%20if%20following)[\[92\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,and%20no%20one%20is%20directly).
- Stage 3: Mastery - advanced refactorings, data migrations, team governance, automated testing (SQL unit tests)[\[3\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=something%20does%20fail%2C%20you%20have,schema%20changes%20being%20deployed%20via)[\[5\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,schema%20issues%20drop%20to%20zero).

Leverage these materials as you grow. Don't hesitate to ask the DB platform team if you need guidance on what to focus on next. Our aim is to have every developer comfortable making and deploying a schema change by end of the first month.

## Best Practices & Common Pitfalls (Dos and Don'ts)

Shifting to this new workflow, there are some common pitfalls to avoid. Here is a "Top 10" of best practices and anti-patterns to keep in mind:

**1\. DO work in the SSDT project, DON'T bypass it:** It may be tempting when in a rush to just run a quick ALTER in SSMS on the database. **Do not do this**. Any change not in the project will be overwritten (or cause drift) and is considered a process violation. All schema changes must go through the project and pipeline for tracking[\[93\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=Read%20%5BTop%2010%20Anti,DON%27T%20commit%20without%20building%20first). The project is the source of truth. If you **manually ALTER a table in SSMS**, your colleagues will not have that change and things will break. Instead, always make the change in the .sql file and build it. The pipeline deployment will apply the actual ALTER for you[\[13\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,Statements%20in%20Project)[\[14\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2AWhy%20It%20Works%2A%2A%3A%20,regardless%20of%20whether%20table%20exists).

**2\. DO add** CREATE **statements, DON'T write** ALTER **in scripts:** In SSDT, if you want to change an object, you edit its CREATE definition. **Never put an ALTER TABLE...ADD column in a table script file**[\[13\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,Statements%20in%20Project). If you do, the build will fail or the deployment will get confused. The correct method: open the table's .sql file (which has the full CREATE TABLE), insert your new column in the definition with the appropriate type, save and build. SSDT will figure out that this means an ALTER on deployment[\[14\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2AWhy%20It%20Works%2A%2A%3A%20,regardless%20of%20whether%20table%20exists). The same goes for stored procs or views: modify the CREATE script directly.

**3\. DO use refactoring tools for renames, DON'T drop and recreate:** Renaming a column or table? Use **Refactor ‚Üí Rename** in Visual Studio. This ensures the change is captured in the project's refactor log and the deployment will perform a true rename (preserving data) rather than a drop-and-add[\[82\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=)[\[83\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,Build%20again). If you just change the name in the CREATE script, SSDT will think "old object was dropped, new one added" - meaning it would drop the table/column (losing data) and create a new one. That's dangerous and often blocked. The refactor log avoids this. **Never** manually drop a column/table that has data without a migration plan (and usually, migration should be done first, then drop in a later release).

**4\. DO make scripts idempotent, DON'T assume one-time run:** For any **post-deployment script** (like seeding reference data or backfilling data), write it so if it runs twice, it doesn't break or duplicate data. Example anti-pattern: INSERT INTO Status VALUES (1,'Pending') will fail the second time (duplicate PK)[\[94\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=,2%2C%20%27Processing%27%29%3B)[\[95\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADo%20This%20Instead%2A%2A%3A%20%60%60%60sql%20,StatusId%20WHEN%20NOT%20MATCHED%20THEN). Instead use a MERGE or an IF NOT EXISTS check[\[95\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADo%20This%20Instead%2A%2A%3A%20%60%60%60sql%20,StatusId%20WHEN%20NOT%20MATCHED%20THEN)[\[78\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%60%60%60sql%20,1%2C%20%27Pending%27%29%3B%20END). This way, if the deployment runs again (or the script runs in multiple envs), it remains safe. Our deployment approach might run post-scripts on every deploy, so this is crucial. **Test your script** by running it twice on a dev database to ensure it behaves (no extra rows, etc.).

**5\. DO think about data volume for changes:** Adding a column to a huge table or changing a datatype can lock up the table during deployment. We haven't hit big volumes yet, but be mindful. If a table has millions of rows and you add a NOT NULL column with default, that will update every row - consider doing it as NULL then backfill. If you need to make a large change, discuss with leads about doing it in off-hours or using partitioning techniques. While not daily concerns, performance and deployment time matter. A "quick" change could be an hour of downtime on a large table if done wrong.

**6\. DON'T use SELECT \* in any persisted object or OutSystems queries:** This is a general SQL best practice (to avoid pulling unnecessary columns and to prevent breakage when columns change). In context of OutSystems, if you use an Advanced Query with SELECT \* against an external entity, and later someone adds a column, that query might start failing or pulling wrong data (since OutSystems might not map the new column). Always select the columns you need explicitly. In database views or stored procedures, same rule: explicitly list columns. This makes schema evolution easier (new columns can be added without impacting existing queries that don't need them).

**7\. DON'T forget to** refresh OutSystems **after any schema change:** We've said it multiple times, but it bears repeating - forgetting to refresh the external entities after a DB deploy will cause errors[\[96\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=,error)[\[97\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=4,use%20in%20OutSystems%20%E2%9C%85). If you ever see an error on an aggregate or query complaining about an invalid column or something missing, ask yourself "Did I refresh the extension after the latest deployment?". This is the #1 cause of post-deployment bugs in this integration scenario. The **OutSystems Integration Studio Refresh** is just as important as the DB deployment itself in our process. Make it a habit: every time you deploy or get a deployment notification, go refresh _immediately_ if it touches your area.

**8\. DO communicate and consult:** If you're unsure about how to model something in the DB, or whether a change might have side effects, raise it early. The team has a lot of collective knowledge - e.g., _"I need to store a large JSON in the DB, should I use NVARCHAR(MAX) or a separate table?"_ - these design decisions benefit from discussion. Use standups, Slack, or a quick call with a senior dev. It's easier to adjust a plan _before_ coding than to fix a problematic design later. Also, if your change might affect others (e.g., modifying a shared reference table), give folks a heads-up.

**9\. DO keep schema and data in sync with OutSystems expectations:** OutSystems has certain patterns - for example, foreign keys on external entities aren't automatically recognized as relationships in Service Studio. You might consider creating DB **views** to provide friendlier data to OutSystems. A pattern used in some teams is to have **OutSystems-facing views** that the apps use, while the underlying tables can be more normalized. This can reduce complexity in OutSystems aggregates. If you choose to do that, ensure the view is kept updated with schema changes. Another example: if OutSystems expects a certain default (like CreatedDate defaulting to now), ensure the DB default matches to avoid surprises. Basically, treat the OutSystems-consuming side as a first-class consumer of your DB design.

**10\. DO practice with the tooling on small changes:** Experience is the best teacher. In your first week, try a few trivial tasks in a safe sandbox: e.g., add a column in the project, build, deploy to a throwaway database, refresh in Integration Studio, see the full cycle. Or intentionally introduce a build error (like reference a non-existent table) to see what the error looks like. The more comfortable you get with the SSDT feedback cycle and the pipeline, the faster you'll be when real tasks come. We have "playbook" documents for common scenarios (Add Column, Add Table, etc.) - refer to them (and this guide cites many of their tips). For instance, here's a quick decision tree for adding a column:

Need to add a column?  
‚îÇ  
‚îú‚îÄ Does table have data already?  
‚îÇ ‚îú‚îÄ YES ‚Üí Can it be NULL?  
‚îÇ ‚îÇ ‚îú‚îÄ YES ‚Üí Add as NULL (simplest)  
‚îÇ ‚îÇ ‚îî‚îÄ NO ‚Üí Must provide DEFAULT value  
‚îÇ ‚îî‚îÄ NO (new table) ‚Üí Can be NOT NULL without DEFAULT  
‚îÇ  
‚îî‚îÄ Will OutSystems use this column?  
‚îú‚îÄ YES ‚Üí Must refresh Integration Studio after deployment  
‚îî‚îÄ NO ‚Üí DB-only change, no OutSystems refresh needed  
\`\`\`\[98\]  
<br/>This illustrates thinking through \*\*nullability\*\* and \*\*OutSystems impact\*\* before implementation. Similar patterns apply for other changes.  
<br/>By adhering to these best practices and avoiding the "don'ts," you will prevent the majority of issues new SSDT users face. We've all been there - accidentally left out a comma and broke the build, forgot to include an index and got a slow query - but with this guide and the playbooks as references, you can anticipate and dodge those pitfalls.  
<br/>\## Roles & Responsibilities - Swim Lanes for the Team  
Our team has a mix of experience levels. To make responsibilities clear, we've defined \*\*"swim lanes"\*\* for Junior, Mid-Level, Senior, and Lead developers in the context of database DevOps. This helps everyone know their focus areas and where to get involved or seek help. Of course, these are guidelines - individuals can grow into the next lane - but they help set expectations especially during onboarding.  
<br/>\### Junior Developers (0-1 year DB experience)  
\*\*Profile:\*\* Most of the team on cutover day falls here, as we are all new to SSDT. Juniors have basic SQL knowledge (comfortable with SELECTs, maybe created a table or two) but are new to database projects and CI/CD. First 1-3 months in this workflow.  
<br/>\*\*What Juniors \*can\* do (independently):\*\* Simple, additive schema changes and routine tasks with guidance from playbooks:  
\- ‚úÖ Add a \*\*nullable column\*\* to an existing table\[99\] (e.g. add \`PhoneNumber VARCHAR(20) NULL\` to \`Customer\` table).  
\- ‚úÖ Create a \*\*new table\*\* that is simple (no complex FK relationships beyond maybe one parent)\[99\].  
\- ‚úÖ Add an \*\*index\*\* on a single column (or add a missing index to support a query).  
\- ‚úÖ Update \*\*reference data\*\* via post-deployment script (e.g. insert a new lookup value)\[99\].  
\- ‚úÖ Run through the \*\*PR -> deploy -> refresh\*\* process for their own changes (follow checklists to create PR, build, etc. and refresh Integration Studio after deployment)\[100\].  
<br/>\*Process-wise\*, juniors are expected to:  
\- Open PRs with the provided template and respond promptly to review comments\[100\].  
\- Always build and test locally before pushing\[100\].  
\- Perform Integration Studio refresh following the guide (no skipping)\[100\].  
\- Test their OutSystems app after refresh to ensure everything is wired up.  
\- Attend daily deployment and refresh activities and ask questions if unclear.  
<br/>\*\*Learning & Growth for Juniors:\*\*  
\- Read the provided playbooks and documentation (like this guide) - lots of answers are there\[101\].  
\- Ask questions in \`#database-help\` - no question is dumb. Better to ask than be stuck or do something risky\[101\].  
\- Pair up with senior devs on complex changes to observe and learn (e.g. join a screen share when a senior is doing a refactor)\[102\].  
\- Take advantage of office hours or any training sessions. Practice on a sample or local database to build confidence.  
<br/>\*\*Where Juniors need guidance (don't do alone yet):\*\*  
\- üü° Adding a NOT NULL column to a table that already has data (requires understanding defaults and potential backfill)\[68\].  
\- üü° Adding a foreign key relationship (making sure to create the FK constraint and an index, and possibly handling existing data)\[68\].  
\- üü° Writing a more complex multi-step \*\*post-deployment script\*\* (like migrating data from one table to another)\[68\].  
\- üü° Resolving merge conflicts in the SSDT project or uncommon build errors they haven't seen\[103\].  
\- üü° Performance-tuning a slow query (index tuning beyond the basics)\[103\].  
\- üü° Troubleshooting Integration Studio connection issues or odd errors on refresh\[103\].  
<br/>For these, a junior should pull in a senior or lead to pair program or guide them through it. Typically 15-30 minutes of guided help can solve it and impart knowledge for next time\[104\]\[105\].  
<br/>\*\*What Juniors should NOT do on their own (high risk):\*\*  
\- ‚ùå Any change that risks data loss or major refactoring: renaming tables/columns, dropping tables or columns, changing a data type on a populated column, splitting or merging tables, large data migrations\[106\]. These all require planning and experience; a senior will either handle or closely supervise these.  
\- ‚ùå Deploying to an environment by themselves (in the first month)\[107\]. Initial deployments are done by leads/seniors until juniors learn the ropes.  
\- ‚ùå Approving other people's PRs or defining architecture/standards\[107\]. A junior might review a peer's PR as a learning exercise, but a senior should co-review.  
\- ‚ùå Troubleshooting production issues. In a production incident, juniors should alert seniors/leads and assist as asked, but not be the point person yet.  
<br/>The reasoning is to avoid critical mistakes in areas that require broader context. Over time, juniors will get exposure to these by pairing and eventually handle them, but not right away\[108\]\[109\].  
<br/>\*\*Growth milestones for Junior devs:\*\* We expect that by end of \*\*Week 1\*\*, a junior can independently do a basic schema change and follow the process:  
\- By Friday of Week 1: they should have added at least one column or table via SSDT, successfully gotten it deployed, and refreshed OutSystems\[110\]. Also be comfortable with the daily routine (not missing the 3:30 refresh, etc.).  
\- By end of \*\*Month 1\*\*: handle ~80% of common changes without help (e.g. most adds/edits)\[111\], write basic post-deployment scripts correctly, know how to create needed indexes, and start resolving simple issues on their own. They should also start reviewing fellow juniors' small PRs and needing less hand-holding day to day\[111\].  
\- By end of \*\*Month 3\*\*: be ready to step up to mid-level. This means they can tackle a broader range (like a not-null addition with default) and even mentor newer hires or juniors who join\[112\]. Also, they should handle merge conflicts alone and have a grasp of query optimizations for simpler cases\[112\].  
<br/>\### Mid-Level Developers (1-2 years DB experience)  
\*\*Profile:\*\* Mid-level devs have more experience with databases and by now are comfortable with the SSDT workflow. They can work largely independently on most tasks and have probably seen the common gotchas at least once.  
<br/>\*\*What Mid-levels \*can\* do (independently):\*\* Everything a junior can, plus more advanced tasks:  
\- ‚úÖ Add NOT NULL columns to large tables \*with appropriate defaults or migrations\* (they know to handle the existing data)\[113\].  
\- ‚úÖ Design new tables including those with multiple foreign keys, and create all necessary FKs and indexes (covering indexes, composite keys as needed)\[113\].  
\- ‚úÖ Write multi-step post-deployment scripts (e.g. backfill data from one structure to another) and ensure they are idempotent\[113\].  
\- ‚úÖ Handle most merge conflicts in Git for the database project - they understand how to merge two developers' table changes, including resolving refactor log conflicts.  
\- ‚úÖ Troubleshoot build errors or deployment errors that come up (missing ref, incorrect syntax, etc.) without immediate help - they've likely encountered these and know the fixes.  
\- ‚úÖ Review PRs from junior devs, providing meaningful feedback and catching issues.  
\- ‚úÖ Execute the daily deployment process (following the checklist) as a rotation duty\[114\]\[115\]. By now, mid-levels can run the 3 PM deployment if assigned, ensuring they follow all steps.  
<br/>Examples of tasks a mid-level might handle solo:  
\- Adding a new \`OrderItems\` table with FKs to \`Orders\` and \`Products\` and including all supporting nonclustered indexes in the script\[116\]\[59\].  
\- Backfilling a newly added \`PhoneNumber\` column by copying data from an old \`ContactInfo\` text field into the structured column, via a post-deployment script (with checks to not duplicate).  
\- Creating a covering index to improve a slow query identified by the team, and verifying its usage.  
\- Resolving a merge conflict where two devs added different columns to the same table - merging the CREATE script lines and ensuring both get deployed\[117\]\[118\].  
<br/>\*\*Where Mid-levels might seek guidance:\*\* They are mostly independent, but for \*very complex or high-impact changes\*, they should consult seniors/leads:  
\- üü° Major \*\*refactoring\*\* of a table (splitting one table into two, or merging tables).  
\- üü° Data type changes on huge tables that might require special deployment approaches (like switching an INT to BIGINT on a 50M row table).  
\- üü° Performance tuning for really complex queries or index design that spans multiple tables (maybe involving index intersections, advanced indexing strategies).  
\- üü° Any change that could break multiple applications or requires cross-team coordination (e.g. a shared DB used by multiple apps).  
\- üü° Troubleshooting an \*\*unusual deployment failure\*\* that isn't solved by the usual checks (like a weird DACPAC bug or environmental issue). Mid-levels will try first, but if 30 minutes of effort doesn't solve it, escalate to a senior.  
<br/>In those cases, the mid-level should involve a senior dev or the staff/lead to discuss design and approach\[119\]\[120\]. Often an architecture discussion or whiteboard session is enough to set the direction.  
<br/>\*\*What Mid-levels should NOT do alone:\*\* (these are more leadership or very advanced moves)  
\- ‚ùå Set or change architectural patterns or team-wide standards without lead approval. For instance, deciding "let's store all dates as UNIX timestamps instead of DateTime" - that's a big decision requiring lead input\[121\].  
\- ‚ùå Production deployments (until they have been trained/approved by leads). Mid-levels might assist, but typically seniors or leads handle production releases because of the risk.  
\- ‚ùå Handle cross-team database changes alone - e.g. if a change impacts another department's system or requires coordination with an external DBA, loop in the lead.  
<br/>\*\*Responsibilities of Mid-levels:\*\* Beyond coding:  
\- They should mentor junior devs. This means being available to answer questions, doing paired programming on occasion, and reviewing juniors' PRs daily\[114\]. This not only helps juniors grow but also reduces lead bottlenecks.  
\- Participate in process improvement. Mid-levels have enough experience to suggest tweaks: maybe the PR template could be improved, or propose adding a new playbook for a scenario they encountered. They are encouraged to bring these up in retrospectives or directly to leads\[122\].  
\- Rotate into the deployment driver role. After about a month, mid-level devs should be able to take the 3 PM deployment duty, with a lead observing the first few times. This builds confidence and spreads knowledge.  
\- Help maintain the documentation/playbooks. If a mid-level spots something outdated or has a new tip, they can update the internal wiki or playbook docs (with lead review). This is part of scaling the knowledge.  
<br/>A mid-level is basically the backbone of the daily workflow - capable of delivering independently and also supporting those less experienced. Progression to Senior will involve demonstrating technical leadership and broader thinking (not just solving tasks, but improving how we do things).  
<br/>\### Senior Developers (2-4+ years DB experience)  
\*\*Profile:\*\* Senior devs have deep SQL and data modeling knowledge. They likely have been through multiple similar transitions or have prior experience with migrations, performance tuning, etc. They are comfortable with any complexity the database can throw at them and serve as go-to experts for tough problems.  
<br/>\*\*What Seniors do independently:\*\* Essentially \*anything\*, including:  
\- ‚úÖ Complex refactorings like renaming or splitting tables with minimal downtime, using advanced techniques and multi-step deployments\[123\].  
\- ‚úÖ Data migrations involving significant logic or large volumes (planning out how to migrate millions of records without locking out the application).  
\- ‚úÖ Advanced performance optimizations - reading execution plans, adding indexes or rewriting queries to eliminate bottlenecks.  
\- ‚úÖ Coordinating breaking changes that require application updates, feature toggles, or multi-phase rollouts. They can come up with a plan to introduce a change safely (e.g. add new structure, backfill, switch app to new structure, then remove old structure).  
\- ‚úÖ Troubleshoot any build or deployment issue, even weird ones. E.g., circular dependency issues in SSDT, obscure SQL errors, pipeline tool issues - they will find a solution or workaround.  
\- ‚úÖ Design the schema for entirely new modules or significant features, ensuring it fits with standards and will scale.  
\- ‚úÖ Code review at the highest level: seniors review not just for syntax but for \*soundness\*. They might catch that a change, while technically fine, could have downstream impact on data integrity or might not scale in production. They often act as the final pair of eyes on any risky change.  
<br/>Seniors also perform production deployments and handle hotfixes when needed (with change management in place). They are trusted to execute on prod because they understand the implications and checks required.  
<br/>\*\*Leadership & consultation:\*\* Seniors should consult with the \*\*Staff/Lead developer\*\* for:  
\- üü° Decisions that affect the entire team or system architecture (for example, "Should we adopt an archiving strategy for old data? How to implement multi-tenancy in the DB?")\[124\] - they provide recommendations but involve leads for buy-in.  
\- üü° Cross-team or strategic moves, like coordinating with other product teams that share the database or aligning with enterprise DBAs on policies.  
\- üü° Adopting new tools/tech in the DB space (like introducing a new indexing scheme, partitioning, or enabling certain SQL Server features) - discuss with lead about feasibility and value.  
<br/>But on a day-to-day basis, seniors operate with a lot of autonomy.  
<br/>\*\*Senior Responsibilities:\*\*  
\- \*\*Technical leadership:\*\* They review complex PRs (and many of the normal ones too) - nothing of significance goes out without a senior or lead's eyes on it\[125\]\[126\]. They are the gatekeepers of quality. They also often mentor mid-level devs during review, pointing out subtle issues or alternative approaches.  
\- \*\*Final decision making:\*\* If there's a debate or an uncertainty (e.g., how to model a tricky relationship or whether to use an indexed view vs. denormalize a table), seniors help make the call (in consultation with lead if it's big). They should base decisions on best practices and explain reasoning to the team - this is how others learn the rationale.  
\- \*\*Mentorship & Knowledge Sharing:\*\* Seniors actively mentor mid-level and junior devs. They might run short knowledge sessions ("brown bags") on topics like "writing efficient queries" or "how indexing works"\[127\]\[128\]. They also make themselves available for questions and pair programming on hard tasks.  
\- \*\*Process improvement & standards:\*\* Seniors contribute heavily to evolving our standards. If they notice recurring issues, they propose a new checklist item or anti-pattern to avoid. They ensure the playbooks and guides are up to date, adding advanced tips. In retrospectives, they bring data (e.g., "We had 3 build failures last week due to missing GO separators - let's add a pre-commit check for that"). They drive continuous improvement.  
\- \*\*On-call & Incident Management:\*\* Typically, seniors rotate on on-call for database issues. If something goes wrong in production (like a failed deployment or a performance regression), a senior is the one to jump in, triage, fix or rollback, and then coordinate the post-mortem\[129\]. They ensure lessons are learned and documented.  
\- \*\*Big picture thinking:\*\* They keep an eye on how our database is evolving and how that impacts the app. For example, if data volume is growing, they plan ahead for indexing or partitioning. They also consider security (permissions, data privacy) and work with leads to enforce best practices there.  
<br/>In summary, seniors are the technical anchors - they handle the hardest technical tasks and also make the whole team better by sharing their knowledge and maintaining high standards.  
<br/>\### Staff/Lead Developer  
(Depending on org titles, this could be an \*\*Architect\*\*, \*\*Principal Developer\*\*, or \*\*Team Lead\*\* role - here we mean the person ultimately accountable for the database platform on the team.)  
<br/>\*\*Profile:\*\* 4+ years of database development, likely the person who drove this cutover initiative. They combine technical depth with strategic perspective. They not only solve problems but also set direction for the team.  
<br/>\*\*Key Responsibilities:\*\*  
\- \*\*Architecture & Standards:\*\* Define and evolve the \*\*architectural direction\*\* for our data layer\[130\]. This includes setting the standards we've been discussing (naming, design patterns, etc.), deciding when to introduce new technologies (maybe adopting an ORM vs. sticking to SSDT, or when to use Azure-specific features if any), and ensuring our DB design aligns with application needs and scalability goals\[131\].  
\- \*\*Governance & Process Ownership:\*\* The lead owns the \*\*DevOps process for the DB\*\*. They set the PR review standards, SLAs (e.g., "all non-urgent PRs reviewed within one business day")\[132\], and the deployment schedules. They also monitor metrics: e.g., how often are we deploying, how many issues are caught in PR vs. after deploy, etc., and adjust process to improve those\[133\]\[134\]. They run the retrospectives and drive changes (like adjusting the 2 PM cutoff if needed, or adding more reviewers if PRs queue up).  
\- \*\*Mentoring & Team Development:\*\* The lead looks after \*\*team skill growth\*\*. They identify who needs more training on what, pair juniors with seniors strategically, and ensure everyone is progressing. They might set up formal training or bring in resources (like inviting a DBA for a workshop). They also help with career development - e.g., guiding a mid-level on what they need to demonstrate to become a senior\[135\].  
\- \*\*Cross-Team Coordination:\*\* They represent the team in bigger forums. If there's a central architecture board or a dependency with another team's database, the lead coordinates those discussions. E.g., if another team wants to integrate with our DB, the lead figures out how to do that safely. They also communicate status to management - for instance, reporting that the cutover was successful and what benefits we're seeing, or raising concerns if any.  
\- \*\*Final Escalation Point:\*\* If a production issue escalates, the lead is the final call. They have the authority to make tough decisions like rolling back a change from production or even temporarily allowing a hotfix query if absolutely needed (and then ensuring it gets into source control). They manage risk - balancing speed and safety. For example, they might decide "We'll pause deployments for two days until we resolve Issue X in Test environment".  
\- \*\*Resource Allocation:\*\* The lead may decide to form mini task forces for special projects (like cleaning up some technical debt in the DB, or conducting a performance audit). They ensure the team's efforts align with priorities (feature work vs. maintenance vs. learning).  
<br/>In the context of this cutover, the lead likely did a lot of prep (like creating initial guides, running training sessions). Post-cutover, their job is to observe how the team is handling the new process and provide support or course-corrections. For instance, if by Wednesday it's clear folks are struggling with PR reviews, they might implement a buddy system or daily office hour. If things go smoothly, they gradually step back from daily execution (letting others deploy, etc.) to focus on forward-looking improvements.  
<br/>\*\*Swim Lane Summary Table:\*\*  
<br/>| Role / Experience | Focus & Independence | Key Responsibilities |  
|--------------------------|---------------------------------------|-----------------------------------------|  
| \*\*Junior Dev (0-1 yr)\*\* | Learn basics, execute simple tasks with guidance. New to SSDT. | Follow process, ask questions; handle simple adds/edits; no high-risk changes solo. |  
| \*\*Mid-Level Dev (1-2 yr)\*\* | Independent on most tasks, guided on complex. | Implement features, review junior work, propose improvements; handle moderate changes; assist in deployments. |  
| \*\*Senior Dev (2-4 yr)\*\* | Complex tasks, mentor others, ensure quality. | Oversee technical correctness, optimize and refactor, review major PRs, lead by example; on-call for tough issues. |  
| \*\*Lead Dev (4+ yr)\*\* | Architecture, standards, team enablement. | Set direction, own process/governance, coordinate across teams, final escalation, develop team's skills. |  
<br/>Everyone in the team is encouraged to \*\*grow into the next lane\*\*. These delineations are not walls but targets - e.g., a junior who has learned quickly can start taking on some mid-level tasks with a safety net. Conversely, a senior should still be willing to do hands-on work that might be "mid-level", especially to help when needed or to mentor.  
<br/>One practical example of how these lanes work together: say we have a \*\*complex refactoring\*\* (like splitting a large table). A lead or senior will make a plan design-wise. A mid-level might execute parts of that plan (write scripts under guidance). Juniors might assist by writing small pieces or updating the OutSystems side, under supervision. During deployment, a senior runs it while others watch or assist. This way, everyone is involved at the appropriate level, and the knowledge flows down.  
<br/>Another example: handling \*\*merge conflicts\*\* in Git - initially, seniors will resolve tricky conflicts, explaining to mid-levels how (especially those involving refactor logs or simultaneous changes). Mid-levels pick up skill and next time handle it themselves, maybe explaining to a nearby junior what they're doing. We create a virtuous cycle of learning.  
<br/>Lastly, \*\*code reviews\*\* mapping to lanes: as a rule, \*\*no one approves their own DB changes.\*\* Junior PRs require at least mid-level or above approval\[136\]. Mid-level PRs require senior approval\[137\]. Senior PRs ideally get another senior or lead to approve (even leads should have a second pair of eyes from a senior)\[138\]. This ensures oversight at the right level. Juniors can certainly review each other's PRs for practice, but a senior should sign off. The idea is not hierarchy for its own sake, but risk management: more experienced eyes on changes that could have bigger impact.  
<br/>\## Onboarding Checklists & Resources Recap  
This final section provides some handy \*\*checklists and decision aids\*\* for quick reference, and summarizes resources you can use as you continue learning.  
<br/>\### First-Day Survival Checklist (for Day 1 post-cutover)  
If you're reading this on cutover Monday, here's a short checklist to survive the day:  
\- \[ \] \*\*Attend the morning extended standup.\*\* We demoed the new workflow - if you missed it, ask a colleague for a recap or check the recording. Key Q&A might have been answered there.  
\- \[ \] \*\*Make one small change\*\* in the DB project before noon (even if not needed for a feature) to go through the motions: e.g., add a test column in a throwaway branch, build it, see that it builds, then maybe discard. This practice helps solidify the steps.  
\- \[ \] \*\*Observe the 3:00 deploy and 3:30 refresh\*\* closely. These are new rituals - today the lead will narrate a lot\[49\]\[139\]. Pay attention to Slack announcements and follow the Integration Studio refresh steps exactly.  
\- \[ \] \*\*Ask questions\*\*! If anything is unclear (e.g., "where do I find the build log?" or "how do I know the refresh worked?"), ask in \`#database-help\`. Chances are others have the same question.  
\- \[ \] \*\*Review the anti-patterns (don't-do list)\[140\]\*\* to avoid any immediate missteps that could cause an outage. Especially: don't directly touch the DB via SSMS and don't skip the OutSystems refresh.  
<br/>By the end of Day 1, aim to have completed at least one cycle of: made a change -> submitted PR -> saw it deployed -> refreshed OutSystems -> verified it in the app. Even if your main work doesn't require a DB change, try a dry run (in a safe way) so you aren't anxious the first time it's for real.  
<br/>\### Ongoing Checklist for Changes (Dev Workflow)  
Before submitting a PR for a database change, run through this:  
\- \[ \] \*\*Implementation done in SSDT project\*\* (no changes pending only in local DB).  
\- \[ \] \*\*Project builds with 0 errors\*\* (fix all build errors or warnings).  
\- \[ \] \*\*Ran a Schema Compare\*\* to double-check the deployment script (especially for anything beyond adding columns). Look for unexpected drops.  
\- \[ \] \*\*Tested in local dev environment\*\* if possible (optional but helpful for complex changes: publish the DACPAC to a local or a personal dev DB to ensure it applies clean).  
\- \[ \] \*\*PR description filled\*\* with context and any special instructions (like "also deploy X OutSystems app after" if relevant).  
\- \[ \] \*\*Self-reviewed naming, types, indexes, nulls\*\* per the standards (use the earlier checklist).  
\- \[ \] \*\*Tagged the right reviewer\*\* (usually your team's dev lead or a senior who knows the area of the database).  
<br/>After deployment (especially if you were the one who made the change):  
\- \[ \] \*\*Refresh Integration Studio\*\* for the affected extension and verify the new fields appear\[86\].  
\- \[ \] \*\*Test the OutSystems application\*\*: does it see the new data? Are queries working? (E.g., if you added a column and then added logic in OutSystems to use it, test that end-to-end now that everything is deployed).  
\- \[ \] \*\*Watch for errors\*\*: if something went wrong (e.g., deployment failed, or the extension didn't publish), escalate in the Slack channel immediately. We have back-out plans if needed, but we rely on quick reporting of issues.  
\- \[ \] \*\*Document anything notable\*\*: If you hit a weird error and solved it, share the knowledge in \`#database-help\` or the team wiki so others can learn. For instance, "Heads up: if you see error XYZ, it means your refactor log is out of sync - fix was to do ABC\[82\]."  
<br/>\### Decision Tree: View vs. Direct Table for OutSystems  
Since "view vs direct bind" was a question: consider this when exposing data to OutSystems:

Need to expose data to OutSystems? ‚îÇ ‚îú‚îÄ Is the schema stable? ‚îÇ ‚îú‚îÄ YES ‚Üí Bind OutSystems directly to the table (simpler) ‚îÇ ‚îî‚îÄ NO (likely to change often) ‚îÇ ‚Üí Consider creating a SQL view for OutSystems ‚îÇ that abstracts the changes ‚îÇ ‚îî‚îÄ Is the data a result of joins or calc? ‚îú‚îÄ YES ‚Üí A view might consolidate logic server-side ‚îî‚îÄ NO ‚Üí Direct table bind is fine \`\`\` **Guideline:** Use direct table connections for straightforward tables that align 1:1 with OutSystems entities. Use a **view** if you need to join multiple tables for OutSystems or present data differently (so OutSystems can just consume the view). Also, if you have a highly volatile schema area, a view can act as a contract - you'd update the view definition as underlying tables change, so OutSystems entity doesn't break frequently. _Remember:_ whether it's a table or view, any structural change means you must refresh the external entity in Integration Studio. Views don't eliminate refreshes on change, but can reduce how often OutSystems modules need code changes (since the view can hide a new column until the OutSystems app is ready to handle it, for example).

### Further Reading & Resources

To deepen your expertise, here are some curated resources: - **Official Microsoft Docs - SSDT and Database Projects:** Great for specific how-tos (importing schema, publishing, schema compare usage). Example: _"Create and deploy a database project"_ tutorial[\[17\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=a%20database,be%20empty%20aside%20from%20the). - **Blogs / Articles:** - Eitan Blumin's series on Database DevOps - covers advanced SSDT usage and CI/CD integration (if you prefer a comprehensive blog-style narrative with examples)[\[141\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=_Study%20Resources%20for%20Stage%202%3A_,continuous)[\[142\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=offers%20insights%20on%20YAML%20configuration,20Azu). - Gavin Matthews' blog on SSDT Azure DevOps pipelines - if you'll be involved in pipeline configuration, this is gold[\[143\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=Learn%20article%20shows%20using%20DACPAC,pipelines%2F%23%3A~%3Atext%3DCI%252FCD%2520o). - The team's internal **Playbooks repository** - includes step-by-step guides for tasks like adding columns, handling merge conflicts, etc. (Much of that content has been summarized here, but the playbooks have more screenshots and examples). - **Books:** _DevOps for Databases_ (O'Reilly, 2023) is a good read to understand the philosophy and broader practices (though not specific to SSDT, it gives context)[\[144\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,SQL%20Server). - **Internal Knowledge Base:** Check our Confluence or Notion for pages tagged "Database" or "SSDT". We have troubleshooting Q&A, recorded demo sessions, and an FAQ that's growing as people ask questions. - **Peer Learning:** Pair with colleagues. If someone on the team does something neat (like scripts a complex deployment), ask them about it. Maybe present it in a team meeting. We want to spread knowledge so everyone becomes comfortable.

## Conclusion

This guide has walked through the entire journey: preparing for the cutover, executing daily in the new model, upskilling on SSDT/DACPAC, avoiding pitfalls, and understanding each team member's role in this new process. It's a lot of information - and you're not expected to memorize it all at once. Keep this document handy as a reference. Use the headings and sections to jump to what you need (be it refresh procedure or naming conventions or a checklist).

**Key takeaways:** - We are now treating database schema changes with the same discipline as application code. This brings huge benefits in stability and speed, but requires us all to follow the process (no shortcuts) and continuously learn. - In the first week, focus on getting the basics right (building, deploying, refreshing). Lean on the guides and on your peers. By the third or fourth deployment, it will start feeling routine. - Communication is vital: between developers (for coordination), with leads (for approvals and design discussions), and with the broader team (announcements, sharing learnings). When in doubt, over-communicate. It's far better to ask "Should I do X or Y?" than to charge ahead and potentially cause an issue. - This is a team sport. Dev leads will be heavily involved initially, but the goal is to have everyone ramp up to be self-sufficient and confident. Help each other - if you've mastered something, offer to help the next person. If you're stuck, ask for help early. - **Keep the momentum:** After the cutover weekend and first week, don't lose steam in learning. There's a lot more to become proficient (like performance tuning, advanced deployment scenarios). Set personal learning goals (maybe one topic each week from the resources) so that in a few months, you not only adapt to this process, you excel in it.

We're transforming how we work with data for the better. There will be bumps, but as the success criteria laid out: in a month, this should feel normal; in a few months, we'll wonder how we ever managed without source control and automated DB deployments. The database will truly become a first-class citizen in our DevOps pipeline, and you'll have a valuable new skill set under your belt.

**Onward and upward - happy coding (and scripting)!** And remember, if something's unclear or not covered here, just ask - we're all learning and improving this together. [\[145\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=Success%20Criteria%20by%20Timeline%20,dev%20leads%20focus%20on%20architecture)[\[146\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%F0%9F%94%B5%20MONTH%203%2B%20EXCELLENCE%20%28Long,improving%20team)

[\[1\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%F0%9F%8E%AF%20This%20Weekend%27s%20Context) [\[2\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2AWhy%20We%20Did%20This%2A%2A%3A%20,Prevents%20drift%20and%20manual%20errors) [\[13\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,Statements%20in%20Project) [\[14\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2AWhy%20It%20Works%2A%2A%3A%20,regardless%20of%20whether%20table%20exists) [\[36\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,Studio%20Refresh) [\[37\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=1,use%20in%20OutSystems%20%E2%9C%85) [\[75\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%E2%9D%8C%20Anti,in%20Views%2FProcedures) [\[76\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADon%27t%20Do%20This%2A%2A%3A%20%60%60%60sql%20,2%2C%20%27Processing%27%29%3B) [\[77\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADo%20This%20Instead%2A%2A%3A%20%60%60%60sql%20,StatusId) [\[78\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%60%60%60sql%20,1%2C%20%27Pending%27%29%3B%20END) [\[93\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=Read%20%5BTop%2010%20Anti,DON%27T%20commit%20without%20building%20first) [\[94\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=,2%2C%20%27Processing%27%29%3B) [\[95\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%2A%2ADo%20This%20Instead%2A%2A%3A%20%60%60%60sql%20,StatusId%20WHEN%20NOT%20MATCHED%20THEN) [\[96\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=,error) [\[97\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=4,use%20in%20OutSystems%20%E2%9C%85) [\[140\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%F0%9F%9A%A8%20DON%27T%20DO%20THESE%20,cause%20outages) [\[145\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=Success%20Criteria%20by%20Timeline%20,dev%20leads%20focus%20on%20architecture) [\[146\]](file://file_000000002f3c61f891746b436bf0261f#:~:text=%F0%9F%94%B5%20MONTH%203%2B%20EXCELLENCE%20%28Long,improving%20team) note1.md

file://file_000000002f3c61f891746b436bf0261f

[\[3\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=something%20does%20fail%2C%20you%20have,schema%20changes%20being%20deployed%20via) [\[4\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=database%20changes%2C%20similar%20to%20application,schema%20issues%20drop%20to%20zero) [\[5\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,schema%20issues%20drop%20to%20zero) [\[6\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=note6.md%20,release%20frequency) [\[7\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=%2A%2AKey%20Activities%20and%20Skills%3A%2A%2A%20,ver17%23%3A~%3Atext%3DThe%252%200development%2520cycle%2520of%2520a%2Clocal%2520development%2520without%2520additional%2520effor) [\[8\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=Properties%20and%20References%20folders.%20,server) [\[9\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=projects%2Ftutorials%2Fcreate,the%20option%20to%20organize%20by) [\[10\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=review%20and%20ensuring%20your%20changes,and) [\[11\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=reference%20,of%20database%20DevOps%3A%20the%20repo) [\[12\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=dacpac,to%20complex%20schema%20overhauls%20with) [\[17\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=a%20database,be%20empty%20aside%20from%20the) [\[20\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,two%20people%20editing%20the) [\[35\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=If%20drift%20is%20detected%20,on%20using%20SSDT%2C%20interpreting%20schema) [\[47\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=match%20at%20L92%20them,never%20the%20reverse) [\[79\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=What%20is%20SSDT%20,Data%20Tools) [\[80\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=issues%29.%20,Schema%20Compare%20result%20will%20show) [\[81\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=and%2Cany,change%20to%20the%20development%20database) [\[84\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=unit%20testing,DevOps%20discuss%20cultural%20and%20process) [\[87\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=_Study%20Resources%20for%20Stage%203%3A_,based) [\[88\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=official%20tSQLt%20site%20and%20its,DevOps%20discuss%20cultural%20and%20process) [\[89\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=Stage%201%3A%20Foundation%20%28Weeks%201,%E2%9C%94%EF%B8%8F) [\[90\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,Release%20folder%20for%20a) [\[91\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,or%20just%20immediately%20if%20following) [\[92\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,and%20no%20one%20is%20directly) [\[141\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=_Study%20Resources%20for%20Stage%202%3A_,continuous) [\[142\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=offers%20insights%20on%20YAML%20configuration,20Azu) [\[143\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=Learn%20article%20shows%20using%20DACPAC,pipelines%2F%23%3A~%3Atext%3DCI%252FCD%2520o) [\[144\]](file://file_00000000948861fbbfaa4567dbd40769#:~:text=,SQL%20Server) note6.md

file://file_00000000948861fbbfaa4567dbd40769

[\[15\]](file://file_00000000212861f88d9493c570cb38db#:~:text=,SQL%20experience) [\[16\]](file://file_00000000212861f88d9493c570cb38db#:~:text=,mappings%20between%20model%20and%20database) note7.md

file://file_00000000212861f88d9493c570cb38db

[\[18\]](https://medium.com/noesis-low-code-solutions/external-databases-in-outsystems-environments-122e97fa2574#:~:text=Right%20clicking%20on%20%E2%80%9CEntities%E2%80%9D%20and,to%20External%20Table%20or%20View%E2%80%9D) External Databases in OutSystems Environments | by Sara Pedrosa | Noesis Low-Code Solutions | Medium

<https://medium.com/noesis-low-code-solutions/external-databases-in-outsystems-environments-122e97fa2574>

[\[19\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,PhoneNumber%5D%20VARCHAR%2820%29%20NULL%3B) [\[52\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=5.%20Description%3A%20,) [\[53\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=%2A%2A%E2%9A%A0%EF%B8%8F%20CRITICAL%20STEP%20,skip) [\[59\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,CustomerId%5D%29%3B%20GO) [\[60\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,CustomerId%5D%29%3B%20GO) [\[73\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,CustomerId%5D%29%3B%20GO) [\[74\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=) [\[85\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=4.%20%2A%2ARight,Click%20Apply) [\[86\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=1.%20,Type%3A%20Text%20Length%3A%2020) [\[98\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,NOT%20NULL%20without%20DEFAULT%20%E2%94%82) [\[116\]](file://file_000000009bd061f7a9340ee2cb40b95f#:~:text=,to%20Customers) note2.md

file://file_000000009bd061f7a9340ee2cb40b95f

[\[21\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,Avoids%20blocking%20people%20first%20thing) [\[22\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=match%20at%20L527%20,15%20minutes) [\[23\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,60%20minutes) [\[26\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%E2%9D%8C%20Dev%20lead%20overwhelmed) [\[27\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%E2%9C%85%201%20deployment%20per%20day,Efficient%20use%20of%20time) [\[28\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2AStep%202%3A%20Pre,3%3A00%20PM) [\[29\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Duration%3A%20,) [\[30\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Pre,dev) [\[31\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,MyDatabase.dacpac) [\[32\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=SqlPackage.exe%20%2FAction%3AScript%20%60%20%2FSourceFile%3A,HHmm%27%29.sql%22) [\[38\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%F0%9F%94%94%20Integration%20Studio%20Refresh%20Time) [\[39\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=1,Confirm%20in%20thread%20when%20done) [\[40\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%5BYourName%5D%22) [\[41\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=2,%5BYourName%5D%22) [\[42\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,No%20%E2%86%92%20Ping%20missing%20people) [\[43\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,3.%20Test%20your%20app) [\[44\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%23%20Ad,window) [\[45\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=2,testing%20with%20old%20schema) [\[46\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,emergency) [\[48\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=) [\[49\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=3%3A00%20PM%3A%20First%20batch%20deployment,communicate) [\[50\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=) [\[68\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,deployment%20migration) [\[69\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%E2%9D%8C) [\[99\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,deployment%20script) [\[100\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,in%20daily%20deployment%20rhythm) [\[101\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,Practice%20on%20sample%20database) [\[102\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%E2%9C%85%20Read%20playbooks%20independently%20%E2%9C%85,Practice%20on%20sample%20database) [\[103\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,Troubleshoot%20Integration%20Studio%20connection%20issue) [\[104\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Guidance%20from%3A%20Senior%20dev%20or,30%20min%20pairing) [\[105\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%F0%9F%9F%A1%20Troubleshoot%20Integration%20Studio%20connection,issue) [\[106\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2AHigh,Breaking%20changes%20to%20OutSystems%20apps) [\[107\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,standards%20%E2%9D%8C%20Troubleshoot%20production%20issues) [\[108\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Must%3A%20Pair%20with%20senior%20dev,loss%20risk%2C%20coordination%20complexity) [\[109\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%E2%9D%8C%20Set%20team%20standards%20%E2%9D%8C,Troubleshoot%20production%20issues) [\[110\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,Follow%20daily%20release%20train%20rhythm) [\[111\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,sufficient) [\[112\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,Contribute%20to%20process%20improvements) [\[113\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%E2%9C%85%20Resolve%20most%20build%20errors) [\[114\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=match%20at%20L1087%20,Troubleshoot%20most%20Integration%20Studio%20issues) [\[115\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%E2%9C%85%20Review%20junior%20dev%20PRs,with%20checklist%29) [\[119\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=) [\[120\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2AHigh,sensitive%20changes) [\[121\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,%E2%9D%8C) [\[122\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2AProcess%2A%2A%3A%20%60%60%60%20,fix%20outdated%20info%29) [\[123\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2AAll%20Mid,after%20training) [\[124\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=) [\[125\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=match%20at%20L1403%20Never%20delegate,first%203%20months%29) [\[126\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Build%20errors%3A%20Junior%20can%20try%2C,Senior%20or%20staff%20only) [\[127\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,on%20advanced%20topics) [\[128\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2ATechnical%20Leadership%2A%2A%3A%20%60%60%60%20,on%20advanced%20topics) [\[129\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2AOn,mortems) [\[130\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=,Define%20swim%20lanes%20and%20roles) [\[131\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=) [\[132\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%60%60%60%20,team%20needs%20with%20management) [\[133\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=match%20at%20L720%20,PRs%20rejected%20first%20time%3A) [\[134\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=match%20at%20L752%20,) [\[135\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=%2A%2ATeam%20Development%2A%2A%3A%20%60%60%60%20,Foster%20learning%20culture) [\[136\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Junior%20PRs%3A%20Reviewed%20by%20Mid,yes%2C%20upward%20review) [\[137\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=match%20at%20L1366%20Junior%20PRs%3A,yes%2C%20upward%20review) [\[138\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=Mid%2FSenior%20reviewing%20Junior%3A%20,Approve%20or%20request%20changes) [\[139\]](file://file_0000000085c8622fab7047f46c20a3bc#:~:text=3%3A30%20PM%3A%20First%20coordinated%20refresh,Pair%20if%20needed) note5.md

file://file_0000000085c8622fab7047f46c20a3bc

[\[24\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,%E2%94%9C%E2%94%80%20All%20green%3F%20%E2%86%92%20Continue) [\[25\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%94%9C%E2%94%80%20Quick%20Check%20,5%20min) [\[33\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,reasonable) [\[34\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,) [\[51\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=) [\[54\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Tables%3A%20%E2%98%90%20Singular%20noun%20,Product%20not%20tblProduct) [\[55\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Primary%20Keys%3A%20%E2%98%90%20,%E2%98%90%20NOT%20NULL%20PRIMARY%20KEY) [\[56\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,Product%20not%20tblProduct) [\[57\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%9D%8C%20,) [\[58\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Primary%20Keys%3A%20%E2%98%90%20,%E2%98%90%20NOT%20NULL%20PRIMARY%20KEY) [\[61\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=Indexes%3A%20%E2%98%90%20IX_TableName_Column1_Column2%20%E2%98%90%20Example%3A,IX_Orders_CustomerId_OrderDate) [\[62\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=) [\[63\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%60%60%60%20%E2%98%90%20User,) [\[64\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%9D%8C%20,%E2%9D%8C) [\[65\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=) [\[66\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=%E2%9D%8C%20,%E2%9D%8C%20Rounding%20errors) [\[67\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=) [\[70\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=) [\[71\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=) [\[72\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,DEFAULT%20or%20migration%20plan%3F) [\[82\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=) [\[83\]](file://file_00000000206c622f96da8e9c0d971575#:~:text=,Build%20again) note3.md

file://file_00000000206c622f96da8e9c0d971575

[\[117\]](file://file_000000000ce061fd9712b71aaea22ff5#:~:text=Conflict%20Type%201%3A%20Simple%20Additive,Easy) [\[118\]](file://file_000000000ce061fd9712b71aaea22ff5#:~:text=) note4.md

file://file_000000000ce061fd9712b71aaea22ff5
