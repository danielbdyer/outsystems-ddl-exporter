# OutSystems → SQL Server: End-to-End Extraction, Tightening, and SSDT Prep

> **Purpose**
> This README is your single source of truth to **build, run, and maintain** a pipeline that:
>
> 1. Extracts OutSystems’ logical data model (via one-shot **Advanced SQL**) into a **parseable JSON** payload.
> 2. **Profiles** the live SQL Server for physical nullability, uniqueness, FKs, and data reality (NULLs, duplicates, orphans).
> 3. Applies **policy-driven tightening** (evidence-gated `NOT NULL`, UNIQUE, and FK creation), with **pre-remediation SQL** where needed.
> 4. Builds **SMO** object graphs (no regex/string-concat), then **emits one CREATE TABLE script per entity** (indexed by module) with inline defaults, foreign keys, indexes, and `MS_Description` extended properties.
> 5. Optionally **compares** your intended model against a **DMM-produced DDL** to ensure **1:1 parity** (PKs only, all `NOT NULL`) before SSDT ingestion.
>
> All code paths avoid regex and manual string concatenation for schema. All schema DDL is generated by **SMO** (and DMM parsing is by **ScriptDom**).

---

## Table of Contents

* [0. TL;DR Quickstart](#0-tldr-quickstart)
* [1. System Requirements & Dependencies](#1-system-requirements--dependencies)
* [2. Repository Layout](#2-repository-layout)
* [3. Advanced SQL: One-Shot Model Export (Modules → Entities → Attributes/Indexes/FKs)](#3-advanced-sql-one-shot-model-export-modules--entities--attributesindexesfks)
* [4. JSON Payload Contract & Schema](#4-json-payload-contract--schema)
* [5. .NET Solution Architecture](#5-net-solution-architecture)
* [6. Profiling: Catalog + Data Reality Sweep](#6-profiling-catalog--data-reality-sweep)
* [7. Tightening Policy (NOT NULL / UNIQUE / FK Decisions)](#7-tightening-policy-not-null--unique--fk-decisions)
* [8. SMO Builder (No Regex; Pure Objects → DDL)](#8-smo-builder-no-regex-pure-objects--ddl)
* [9. Per-Table DDL Emitter (SSDT-Ready Output)](#9-pertable-ddl-emitter-ssdtready-output)
* [10. DMM Parity Comparator (ScriptDom, PK-only, NOT NULL)](#10-dmm-parity-comparator-scriptdom-pkonly-not-null)
* [11. CI/CD & PR Workflow](#11-cicd--pr-workflow)
* [12. Testing Strategy](#12-testing-strategy)
* [13. Configuration & Environment](#13-configuration--environment)
* [14. Troubleshooting & Gotchas](#14-troubleshooting--gotchas)
* [15. Security, Performance, and Operations](#15-security-performance-and-operations)
* [16. Extensibility Roadmap](#16-extensibility-roadmap)
* [Appendix D — Design Contracts at the Boundaries](#appendix-d--design-contracts-at-the-boundaries)

---

## 0. TL;DR Quickstart

1. **Run Advanced SQL** inside an OutSystems Server Action (or use the provided fixtures) to produce **JSON** for your chosen modules. Save it to `model.json`. When operating fixture-first, you can replay the Advanced SQL output with the CLI:

   ```bash
   dotnet run --project src/Osm.Cli \
     extract-model \
     --mock-advanced-sql tests/Fixtures/extraction/advanced-sql.manifest.json \
     --modules "AppCore,ExtBilling,Ops" \
     --out ./out/model.edge-case.json
   ```

   The manifest maps module selections to deterministic JSON payloads, giving the same shape you would fetch from a live OutSystems database. For a hands-on reference, inspect `tests/Fixtures/model.edge-case.json` and its companion profiler snapshot under `tests/Fixtures/profiling/profile.edge-case.json`.
2. **Run the .NET pipeline** (fixture-first example shown; swap in your live export and profiler snapshot when ready):

   ```bash
   dotnet run --project src/Osm.Cli \
     build-ssdt \
     --model tests/Fixtures/model.edge-case.json \
     --profile tests/Fixtures/profiling/profile.edge-case.json \
     --out ./out
   ```

   The command evaluates NOT NULL/UNIQUE/FK decisions, materializes SMO tables, emits SSDT-ready per-table files to `./out/Modules/...`, and records a structured summary in `./out/policy-decisions.json` alongside the `manifest.json` snapshot.

  The emitted manifest mirrors the fixtures we keep under `tests/Fixtures/emission/edge-case` (and the rename variant under `tests/Fixtures/emission/edge-case-rename`), so you can diff your live runs against the curated baselines.
3. **(Optional) Verify DMM parity** using the same model/profile inputs:

   ```bash
   dotnet run --project src/Osm.Cli \
     dmm-compare \
     --model tests/Fixtures/model.edge-case.json \
     --profile tests/Fixtures/profiling/profile.edge-case.json \
     --dmm ./out/dmm/edge-case.sql \
     --out ./out/dmm-diff.json
   ```

   The command emits a structured diff artifact (default `./dmm-diff.json`) summarizing the comparison outcome and exits with a non-zero status when drift is detected, making it CI-friendly.

---

## 1. System Requirements & Dependencies

* **OutSystems**: Platform Server O11+ (cloud) with the **System** producer available (metamodel).
* **SQL Server**: 2017+ (recommended 2019/2022).
* **.NET**: .NET 9 SDK (or the version pinned in `global.json` when introduced).
* **NuGet Packages**:

  * `Microsoft.SqlServer.SqlManagementObjects` (SMO)
  * `Microsoft.SqlServer.TransactSql.ScriptDom` (ScriptDom)
  * `Microsoft.Data.SqlClient` (or `System.Data.SqlClient`)
  * `Microsoft.SqlServer.DacFx` *(optional; not required if skipping dacpac)*
* **Build tools**: Visual Studio or `dotnet` CLI.
* **Permissions**: Read access to target DB (`SELECT`, metadata views), and ability to run `SELECT` profiling queries. No DDL permissions required to **emit** scripts (only to **apply** them later).

---

## 2. Repository Layout

```
OutSystemsModelToSql.sln
src/
  Osm.Domain/                 # DTOs: Model, Profiling, Decisions
  Osm.Json/                   # JSON provider + schema validation
  Osm.Validation/             # Model validation + TighteningPolicy
  Osm.Smo/                    # SMO builder + PerTableDdlEmitter
  Osm.Dmm/                    # DMM lens, ScriptDom parser, comparator
  Osm.Pipeline/               # Orchestrators (use cases)
  Osm.Cli/                    # CLI entry points (extract-model, build-ssdt, dmm-compare)
tests/
  Osm.Domain.Tests/
  Osm.Validation.Tests/
  Osm.Smo.Tests/
  Osm.Dmm.Tests/
  Osm.Pipeline.Tests/
```

---

## 3. Advanced SQL: One-Shot Model Export (Modules → Entities → Attributes/Indexes/FKs)

> **Goal:** produce a **single JSON** that captures modules, entities (logical + physical names), attributes, reference semantics (delete rule), indexes, and physical drift flags. This avoids N+1 calls.

**Inputs**

* `@ModuleNamesCsv` (Text) — e.g., `AppCore,Payments,Backoffice`
* `@IncludeSystem` (Boolean) — include System modules (default `False`)
* `@OnlyActiveAttributes` (Boolean) — default `True`

**Place in**: a *Server Action* → **Advanced SQL** node.
**Output**: a single row with a single `Text` column containing the JSON.


The full query now lives in [`src/AdvancedSql/outsystems_model_export.sql`](src/AdvancedSql/outsystems_model_export.sql) so that IDEs and linters can reason about it. The opening excerpt below shows the documented inputs and module filter:

```sql
/* ============================================================================
   OutSystems → JSON (Two-phase, CTE-free)
   GOAL #1: emit 100% of module/entity/attribute/index fields in README schema,
   GOAL #2: reconcile ossys intent with sys.* physical reality.
*/

SET NOCOUNT ON;
SET TEXTSIZE -1; -- unlimited for (n)varchar(max) in this session

-- 1) #ModuleNames (handles optional @ModuleNamesCsv filter)
IF OBJECT_ID('tempdb..#ModuleNames') IS NOT NULL DROP TABLE #ModuleNames;
CREATE TABLE #ModuleNames ( ModuleName NVARCHAR(200) COLLATE DATABASE_DEFAULT NOT NULL );
INSERT INTO #ModuleNames(ModuleName)
SELECT LTRIM(RTRIM(value))
FROM STRING_SPLIT(@ModuleNamesCsv, ',')
WHERE NULLIF(LTRIM(RTRIM(value)), '') IS NOT NULL;
```

Key metadata surfaced by the reconciled extractor:

* **Logical attribute provenance** — emits `originalName`, logical `dataType`, and the external connector’s `external_dbType` straight from `ossys_Entity_Attr` so renames and passthrough mappings stay traceable.
* **Physical drift hints** — `physical_isPresentButInactive` lights up when `sys.columns` still contains an inactive attribute, making cleanup candidates obvious.
* **Real FK detection** — `reference_hasDbConstraint` and relationship `hasDbConstraint` only flip to `1` when the logical reference is backed by a matching `sys.foreign_keys` entry.
* **External catalog/schema discovery** — external entities reuse the catalog/owner metadata on `ossys_Entity` when a physical table is absent in the current database, preserving parity across linked servers.

> 💡 **Sample output row**: the fixtures under `tests/Fixtures/model.edge-case.json` mirror the JSON payload produced by the SQL. The first module entry expands to:

```json
{
  "module": {
    "name": "AppCore",
    "isSystem": false,
    "isActive": true
  },
  "entities": [
    {
      "name": "Customer",
      "physicalName": "OSUSR_ABC_CUSTOMER",
      "isStatic": false,
      "isExternal": false,
      "isActive": true
    }
  ]
}
```

**Export tip:** write the JSON to a Site Property, an entity, or an S3/GCS/Blob via Integration Builders; or stream back in Service Studio for download.

---

## 4. JSON Payload Contract & Schema

**Top level (recommended for multi-module export):**

```json
{
  "modules": [
    {
      "name": "AppCore",
      "isSystem": false,
      "isActive": true,
      "entities": [ /* see entity shape below */ ]
    }
  ]
}
```

**Entity shape:**

```json
{
  "name": "Customer",
  "physicalName": "OSUSR_ABC_CUSTOMER",
  "isStatic": false,
  "isExternal": false,
  "isActive": true,
  "db_catalog": null,
  "db_schema": "dbo",
  "meta": {
    "description": "End-user profile data captured from Service Center"
  },
  "attributes": [ /* attributes[] below */ ],
  "relationships": [ /* derived references */ ],
  "indexes": [ /* modeled indexes */ ]
}
```

**Attribute shape (per column):**

```json
{
  "name": "Email",
  "physicalName": "EMAIL",
  "originalName": null,
  "dataType": "Text",
  "length": 255,
  "precision": null,
  "scale": null,
  "default": null,
  "isMandatory": true,
  "isActive": true,
  "isIdentifier": false,
  "isReference": 0,
  "refEntityId": null,
  "refEntity_name": null,
  "refEntity_physicalName": null,
  "reference_deleteRuleCode": null,
  "hasDbConstraint": 0,
  "external_dbType": null,
  "physical_isPresentButInactive": 0,
  "onDisk": {
    "isNullable": 0,
    "sqlType": "nvarchar",
    "maxLength": 255,
    "precision": 0,
    "scale": 0,
    "collation": "Latin1_General_CI_AI",
    "isIdentity": 0,
    "isComputed": 0,
    "computedDefinition": null,
    "defaultDefinition": "DEFAULT ('')"
  },
  "meta": {
    "description": "Primary email address"
  }
}
```

**Relationships:**

```json
{
  "viaAttributeId": 12345,
  "viaAttributeName": "CityId",
  "toEntity_name": "City",
  "toEntity_physicalName": "OSUSR_DEF_CITY",
  "deleteRuleCode": "Protect",
  "hasDbConstraint": 1,
  "actualConstraints": [
    {
      "name": "FK_OSUSR_ABC_CUSTOMER_CITY",
      "onDelete": "NO_ACTION",
      "onUpdate": "NO_ACTION",
      "referencedSchema": "dbo",
      "referencedTable": "OSUSR_DEF_CITY",
      "columns": [
        {
          "ordinal": 1,
          "owner": { "attribute": "CityId", "physical": "CITYID" },
          "referenced": { "attribute": "Id", "physical": "ID" }
        }
      ]
    }
  ]
}
```

**Indexes:**

```json
{
  "name": "IDX_CUSTOMER_EMAIL",
  "isUnique": true,
  "isPlatformAuto": 0,
  "columns": [
    {
      "attribute": "Email",
      "physicalColumn": "EMAIL",
      "ordinal": 1,
      "isIncluded": false,
      "direction": "ASC"
    }
  ]
}
```

>
> **Extended descriptions → `MS_Description`**
>
> The `meta.description` payload for entities and attributes comes straight from the OutSystems metadata. To round-trip these notes into SQL Server or SSDT projects, iterate the JSON and call `sp_addextendedproperty`/`sp_updateextendedproperty` as shown below:
>
> ```sql
> -- Table description (entity-level)
> EXEC sys.sp_addextendedproperty
>      @name = N'MS_Description',
>      @value = @EntityDescription,
>      @level0type = N'SCHEMA', @level0name = @SchemaName,
>      @level1type = N'TABLE',  @level1name = @TableName;
>
> -- Column description (attribute-level)
> EXEC sys.sp_addextendedproperty
>      @name = N'MS_Description',
>      @value = @AttrDescription,
>      @level0type = N'SCHEMA', @level0name = @SchemaName,
>      @level1type = N'TABLE',  @level1name = @TableName,
>      @level2type = N'COLUMN', @level2name = @ColumnName;
> ```
>
> Use `sp_updateextendedproperty` when the description already exists. Because the exporter surfaces trimmed descriptions and physical column names, you can drive these stored procedures directly from the JSON.
>
**JSON schema** (optional) — validate with `NJsonSchema` or `JsonSchema.Net` before mapping.

---

## 5. .NET Solution Architecture

**Principles**

* **No regex / no string-concat** for schema; only SMO (and ScriptDom for DMM parse).
* **Layered & DI-friendly**: parse → validate → profile → decide → build → emit.
* **Deterministic**: same input → same files.

**Key interfaces**

```csharp
public interface IModelProvider { Task<ModelRoot> LoadAsync(Stream json, CancellationToken ct = default); }
public interface IModelValidator { ValidationReport Validate(ModelRoot model); }
public interface IDataProfiler { Task<ProfileSnapshot> CaptureAsync(string conn, IEnumerable<TableRef> tables, IEnumerable<(LogicalFkRef Ref,bool IsDbConstraintPresent)> refs, IEnumerable<(TableRef Table,string Column)> uniqueSingles, CancellationToken ct = default); }
public interface ISqlServerObjectBuilder { Database Build(ModelRoot model, SmoBuildOptions options); }
public interface IDdlEmitter { /* not used when we emit per-table via PerTableDdlEmitter */ }
```

---

## 6. Profiling: Catalog + Data Reality Sweep

**What we collect**

* Physical: `sys.columns.is_nullable`, computed, defaults, PK/unique membership.
* Data: per-column **NULL counts** and **row count** (one dynamic query per table).
* Uniqueness: duplicates for **single-column** modeled unique indexes.
* FKs without DB constraint: **orphans** (`EXISTS` mismatch).

**Profiler implementation** (excerpt)

```csharp
public sealed class SqlServerDataProfiler : IDataProfiler
{
  public async Task<ProfileSnapshot> CaptureAsync(
      string connectionString,
      IEnumerable<TableRef> tables,
      IEnumerable<(LogicalFkRef Ref, bool IsDbConstraintPresent)> logicalRefs,
      IEnumerable<(TableRef Table, string Column)> uniqueSingleColumnCandidates,
      CancellationToken ct = default)
  {
    // 1) sys.* snapshot per table (columns, defaults, PK/unique membership)
    // 2) one dynamic SELECT per table to compute NULL counts + rowcount
    // 3) per-candidate duplicate checks
    // 4) orphan checks for refs without DB constraints
  }
}
```

**Dynamic per-table NULL profiling** (generated for each table):

```sql
DECLARE @rc BIGINT;
SELECT @rc = COUNT_BIG(*) FROM [dbo].[MyTable];
SELECT
  SUM(CASE WHEN [Col1] IS NULL THEN 1 ELSE 0 END) AS [Col1],
  SUM(CASE WHEN [Col2] IS NULL THEN 1 ELSE 0 END) AS [Col2],
  @rc AS __rowcount
FROM [dbo].[MyTable];
```

**Sampling:** when `sql.sampling.rowThreshold` is exceeded the profiler automatically samples `sql.sampling.sampleSize` rows per table to keep scans predictable. NULL/duplicate/orphan counts are scaled back to estimated totals so decisions remain comparable to full-table sweeps.

### Feeding profiles into `build-ssdt`

The CLI defaults to the **fixture** profiler so local or CI runs can replay deterministic JSON snapshots. Point `--profile` to an on-disk snapshot (or configure `profile.path` / `profiler.profilePath` in `appsettings.json`) and the pipeline will hydrate `ProfileSnapshot` before policy evaluation and SMO emission.【F:src/Osm.Cli/Program.cs†L203-L286】【F:src/Osm.Cli/Program.cs†L1142-L1171】

#### Fixture-first loops

```bash
dotnet run --project src/Osm.Cli -- build-ssdt \
  --model tests/Fixtures/model.edge-case.json \
  --profile tests/Fixtures/profiling/profile.edge-case.json \
  --out ./out
```

* Keep reusable snapshots under version control (for example the repository fixtures) and point to them via `--profile` or the CLI configuration file.
* `profiler.provider=Fixture` and `profiler.profilePath=<path>` in `appsettings.json` remove the need to pass flags on every invocation; environment variables such as `OSM_CLI_PROFILE_PATH` offer another override when automating builds.【F:src/Osm.Pipeline/Configuration/CliConfigurationLoader.cs†L95-L140】【F:readme.md†L626-L671】

#### Live SQL capture

```bash
dotnet run --project src/Osm.Cli -- build-ssdt \
  --model ./cache/model.json \
  --profiler-provider sql \
  --connection-string "Server=sql.local;Database=OutSystems;Integrated Security=true" \
  --sampling-threshold 250000 \
  --sampling-size 75000 \
  --out ./out-live
```

* Supplying `--profiler-provider sql` switches to the live profiler, requiring a connection string (via CLI flag, configuration, or `OSM_CLI_CONNECTION_STRING`). Optional authentication and sampling knobs mirror the `sql.*` configuration section so you can pin timeouts, Azure AD credentials, or table sampling thresholds without editing secrets into source control.【F:src/Osm.Cli/Program.cs†L1127-L1171】【F:src/Osm.Pipeline/Configuration/CliConfigurationLoader.cs†L215-L334】
* When a live run completes the CLI emits the captured snapshot to STDOUT (`SQL profiler snapshot:` …). Redirect the output to persist the JSON and reuse it for later fixture-style runs:

  ```bash
  dotnet run --project src/Osm.Cli -- build-ssdt --profiler-provider sql ... \
    | tee profile.latest.json
  ```

#### How the profile influences emission

* Policy decisions (`NOT NULL`, UNIQUE, FK) always read from the hydrated snapshot before tightening, ensuring that live evidence gates schema changes even when you replay fixtures later.【F:src/Osm.Cli/Program.cs†L273-L323】
* Default expressions captured by the profiler flow into emission; the SMO factory cross-references each column’s default definition so `DEFAULT (getutcdate())` and similar metadata survive into the generated SSDT scripts.【F:src/Osm.Smo/SmoModelFactory.cs†L15-L118】
* The emitted `policy-decisions.json` and `manifest.json` capture the exact profile path/provider that produced the run, helping reviewers correlate schema changes back to their evidence snapshot.【F:src/Osm.Cli/Program.cs†L285-L323】

---

## 7. Tightening Policy (NOT NULL / UNIQUE / FK Decisions)

**Signals**

* S1: PK (OutSystems `IsIdentifier`) ⇒ `NOT NULL`
* S2: Physical `is_nullable=0` ⇒ `NOT NULL`
* S3: FK with DB constraint ⇒ strong `NOT NULL` for FK column
* S4: Single-column UNIQUE with no duplicates ⇒ strong `NOT NULL`
* S5: Logical `isMandatory` ⇒ weak signal
* S7: Default exists ⇒ combine with S5

**Modes**

* **Cautious**: S1 ∪ S2 only
* **EvidenceGated (default)**: S1 ∪ S2 ∪ ((S3 ∪ S4 ∪ (S5∧S7)) ∧ (NULLs==0))
* **Aggressive**: S1 ∪ S2 ∪ S3 ∪ S4 ∪ S5 (with **pre-remediation SQL**)

**Decisions DTOs**

```csharp
public sealed record NullabilityDecision(bool MakeNotNull, string Rationale, string? PreRemediationSql = null);
public sealed record UniqueDecision(bool EnforceUnique, string Rationale, string? PreRemediationSql = null);
public sealed record ForeignKeyDecision(bool CreateConstraint, string Rationale, string? PreRemediationSql = null);
public sealed record TighteningDecisions(...);
```

**Sample pre-remediation (Aggressive mode)**

```sql
-- Null fix by type heuristic; customize per domain
UPDATE [dbo].[Orders]
SET [CustomerId] = 0     -- or map to known sentinel
WHERE [CustomerId] IS NULL;
```

---

## 8. SMO Builder (No Regex; Pure Objects → DDL)

**Key mapping rules**

* Columns: **nullable by default**, then apply `NullabilityDecision` (set `Nullable=false` when decided).
* PK: single column `Id` (`IsIdentifier`).
* UNIQUE: keep modeled unique; suppress if `UniqueDecision.EnforceUnique == false`.
* FK: add only when `ForeignKeyDecision.CreateConstraint == true`.

**Builder options + implementation** (excerpt)

```csharp
public sealed class SmoObjectBuilder : ISqlServerObjectBuilder
{
  public Database Build(ModelRoot model, SmoBuildOptions options)
  {
    var db = new Database(new Server(new ServerConnection()), options.DatabaseName ?? "ModelScratch");
    // ... create schemas, tables, columns (apply decisions), PK, indexes, FKs ...
    return db;
  }
}
```

---

## 9. Per-Table DDL Emitter (SSDT-Ready Output)

**Output layout**

```
out/
  Modules/
    <ModuleName>/
      Tables/<schema>.<table>.sql          # CREATE TABLE + PK + inline defaults/FKs/indexes/extended properties
  manifest.json
  README.txt
```

> **Identifier casing:** the emitter projects each table and column to its logical, human-readable name by default (for example, `dbo.OSUSR_ABC_CUSTOMER` becomes `dbo.Customer` and columns like `ID`/`NAME` render as `Id`/`Name`). Explicit overrides supplied via configuration or `--rename-table` still win when you need deterministic collision handling across modules.

**Emitter pipeline**

* Builds one `CREATE TABLE` AST per entity using ScriptDom, attaching `DefaultConstraintDefinition`, `ForeignKeyConstraintDefinition`, and inline `CREATE INDEX` statements.
* Formats default expressions to a dedicated indented line and nests foreign key definitions two levels deep for readability.
* Appends `sys.sp_addextendedproperty`/`sys.sp_updateextendedproperty` calls for entity and column descriptions when metadata is present.
* Records emitted index names, foreign key names, and whether extended properties were included in `manifest.json` (`TableManifestEntry.Indexes`, `ForeignKeys`, `IncludesExtendedProperties`).
* Honors `EmitBareTableOnly` to suppress inline defaults, foreign keys, indexes, and extended properties when consumers need a structural-only script.

**SSDT import**
Create a Database Project → Add items from `Tables/`. Inline foreign keys, indexes, and defaults ship inside each table file. Use `EmitBareTableOnly` when you prefer to add constraints/indexes manually.
Optional remediation batches (if enabled) continue to land under `PreRemediation/`.

---

## 10. DMM Parity Comparator (ScriptDom, PK-only, NOT NULL)

**Why**
DMM will push a **PK-only, all `NOT NULL`** schema into SSDT. We ensure our intent matches that **exactly**.

**Steps**

1. **Lens** our model into **DMM shape** (all columns `NotNull=true`; PK = Identifier).
2. **Parse DMM DDL** with **ScriptDom** (no regex) into a comparable model.
3. **Compare**: table presence, column order/names/types/length/precision/scale (canonicalized), PK column list.

**Lens** (excerpt)

```csharp
public static DmmDatabase Project(ModelRoot model) { /* build DmmTable/Column with NotNull=true */ }
```

**Parser** (excerpt)

```csharp
var parser = new TSql150Parser(initialQuotedIdentifiers: true);
var fragment = parser.Parse(new StringReader(script), out errors);
// visitor collects CreateTable + ALTER TABLE ... ADD CONSTRAINT PK statements
```

**Comparator** (excerpt)

```csharp
if (!lcol.Name.Equals(rcol.Name, OrdinalIgnoreCase)) diff.Add("col name mismatch ...");
if (!TypeEq(lcol, rcol)) diff.Add("type mismatch ...");
if (!rcol.NotNull) diff.Add("expected NOT NULL but actual nullable");
if (!lt.PrimaryKey.Columns.SequenceEqual(rt.PrimaryKey.Columns, OrdinalIgnoreCase)) diff.Add("PK columns differ");
```

> **Now shipping:** the comparator canonicalizes ScriptDom type facets (length/precision/scale), tolerates casing/whitespace variance, treats `NUMERIC` and `DECIMAL` as the same family, and captures primary keys declared inline or via follow-up `ALTER TABLE` batches. Track regression coverage in `tests/Osm.Dmm.Tests/DmmComparatorTests.cs` and the living test plan §6.3/§6.7.

**CLI example**

```bash
dotnet run --project src/Osm.Cli dmm-compare \
  --in model.json \
  --dmm dmm_out/*.sql \
  --out out/dmm-diff.json
```

The `dmm-diff.json` artifact captures:

```jsonc
{
  "isMatch": true,
  "modelPath": "./model.json",
  "profilePath": "./profile.json",
  "dmmPath": "./dmm_out/edge-case.sql",
  "generatedAtUtc": "2024-09-16T20:01:37.4280793Z",
  "modelDifferences": [],
  "ssdtDifferences": []
}
```

When drift exists, `isMatch` flips to `false` and each difference entry carries structured context:

```jsonc
{
  "schema": "dbo",
  "table": "Customer",
  "column": "Email",
  "property": "Nullability",
  "expected": "NOT NULL",
  "actual": "NULL",
  "artifactPath": "Modules/AppCore/Tables/dbo.Customer.sql"
}
```

The CLI renders the same information to stderr and exits with code `2`, making it easy to pipe the JSON into automation or dashboards.

---

## 11. CI/CD & PR Workflow

1. **Generate/refresh** `model.json` (Advanced SQL) for target modules.
2. **Run build-ssdt** to emit per-table DDL and **manifest.json**.
3. **(Optional) DMM parity**: run comparator; **fail** if diffs.
4. **Create PR** into SSDT repo (or copy files) with a standard layout.
5. **Review gates**:

   * No missing tables/files (check `manifest.json` vs DB).
   * No nullability violations unless pre-scripts included.
   * DMM parity passes (if you use DMM as source-of-deploy).
   * `dmm-compare` writes a diff artifact (`IsMatch`, `Differences`) on every run and returns non-zero whenever drift is detected (tracked in `tasks.md` §7).

---

## 12. Testing Strategy

* **Golden tests**: assert scripted DDL equals expected snapshots for small models — see the `Osm.Etl.Integration.Tests` suite for the fixture-to-emission parity check.
* **Property tests**: randomly generate entity/attribute combos and ensure builder+emitter don’t throw; output compiles in SSDT.
* **Policy tests**: verify EvidenceGated mode only flips `NOT NULL` when `NullCount==0`.
* **DMM parser tests**: parse curated T-SQL variants (CREATE TABLE PK inline; PK via ALTER TABLE; case/quote variants).
* **Performance**: profile a 100+ table model; ensure single pass per layer and per-table dynamic profiling.
* **Evidence cache longevity**: validate cache eviction/refresh semantics when module selections change and smoke the forthcoming live SQL adapter. *(See `notes/test-plan.md` §18.5–§18.6.)*

---

## 13. Configuration & Environment

**Baseline tightening defaults**

The repository ships with `config/default-tightening.json`, which the configuration deserializer loads into `TighteningOptions` (EvidenceGated policy, FK creation enabled, platform auto-indexes suppressed). Use it as the starting point for local runs or copy it into environment-specific settings before overriding individual flags.

```jsonc
"emission": {
  "perTableFiles": true,
  "includePlatformAutoIndexes": false,
  "sanitizeModuleNames": true,
  "emitBareTableOnly": false,
  "namingOverrides": {
    "rules": [
      {
        "schema": "dbo",
        "table": "OSUSR_RTJ_CATEGORY",
        "module": "Inventory",
        "entity": "Category",
        "override": "CATEGORY_STATIC"
      },
      {
        "module": "SupportPortal",
        "entity": "Case",
        "override": "CASE_BACKOFFICE"
      }
    ]
  }
}
```

### Naming override rules

`namingOverrides.rules` is a single, unified collection that understands both the *physical* table (`schema` + `table`) and the *logical* entity (`module` + `entity`). Every rule must supply an `override`, and you can include whichever coordinates you know:

* **Physical only** – provide `schema` + `table` (module/entity omitted). The emitted table script plus every constraint (PK, FK, IX) and manifest entry uses the replacement while the logical name remains untouched.
* **Logical only** – provide `entity` and, optionally, `module`. This resolves duplicate logical names across modules; all derived identifiers (including FK targets) adopt the override even if multiple physical tables share the logical name.
* **Hybrid** – provide both physical and logical coordinates (as in the example). This is the safest approach when you are stitching models from multiple modules: the factory first rewrites the raw SMO table keyed by schema/table and then re-checks the logical entity so every downstream lookup (`GetEffectiveTableName`) returns the same override for tables, foreign keys, and manifest payloads.

The CLI mirrors this behavior with `--rename-table`. You can keep the legacy syntax (`dbo.OSUSR_ABC_CUSTOMER=CUSTOMER_PORTAL`) for quick physical renames or supply a combined descriptor:

```
--rename-table dbo.OSUSR_RTJ_CATEGORY|Inventory::Category=Category_StaticEntity
```

Segments separated by `|` describe the physical (`schema.table`) and logical (`Module::Entity`) facets that feed the same rule. The parser trims whitespace, defaults the schema to `dbo` when omitted, and allows multiple overrides separated by `,` or `;`. Under the covers the CLI merges these rules with any configuration-derived rules before invoking the SMO factory, so ad-hoc fixes and declarative configuration stay in sync.

Older configuration files that still expose `tables`/`entities` arrays continue to deserialize, but the unified `rules` section should be preferred going forward because it guarantees the override flows through SSDT emission, FK lookups, DMM comparison, and manifest generation identically.

**CLI configuration file**

Copy `config/appsettings.example.json` to an environment-specific location (e.g., `config/appsettings.json`) and adjust the paths/toggles that should act as defaults for every CLI run.

```jsonc
{
  "tighteningPath": "config/default-tightening.json",   // optional override for TighteningOptions
  "model": {
    "path": "tests/Fixtures/model.edge-case.json",
    "modules": [
      "AppCore",
      { "name": "ServiceCenter", "entities": ["User"] }
    ],
    "includeSystemModules": false,
    "includeInactiveModules": true
  },
  "profile": { "path": "tests/Fixtures/profiling/profile.edge-case.json" },
  "cache": { "root": ".artifacts/cache", "refresh": false },
  "profiler": { "provider": "Fixture", "profilePath": "tests/Fixtures/profiling/profile.edge-case.json" },
  "sql": { "connectionString": "Server=localhost;Database=OutSystems;Trusted_Connection=True;", "commandTimeoutSeconds": 120 }
}
```

Module filters declared in configuration act as defaults—`--modules`, `--exclude-system-modules`, and `--only-active-modules` override them on the command line. The evidence cache key incorporates the resolved module list and toggles so cached payloads stay aligned when you swap module selections between runs.

Entries inside the `modules` array can be plain strings (include the entire module) or objects with a `name` plus an optional `entities` selector. Supplying an array (or CSV string) to `entities` trims and deduplicates values so you can scope extraction to specific logical or physical entity names—for example, `{ "name": "ServiceCenter", "entities": ["User"] }` keeps only the Service Center `User` entity while avoiding other tables that might fail validation. A wildcard (`"*"`) or boolean `true` keeps every entity in the module.

`sql.sampling` tunes when the profiler switches to sampling and how many rows it inspects; `sql.authentication` plugs in Azure AD / managed identity authentication or per-connection ADO.NET overrides (e.g., application name, certificate trust) without polluting the connection string.

### Supplemental models (entity overrides)

OutSystems modules frequently reference **system** or **external** tables (for example `OSSYS_User`) that the Advanced SQL export does not include. The CLI’s supplemental model loader lets you bring those table definitions along so the SMO factory can materialize them and allow foreign keys to resolve cleanly in the emitted SSDT project.

* In configuration, declare the `supplementalModels` section:

  ```jsonc
  "supplementalModels": {
    "includeUsers": true,
    "paths": ["config/supplemental/ossys-user.json"]
  }
  ```

  * `includeUsers` controls whether the built-in `OSUSR_U_USER` definition ships with every run. It is `true` by default so FKs targeting `Users` always bind, and you can disable it when you maintain a richer override file yourself.【F:src/Osm.Pipeline/Configuration/CliConfiguration.cs†L73-L79】【F:src/Osm.Domain/Model/OutSystemsInternalModel.cs†L9-L44】
  * `paths` accepts any number of additional JSON payloads that follow the same shape as the Advanced SQL export (`modules` → `entities` → attributes/indexes/relationships). Each file can describe one or more tables—even outside of OutSystems—so long as the schema/table names align with the foreign keys you expect to emit.【F:src/Osm.Cli/Program.cs†L720-L786】

* The loader merges these supplemental entities ahead of SMO construction. During emission the factory first prefers modules/entities from the primary model, but it can fall back to supplemental definitions when resolving FK targets or when you want to ship an external table alongside OutSystems entities.【F:src/Osm.Smo/SmoModelFactory.cs†L15-L118】【F:src/Osm.Smo/SmoModelFactory.cs†L659-L746】
* Because supplemental tables run through the same `build-ssdt` pipeline, they appear in `manifest.json`, honor naming overrides, and participate in DMM comparisons exactly like native entities.【F:src/Osm.Cli/Program.cs†L285-L323】【F:src/Osm.Dmm/DmmComparator.cs†L15-L50】

**Sample supplemental file** (`config/supplemental/ossys-user.json`):

```json
{
  "modules": [
    {
      "name": "OutSystems.System",
      "isSystem": true,
      "isActive": true,
      "entities": [
        {
          "name": "User",
          "physicalName": "OSUSR_U_USER",
          "schema": "dbo",
          "isActive": true,
          "isExternal": false,
          "isStatic": false,
          "attributes": [
            { "name": "Id", "physicalName": "ID", "dataType": "Identifier", "isMandatory": true, "isIdentifier": true },
            { "name": "Username", "physicalName": "USERNAME", "dataType": "Text", "isMandatory": true, "length": 50 },
            { "name": "Email", "physicalName": "EMAIL", "dataType": "Text", "isMandatory": true, "length": 255 }
          ],
          "indexes": [],
          "relationships": []
        }
      ]
    }
  ]
}
```

Store these JSON files in your repo (for example under `config/supplemental/`) so every team member and CI run resolves the same definitions.

**Precedence**

When resolving inputs, the CLI honours the following order: CLI flag ➝ environment variable ➝ CLI config file ➝ built-in defaults.

**Environment variables**

* `OSM_CLI_CONFIG_PATH` — default `--config` path when none is supplied.
* `OSM_CLI_MODEL_PATH`, `OSM_CLI_PROFILE_PATH`, `OSM_CLI_DMM_PATH` — fallbacks for required inputs.
* `OSM_CLI_CACHE_ROOT`, `OSM_CLI_REFRESH_CACHE` — cache root and refresh behavior.
* `OSM_CLI_PROFILER_PROVIDER`, `OSM_CLI_PROFILER_MOCK_FOLDER` — override profiler defaults.
* `OSM_CLI_CONNECTION_STRING`, `OSM_CLI_SQL_COMMAND_TIMEOUT` — staged for the live SQL adapter and cached metadata hashing.
* `OSM_CLI_SQL_AUTHENTICATION`, `OSM_CLI_SQL_ACCESS_TOKEN`, `OSM_CLI_SQL_TRUST_SERVER_CERTIFICATE`, `OSM_CLI_SQL_APPLICATION_NAME` — fine-tune SQL connectivity without hard-coding sensitive values in the config file.

**CLI flags**

* `extract-model`
  * `--connection-string <value>` / `--command-timeout <seconds>` — point at the live OutSystems catalog and adjust the ADO.NET timeout.
  * `--sql-authentication <method>` / `--sql-access-token <token>` / `--sql-trust-server-certificate [true|false]` / `--sql-application-name <name>` — optional authentication and connection-management overrides (supports Azure AD, managed identity, and application tagging).
  * `--sampling-threshold <rows>` / `--sampling-size <rows>` — override the profiler’s built-in sampling defaults for very large tables.
  * `--mock-advanced-sql <manifest.json>` — replay deterministic Advanced SQL payloads (bypasses live extraction).
  * `--modules <csv>` — optional module filter; trimmed, case-insensitive.
  * `--include-system-modules` — include OutSystems system producers.
  * `--include-inactive-attributes` — future toggle to rehydrate inactive columns when downstream tooling still expects them.
  * `--out <path>` — destination for the JSON payload (defaults to `model.extracted.json`).
* `build-ssdt`
  * `--model <model.json>` / `--profile <profile.json>` — deterministic inputs (fixtures or cached extraction outputs).
  * `--connection-string`, `--command-timeout`, `--sql-authentication`, `--sql-access-token`, `--sql-trust-server-certificate`, `--sql-application-name` — same semantics as `extract-model`; only required when running the live SQL profiler.
  * `--sampling-threshold`, `--sampling-size` — override profiler sampling defaults when capturing directly from SQL Server.
  * `--modules <csv>` — optional module filter; values are trimmed and case-insensitive.
  * `--exclude-system-modules` / `--include-system-modules` — toggle whether system modules participate when the filter is empty.
  * `--only-active-modules` / `--include-inactive-modules` — drop inactive modules entirely (active-only by default when the flag is present).
  * `--config <appsettings.json>` — optional CLI configuration (model/profile defaults, cache root, tightening overrides).
  * `--out <directory>` — emission root (`./out` by default).
  * `--cache-root <directory>` / `--refresh-cache` — evidence cache control for model/profile/DMM/config artifacts.
  * `--rename-table schema.table=Override` — rename the emitted table/constraint identifiers (separate multiple overrides with `;` or `,`).
* `dmm-compare`
  * `--model <model.json>` / `--profile <profile.json>` — same as `build-ssdt`.
  * `--dmm <path>` — baseline DMM script to compare against SMO output.
  * `--modules`, `--exclude-system-modules`, `--only-active-modules` — same semantics as `build-ssdt`; restricts the SMO baseline prior to diffing.
  * `--config`, `--cache-root`, `--refresh-cache` — same semantics as `build-ssdt`.

---

## 14. Troubleshooting & Gotchas

* **“Mandatory” vs DB `NOT NULL`**: OutSystems `isMandatory` is logical; our policy upgrades to `NOT NULL` only with evidence (or Aggressive + pre-fix).
* **Index ASC/DESC**: OutSystems model doesn’t expose per-column sort direction; DDL omits direction (default ASC).
* **Cross-catalog FKs**: metamodel can show logical refs that DB can’t enforce; policy won’t create FK when catalogs/schemas differ (or when orphans exist).
* **Inactive attributes**: columns flagged `isActive = false` or `physical.isPresentButInactive = 1` are omitted from emission by default while remaining in the decision log for audit trails.
* **Constraint casing**: emitted PK/IX/FK identifiers are regenerated using PascalCase table/column names; table rename overrides propagate across every constraint artifact.
* **Name collisions**: sanitized module names keep paths safe; use `emission.namingOverrides.rules` or `--rename-table` when downstream tooling requires human-friendly table/constraint names.
* **ScriptDom parsing errors**: DMM DDL must be valid T-SQL; errors list file & line.

---

## 15. Security, Performance, and Operations

* **Security**: profiling uses `SELECT`; no DDL or data mutation occurs unless you run pre-scripts manually. Keep connection strings in KeyVault/Secrets.
* **Performance**: per-table dynamic NULL queries are O(columns); avoid running on peak hours. For very large tables, consider sampling (configurable) before full run.
* **Observability**: log module/entity counts, decision rationale (`PK`, `DB_NOT_NULL`, `UNIQUE_NO_NULLS`, etc.), and any generated pre-scripts.

---

## 16. Extensibility Roadmap

* **ScriptDom type parser** for `external.dbType` → exact SMO `DataType`.
* **Check constraints**: model custom checks from your domain JSON (not native to OS), and emit `CHECK` statements.
* **Seed data** for static entities: dump rows and emit idempotent `MERGE` scripts.
* **Automated pre-deploy runner**: Wire pre-scripts into a controlled pre-deployment phase before SSDT publish.
* **Bidirectional diff**: parse SSDT project files and detect drift vs model.

---

### Appendix A — Representative C# Snippets

**TighteningPolicy core**

```csharp
bool D1zero = (p.NullCount ?? 0) == 0 || nullRate <= _nullBudget;
makeNotNull = _mode switch
{
  TighteningMode.Cautious      => S1 || S2,
  TighteningMode.EvidenceGated => S1 || S2 || ((S3 || S4 || (S5 && S7)) && D1zero),
  TighteningMode.Aggressive    => S1 || S2 || S3 || S4 || S5,
};
```

**SMO PK creation**

```csharp
var pk = new Index(table, $"PK_{entity.PhysicalName}")
{
  IndexKeyType = IndexKeyType.DriPrimaryKey,
  IsClustered = true
};
pk.IndexedColumns.Add(new IndexedColumn(pk, idAttr.PhysicalName));
table.Indexes.Add(pk);
```

**FK creation (policy enforced)**

```csharp
var fk = new ForeignKey(fromTable, $"FK_{fromTable.Schema}_{fromTable.Name}_{viaCol}_{toTable.Name}")
{
  ReferencedTable = toTable.Name, ReferencedTableSchema = toTable.Schema
};
fk.Columns.Add(new ForeignKeyColumn(fk, viaCol, "ID"));
fromTable.ForeignKeys.Add(fk);
```

**Per-table scripting helper**

```csharp
string JoinBatches(IEnumerable batches)
{
  var sb = new StringBuilder();
  foreach (var b in batches) { sb.AppendLine(b.ToString()); sb.AppendLine("GO"); }
  return sb.ToString().Trim();
}
```

**ScriptDom type normalization (example)**

```csharp
private static string TypeToString(DataTypeReference dtr)
{
  var name = string.Join("", dtr.Name.Identifiers.Select(i => i.Value)).ToLowerInvariant();
  var (len, prec, scale) = ExtractFacet(dtr);
  return name switch
  {
    "nvarchar" => len is null ? "nvarchar(max)" : $"nvarchar({len})",
    "varchar"  => len is null ? "varchar(max)"  : $"varchar({len})",
    "decimal" or "numeric" => $"decimal({prec ?? 18},{scale ?? 0})",
    _ => name
  };
}
```

---

### Appendix B — Example CLI Usage

**Emit SSDT-ready DDL (EvidenceGated)**

```bash
dotnet run --project src/Osm.Cli build-ssdt \
  --in ./model.json \
  --profile-conn "Server=.;Database=ProdClone;Trusted_Connection=True" \
  --mode EvidenceGated \
  --out ./out
```

**Aggressive mode with remediation**

```bash
dotnet run --project src/Osm.Cli build-ssdt \
  --in ./model.json \
  --profile-conn "Server=.;Database=ProdClone;Trusted_Connection=True" \
  --mode Aggressive \
  --out ./out
# Inspect out/Modules/*/PreRemediation/*.pre.sql before running
```

**DMM Parity Check**

```bash
dotnet run --project src/Osm.Cli dmm-compare \
  --in ./model.json \
  --dmm ./dmm/*.sql \
  --out ./out/dmm-diff.json
```

---

### Appendix C — Manifest & README Generated

**manifest.json** (sample)

```json
{
  "Tables": [
    {
      "Module": "AppCore",
      "Schema": "dbo",
      "Table": "Customer",
      "TableFile": "Modules/AppCore/Tables/dbo.Customer.sql",
      "Indexes": [
        "IDX_Customer_Email",
        "IDX_Customer_Name"
      ],
      "ForeignKeys": [
        "FK_Customer_CityId"
      ],
      "IncludesExtendedProperties": true
    }
  ],
  "Options": {
    "IncludePlatformAutoIndexes": false,
    "EmitBareTableOnly": false
  },
  "Coverage": {
    "Tables": { "Emitted": 1, "Total": 1, "Percentage": 100.0 },
    "Columns": { "Emitted": 6, "Total": 6, "Percentage": 100.0 },
    "Constraints": { "Emitted": 4, "Total": 4, "Percentage": 100.0 }
  },
  "Unsupported": []
}
```

**README.txt** (emitted alongside artifacts)

```
This folder contains per-table DDL organized by OutSystems Module.

Import guidance (SSDT):
1) Create a new SQL Server Database Project.
2) Add items from Modules/<Module>/Tables.
3) Optional: add PreRemediation/*.pre.sql as Pre-Deployment, or run manually once.
4) Build & publish / open PR.

Emission rules:
- Tables: CREATE TABLE with inline PRIMARY KEY, non-PK indexes, foreign keys, defaults, and `MS_Description` extended properties.
- Manifest: lists emitted index/foreign-key names plus toggle state (`IncludePlatformAutoIndexes`, `EmitBareTableOnly`).
```

---

You now have **everything** needed to implement, operate, and extend this pipeline—end-to-end—from OutSystems Advanced SQL through profiling and policy-driven tightening to SSDT-ready per-table DDL, plus a DMM comparator for PK-only, NOT-NULL parity. Cross-check the interface contracts in [Appendix D](#appendix-d--design-contracts-at-the-boundaries) whenever you add a new integration or tweak a policy so that boundaries stay honest. If you want me to tailor the default **type map** (e.g., treat OutSystems `Identifier` as `bigint`), say which variant you prefer and I’ll inline the exact mapper.

---

## Appendix D — Design Contracts at the Boundaries

We keep the executable contracts for every major seam—model ingestion, profiling, tightening, SMO building, emission, and DMM comparison—in [`notes/design-contracts.md`](notes/design-contracts.md). Each contract documents:

* The interface signature.
* Required invariants (e.g., logical names vs. physical names, schema casing rules).
* Expected failure shapes (`Result<T>` codes) and telemetry hooks.

Visit the appendix whenever you introduce a new adapter or extend CLI options so you can align with the boundary guarantees and reuse the existing fixture-first tests.
