# OutSystems → SQL Server: End-to-End Extraction, Tightening, and SSDT Prep

> **Purpose**
> This README is your single source of truth to **build, run, and maintain** a pipeline that:
>
> 1. Extracts OutSystems’ logical data model (via one-shot **Advanced SQL**) into a **parseable JSON** payload.
> 2. **Profiles** the live SQL Server for physical nullability, uniqueness, FKs, and data reality (NULLs, duplicates, orphans).
> 3. Applies **policy-driven tightening** (evidence-gated `NOT NULL`, UNIQUE, and FK creation), with **pre-remediation SQL** where needed.
> 4. Builds **SMO** object graphs (no regex/string-concat), then **emits per-table DDL** (Tables / Indexes / ForeignKeys), **folderized by OutSystems Module**, with **PreRemediation** scripts.
> 5. Optionally **compares** your intended model against a **DMM-produced DDL** to ensure **1:1 parity** (PKs only, all `NOT NULL`) before SSDT ingestion.
>
> All code paths avoid regex and manual string concatenation for schema. All schema DDL is generated by **SMO** (and DMM parsing is by **ScriptDom**).

---

## Table of Contents

* [0. TL;DR Quickstart](#0-tldr-quickstart)
* [1. System Requirements & Dependencies](#1-system-requirements--dependencies)
* [2. Repository Layout](#2-repository-layout)
* [3. Advanced SQL: One-Shot Model Export (Modules → Entities → Attributes/Indexes/FKs)](#3-advanced-sql-one-shot-model-export-modules--entities--attributesindexesfks)
* [4. JSON Payload Contract & Schema](#4-json-payload-contract--schema)
* [5. .NET Solution Architecture](#5-net-solution-architecture)
* [6. Profiling: Catalog + Data Reality Sweep](#6-profiling-catalog--data-reality-sweep)
* [7. Tightening Policy (NOT NULL / UNIQUE / FK Decisions)](#7-tightening-policy-not-null--unique--fk-decisions)
* [8. SMO Builder (No Regex; Pure Objects → DDL)](#8-smo-builder-no-regex-pure-objects--ddl)
* [9. Per-Table DDL Emitter (SSDT-Ready Output)](#9-pertable-ddl-emitter-ssdtready-output)
* [10. DMM Parity Comparator (ScriptDom, PK-only, NOT NULL)](#10-dmm-parity-comparator-scriptdom-pkonly-not-null)
* [11. CI/CD & PR Workflow](#11-cicd--pr-workflow)
* [12. Testing Strategy](#12-testing-strategy)
* [13. Configuration & Environment](#13-configuration--environment)
* [14. Troubleshooting & Gotchas](#14-troubleshooting--gotchas)
* [15. Security, Performance, and Operations](#15-security-performance-and-operations)
* [16. Extensibility Roadmap](#16-extensibility-roadmap)

---

## 0. TL;DR Quickstart

1. **Run Advanced SQL** inside an OutSystems Server Action (or use the provided fixtures) to produce **JSON** for your chosen modules. Save it to `model.json`. When operating fixture-first, you can replay the Advanced SQL output with the CLI:

   ```bash
   dotnet run --project src/Osm.Cli \
     extract-model \
     --mock-advanced-sql tests/Fixtures/extraction/advanced-sql.manifest.json \
     --modules "AppCore,ExtBilling,Ops" \
     --out ./out/model.edge-case.json
   ```

   The manifest maps module selections to deterministic JSON payloads, giving the same shape you would fetch from a live OutSystems database.
2. **Run the .NET pipeline** (fixture-first example shown; swap in your live export and profiler snapshot when ready):

   ```bash
   dotnet run --project src/Osm.Cli \
     build-ssdt \
     --model tests/Fixtures/model.edge-case.json \
     --profile tests/Fixtures/profiling/profile.edge-case.json \
     --out ./out
   ```

   The command evaluates NOT NULL/UNIQUE/FK decisions, materializes SMO tables, emits SSDT-ready per-table files to `./out/Modules/...`, and records a structured summary in `./out/policy-decisions.json` alongside the `manifest.json` snapshot.
3. **(Optional) Verify DMM parity** using the same model/profile inputs:

   ```bash
   dotnet run --project src/Osm.Cli \
     dmm-compare \
     --model tests/Fixtures/model.edge-case.json \
     --profile tests/Fixtures/profiling/profile.edge-case.json \
     --dmm ./out/dmm/edge-case.sql
   ```

   The CLI exits with a non-zero status and writes `dmm-diff.json` when parity gaps exist, making it CI-friendly.

---

## 1. System Requirements & Dependencies

* **OutSystems**: Platform Server O11+ (cloud) with the **System** producer available (metamodel).
* **SQL Server**: 2017+ (recommended 2019/2022).
* **.NET**: .NET 8 SDK (or .NET 6 LTS).
* **NuGet Packages**:

  * `Microsoft.SqlServer.SqlManagementObjects` (SMO)
  * `Microsoft.SqlServer.TransactSql.ScriptDom` (ScriptDom)
  * `Microsoft.Data.SqlClient` (or `System.Data.SqlClient`)
  * `Microsoft.SqlServer.DacFx` *(optional; not required if skipping dacpac)*
* **Build tools**: Visual Studio or `dotnet` CLI.
* **Permissions**: Read access to target DB (`SELECT`, metadata views), and ability to run `SELECT` profiling queries. No DDL permissions required to **emit** scripts (only to **apply** them later).

---

## 2. Repository Layout

```
OutSystemsModelToSql.sln
src/
  Osm.Domain/                 # DTOs: Model, Profiling, Decisions
  Osm.Json/                   # JSON provider + schema validation
  Osm.Validation/             # Model validation + TighteningPolicy
  Osm.Smo/                    # SMO builder + PerTableDdlEmitter
  Osm.Dmm/                    # DMM lens, ScriptDom parser, comparator
  Osm.Pipeline/               # Orchestrators (use cases)
  Osm.Cli/                    # CLI entry points (extract-model, build-ssdt, dmm-compare)
tests/
  Osm.Domain.Tests/
  Osm.Validation.Tests/
  Osm.Smo.Tests/
  Osm.Dmm.Tests/
  Osm.Pipeline.Tests/
```

---

## 3. Advanced SQL: One-Shot Model Export (Modules → Entities → Attributes/Indexes/FKs)

> **Goal:** produce a **single JSON** that captures modules, entities (logical + physical names), attributes, reference semantics (delete rule), indexes, and physical drift flags. This avoids N+1 calls.

**Inputs**

* `@ModuleNamesCsv` (Text) — e.g., `AppCore,Payments,Backoffice`
* `@IncludeSystem` (Boolean) — include System modules (default `False`)
* `@OnlyActiveAttributes` (Boolean) — default `True`

**Place in**: a *Server Action* → **Advanced SQL** node.
**Output**: a single row with a single `Text` column containing the JSON.

<details>
<summary>Advanced SQL (click to open)</summary>

```sql
/* ===========================
   OutSystems Advanced SQL: One-shot model → JSON
   Inputs:
     @ModuleNamesCsv (Text), @IncludeSystem (Boolean), @OnlyActiveAttributes (Boolean)
   Output: JSON
   =========================== */
WITH ModuleNames AS (
  SELECT LTRIM(RTRIM(value)) AS ModuleName
  FROM STRING_SPLIT(@ModuleNamesCsv, ',')
  WHERE NULLIF(LTRIM(RTRIM(value)), '') IS NOT NULL
),
E AS (
  SELECT e.[Id] EspaceId, e.[Name] EspaceName,
         ISNULL(e.[Is_System],0) IsSystemModule, ISNULL(e.[Is_Active],1) ModuleIsActive
  FROM {Espace} e
  WHERE (@IncludeSystem = 1 OR ISNULL(e.[Is_System],0) = 0)
    AND (NOT EXISTS (SELECT 1 FROM ModuleNames) OR e.[Name] IN (SELECT ModuleName FROM ModuleNames))
),
Ent AS (
  SELECT en.[Id] EntityId, en.[Name] EntityName, en.[Physical_Table_Name] PhysicalTableName,
         ISNULL(en.[Is_Static],0) IsStaticEntity, ISNULL(en.[Is_External],0) IsExternalEntity,
         ISNULL(en.[Is_Active],1) EntityIsActive,
         NULLIF(en.[Db_Catalog],'') DbCatalog, NULLIF(en.[Db_Schema],'') DbSchema,
         en.[Espace_Id] EspaceId
  FROM {Entity} en
  WHERE en.[Espace_Id] IN (SELECT EspaceId FROM E)
),
Attr AS (
  SELECT a.[Id] AttrId, a.[Entity_Id] EntityId, a.[Name] AttrName,
         a.[Physical_Column_Name] PhysicalColumnName, a.[Data_Type] DataType,
         a.[Length] [Length], a.[Precision] [Precision], a.[Scale] [Scale],
         a.[Default_Value] DefaultValue,
         ISNULL(a.[Is_Mandatory],0) IsMandatory,
         ISNULL(a.[Is_Active],1) AttrIsActive, ISNULL(a.[Is_Identifier],0) IsIdentifier,
         a.[Referenced_Entity_Id] RefEntityId,
         a.[Original_Name] OriginalName, a.[External_Column_Type] ExternalColumnType,
         a.[Delete_Rule] DeleteRuleCode
  FROM {Entity_Attr} a
  WHERE (@OnlyActiveAttributes = 0 OR ISNULL(a.[Is_Active],1) = 1)
),
Idx AS (
  SELECT i.[Id] IndexId, i.[Entity_Id] EntityId, i.[Name] IndexName,
         ISNULL(i.[Is_Unique],0) IsUnique, ISNULL(i.[Is_Active],1) IndexIsActive
  FROM {Index} i
),
IdxAttr AS (
  SELECT ia.[Id] IndexAttrId, ia.[Index_Id] IndexId, ia.[Entity_Attr_Id] AttrId, ia.[Sort_Order] OrdinalPosition
  FROM {Index_Attr} ia
),
RefMap AS (
  SELECT a.[Id] AttrId, a.[Entity_Id] FromEntityId, a.[Referenced_Entity_Id] ToEntityId
  FROM Attr a WHERE a.RefEntityId IS NOT NULL
),
AttrAll AS (
  SELECT a.*, en.EntityName, en.PhysicalTableName, en.IsStaticEntity, en.IsExternalEntity, en.DbCatalog, en.DbSchema
  FROM Attr a JOIN Ent en ON en.EntityId = a.EntityId
),
IdxAll AS (
  SELECT i.IndexId, i.EntityId, i.IndexName, i.IsUnique
  FROM Idx i WHERE ISNULL(i.IndexIsActive,1) = 1
),
IdxCols AS (
  SELECT ia.IndexId, ia.AttrId, ia.OrdinalPosition, a.AttrName, a.PhysicalColumnName
  FROM IdxAttr ia JOIN Attr a ON a.AttrId = ia.AttrId
),
EntObj AS (
  SELECT en.EntityId, en.PhysicalTableName,
         QUOTENAME(ISNULL(NULLIF(en.DbSchema,''),'dbo')) + N'.' + QUOTENAME(en.PhysicalTableName) AS TwoPartName
  FROM Ent en
),
PhysCols AS (
  SELECT a.AttrId, sc.column_id AS ColumnId
  FROM AttrAll a JOIN EntObj eo ON eo.EntityId = a.EntityId
  OUTER APPLY (
    SELECT sc.column_id FROM sys.columns sc
    WHERE sc.object_id = OBJECT_ID(eo.TwoPartName) AND sc.name = a.PhysicalColumnName
  ) pc WHERE pc.column_id IS NOT NULL
)
SELECT
  e.EspaceName AS [module.name],
  e.IsSystemModule AS [module.isSystem],
  e.ModuleIsActive AS [module.isActive],
  (
    SELECT
      en.EntityName AS [name],
      en.PhysicalTableName AS [physicalName],
      en.IsStaticEntity AS [isStatic],
      en.IsExternalEntity AS [isExternal],
      en.EntityIsActive AS [isActive],
      en.DbCatalog AS [db.catalog],
      en.DbSchema AS [db.schema],
      (
        SELECT
          a.AttrName AS [name],
          a.PhysicalColumnName AS [physicalName],
          a.OriginalName AS [originalName],
          a.DataType AS [dataType], a.[Length] AS [length],
          a.[Precision] AS [precision], a.[Scale] AS [scale],
          a.DefaultValue AS [default],
          a.IsMandatory AS [isMandatory],
          a.AttrIsActive AS [isActive],
          a.IsIdentifier AS [isIdentifier],
          CASE WHEN a.RefEntityId IS NOT NULL THEN 1 ELSE 0 END AS [isReference],
          a.RefEntityId AS [refEntityId],
          refEn.EntityName AS [refEntity.name],
          refEn.PhysicalTableName AS [refEntity.physicalName],
          a.DeleteRuleCode AS [reference.deleteRuleCode],
          CASE WHEN a.RefEntityId IS NOT NULL AND (a.DeleteRuleCode IN ('Protect','Delete',1,2)) THEN 1 ELSE 0 END AS [reference.hasDbConstraint],
          a.ExternalColumnType AS [external.dbType],
          CASE WHEN a.AttrIsActive = 0 AND EXISTS (SELECT 1 FROM PhysCols pc WHERE pc.AttrId = a.AttrId) THEN 1 ELSE 0 END AS [physical.isPresentButInactive]
        FROM AttrAll a
        LEFT JOIN Ent refEn ON refEn.EntityId = a.RefEntityId
        WHERE a.EntityId = en.EntityId
        ORDER BY a.IsIdentifier DESC, a.AttrName
        FOR JSON PATH
      ) AS [attributes],
      (
        SELECT DISTINCT
          f.AttrId AS [viaAttributeId],
          a.AttrName AS [viaAttributeName],
          toEn.EntityName AS [toEntity.name],
          toEn.PhysicalTableName AS [toEntity.physicalName],
          a.DeleteRuleCode AS [deleteRuleCode],
          CASE WHEN a.DeleteRuleCode IN ('Protect','Delete',1,2) THEN 1 ELSE 0 END AS [hasDbConstraint]
        FROM RefMap f
        JOIN Attr a ON a.AttrId = f.AttrId
        JOIN Ent toEn ON toEn.EntityId = f.ToEntityId
        WHERE f.FromEntityId = en.EntityId
        ORDER BY a.AttrName
        FOR JSON PATH
      ) AS [relationships],
      (
        SELECT
          i.IndexName AS [name],
          i.IsUnique AS [isUnique],
          CASE WHEN i.IndexName LIKE 'OSIDX\_%' ESCAPE '\' THEN 1 ELSE 0 END AS [isPlatformAuto],
          (
            SELECT
              c.AttrName AS [attribute],
              c.PhysicalColumnName AS [physicalColumn],
              c.OrdinalPosition AS [ordinal]
            FROM IdxCols c
            WHERE c.IndexId = i.IndexId
            ORDER BY c.OrdinalPosition
            FOR JSON PATH
          ) AS [columns]
        FROM IdxAll i
        WHERE i.EntityId = en.EntityId
        ORDER BY i.IndexName
        FOR JSON PATH
      ) AS [indexes]
    FROM Ent en
    WHERE en.EspaceId = e.EspaceId
    ORDER BY en.EntityName
    FOR JSON PATH
  ) AS [module.entities]
FROM E e
ORDER BY e.EspaceName
FOR JSON PATH, WITHOUT_ARRAY_WRAPPER;
```

</details>

**Export tip:** write the JSON to a Site Property, an entity, or an S3/GCS/Blob via Integration Builders; or stream back in Service Studio for download.

---

## 4. JSON Payload Contract & Schema

**Top level (recommended for multi-module export):**

```json
{
  "modules": [
    {
      "name": "AppCore",
      "isSystem": false,
      "isActive": true,
      "entities": [ /* see entity shape below */ ]
    }
  ]
}
```

**Entity shape:**

```json
{
  "name": "Customer",
  "physicalName": "OSUSR_ABC_CUSTOMER",
  "isStatic": false,
  "isExternal": false,
  "isActive": true,
  "db.catalog": null,
  "db.schema": "dbo",
  "attributes": [ /* attributes[] below */ ],
  "relationships": [ /* derived references */ ],
  "indexes": [ /* modeled indexes */ ]
}
```

**Attribute shape (per column):**

```json
{
  "name": "Email",
  "physicalName": "EMAIL",
  "originalName": null,
  "dataType": "Text",
  "length": 255,
  "precision": null,
  "scale": null,
  "default": null,
  "isMandatory": true,
  "isActive": true,
  "isIdentifier": false,
  "isReference": 0,
  "refEntityId": null,
  "refEntity.name": null,
  "refEntity.physicalName": null,
  "reference.deleteRuleCode": null,
  "reference.hasDbConstraint": 0,
  "external.dbType": null,
  "physical.isPresentButInactive": 0
}
```

**Relationships:**

```json
{
  "viaAttributeId": 12345,
  "viaAttributeName": "CityId",
  "toEntity.name": "City",
  "toEntity.physicalName": "OSUSR_DEF_CITY",
  "deleteRuleCode": "Protect",
  "hasDbConstraint": 1
}
```

**Indexes:**

```json
{
  "name": "IDX_CUSTOMER_EMAIL",
  "isUnique": true,
  "isPlatformAuto": 0,
  "columns": [
    { "attribute": "Email", "physicalColumn": "EMAIL", "ordinal": 1 }
  ]
}
```

**JSON schema** (optional) — validate with `NJsonSchema` or `JsonSchema.Net` before mapping.

---

## 5. .NET Solution Architecture

**Principles**

* **No regex / no string-concat** for schema; only SMO (and ScriptDom for DMM parse).
* **Layered & DI-friendly**: parse → validate → profile → decide → build → emit.
* **Deterministic**: same input → same files.

**Key interfaces**

```csharp
public interface IModelProvider { Task<ModelRoot> LoadAsync(Stream json, CancellationToken ct = default); }
public interface IModelValidator { ValidationReport Validate(ModelRoot model); }
public interface IDataProfiler { Task<ProfileSnapshot> CaptureAsync(string conn, IEnumerable<TableRef> tables, IEnumerable<(LogicalFkRef Ref,bool IsDbConstraintPresent)> refs, IEnumerable<(TableRef Table,string Column)> uniqueSingles, CancellationToken ct = default); }
public interface ISqlServerObjectBuilder { Database Build(ModelRoot model, SmoBuildOptions options); }
public interface IDdlEmitter { /* not used when we emit per-table via PerTableDdlEmitter */ }
```

---

## 6. Profiling: Catalog + Data Reality Sweep

**What we collect**

* Physical: `sys.columns.is_nullable`, computed, defaults, PK/unique membership.
* Data: per-column **NULL counts** and **row count** (one dynamic query per table).
* Uniqueness: duplicates for **single-column** modeled unique indexes.
* FKs without DB constraint: **orphans** (`EXISTS` mismatch).

**Profiler implementation** (excerpt)

```csharp
public sealed class SqlServerDataProfiler : IDataProfiler
{
  public async Task<ProfileSnapshot> CaptureAsync(
      string connectionString,
      IEnumerable<TableRef> tables,
      IEnumerable<(LogicalFkRef Ref, bool IsDbConstraintPresent)> logicalRefs,
      IEnumerable<(TableRef Table, string Column)> uniqueSingleColumnCandidates,
      CancellationToken ct = default)
  {
    // 1) sys.* snapshot per table (columns, defaults, PK/unique membership)
    // 2) one dynamic SELECT per table to compute NULL counts + rowcount
    // 3) per-candidate duplicate checks
    // 4) orphan checks for refs without DB constraints
  }
}
```

**Dynamic per-table NULL profiling** (generated for each table):

```sql
DECLARE @rc BIGINT;
SELECT @rc = COUNT_BIG(*) FROM [dbo].[MyTable];
SELECT
  SUM(CASE WHEN [Col1] IS NULL THEN 1 ELSE 0 END) AS [Col1],
  SUM(CASE WHEN [Col2] IS NULL THEN 1 ELSE 0 END) AS [Col2],
  @rc AS __rowcount
FROM [dbo].[MyTable];
```

---

## 7. Tightening Policy (NOT NULL / UNIQUE / FK Decisions)

**Signals**

* S1: PK (OutSystems `IsIdentifier`) ⇒ `NOT NULL`
* S2: Physical `is_nullable=0` ⇒ `NOT NULL`
* S3: FK with DB constraint ⇒ strong `NOT NULL` for FK column
* S4: Single-column UNIQUE with no duplicates ⇒ strong `NOT NULL`
* S5: Logical `isMandatory` ⇒ weak signal
* S7: Default exists ⇒ combine with S5

**Modes**

* **Cautious**: S1 ∪ S2 only
* **EvidenceGated (default)**: S1 ∪ S2 ∪ ((S3 ∪ S4 ∪ (S5∧S7)) ∧ (NULLs==0))
* **Aggressive**: S1 ∪ S2 ∪ S3 ∪ S4 ∪ S5 (with **pre-remediation SQL**)

**Decisions DTOs**

```csharp
public sealed record NullabilityDecision(bool MakeNotNull, string Rationale, string? PreRemediationSql = null);
public sealed record UniqueDecision(bool EnforceUnique, string Rationale, string? PreRemediationSql = null);
public sealed record ForeignKeyDecision(bool CreateConstraint, string Rationale, string? PreRemediationSql = null);
public sealed record TighteningDecisions(...);
```

**Sample pre-remediation (Aggressive mode)**

```sql
-- Null fix by type heuristic; customize per domain
UPDATE [dbo].[Orders]
SET [CustomerId] = 0     -- or map to known sentinel
WHERE [CustomerId] IS NULL;
```

---

## 8. SMO Builder (No Regex; Pure Objects → DDL)

**Key mapping rules**

* Columns: **nullable by default**, then apply `NullabilityDecision` (set `Nullable=false` when decided).
* PK: single column `Id` (`IsIdentifier`).
* UNIQUE: keep modeled unique; suppress if `UniqueDecision.EnforceUnique == false`.
* FK: add only when `ForeignKeyDecision.CreateConstraint == true`.

**Builder options + implementation** (excerpt)

```csharp
public sealed class SmoObjectBuilder : ISqlServerObjectBuilder
{
  public Database Build(ModelRoot model, SmoBuildOptions options)
  {
    var db = new Database(new Server(new ServerConnection()), options.DatabaseName ?? "ModelScratch");
    // ... create schemas, tables, columns (apply decisions), PK, indexes, FKs ...
    return db;
  }
}
```

---

## 9. Per-Table DDL Emitter (SSDT-Ready Output)

**Output layout**

```
out/
  Modules/
    <ModuleName>/
      Tables/<schema>.<table>.sql          # CREATE TABLE + PK
      Indexes/<schema>.<table>.indexes.sql # CREATE INDEX (non-PK)
      ForeignKeys/<schema>.<table>.fks.sql # ALTER TABLE ADD CONSTRAINT FK...
      PreRemediation/<schema>.<table>.pre.sql # data fixes (optional)
  manifest.json
  README.txt
```

> **Identifier casing:** the emitter now projects each table and column to its logical, human-readable name by default (for example, `dbo.OSUSR_ABC_CUSTOMER` becomes `dbo.Customer` and columns like `ID`/`NAME` render as `Id`/`Name`). Explicit overrides supplied via configuration or `--rename-table` still win when you need deterministic collision handling across modules.

**Emitter** uses three **Scripter** passes with distinct `ScriptingOptions`:

* **Tables**: PK only; no non-PK indexes, no FKs.
* **Indexes**: exclude PK; emit unique/nonunique indexes.
* **FKs**: emit ADD CONSTRAINTs per origin table.

**PerTableDdlEmitter** (excerpt)

```csharp
var scripterTables = new Scripter(db.Parent) { Options = _tableOpts };
var scripterIdx    = new Scripter(db.Parent) { Options = _indexOpts };
var scripterFk     = new Scripter(db.Parent) { Options = _fkOpts };
// iterate modules/entities, locate SMO table, script urns, write files
```

**SSDT import**
Create a Database Project → Add items from `Tables/`, then `Indexes/`, then `ForeignKeys/`.
Optionally include `PreRemediation/*.pre.sql` as **Pre-Deploy** steps or run once before publish.

---

## 10. DMM Parity Comparator (ScriptDom, PK-only, NOT NULL)

**Why**
DMM will push a **PK-only, all `NOT NULL`** schema into SSDT. We ensure our intent matches that **exactly**.

**Steps**

1. **Lens** our model into **DMM shape** (all columns `NotNull=true`; PK = Identifier).
2. **Parse DMM DDL** with **ScriptDom** (no regex) into a comparable model.
3. **Compare**: table presence, column order/names/types/length/precision/scale, PK column list.

**Lens** (excerpt)

```csharp
public static DmmDatabase Project(ModelRoot model) { /* build DmmTable/Column with NotNull=true */ }
```

**Parser** (excerpt)

```csharp
var parser = new TSql150Parser(initialQuotedIdentifiers: true);
var fragment = parser.Parse(new StringReader(script), out errors);
// visitor collects CreateTable + ALTER TABLE ... ADD CONSTRAINT PK statements
```

**Comparator** (excerpt)

```csharp
if (!lcol.Name.Equals(rcol.Name, OrdinalIgnoreCase)) diff.Add("col name mismatch ...");
if (!TypeEq(lcol, rcol)) diff.Add("type mismatch ...");
if (!rcol.NotNull) diff.Add("expected NOT NULL but actual nullable");
if (!lt.PrimaryKey.Columns.SequenceEqual(rt.PrimaryKey.Columns, OrdinalIgnoreCase)) diff.Add("PK columns differ");
```

> **Roadmap:** upcoming comparator hardening will canonicalize ScriptDom type facets (length/precision/scale) and expand parsing coverage to inline `CREATE TABLE` PK declarations plus mixed `ALTER TABLE` batches. Track progress in `tasks.md` §6 and the living test plan §6.3/§6.7.

**CLI example**

```bash
dotnet run --project src/Osm.Cli dmm-compare \
  --in model.json \
  --dmm dmm_out/*.sql \
  --out out/dmm-diff.json
```

---

## 11. CI/CD & PR Workflow

1. **Generate/refresh** `model.json` (Advanced SQL) for target modules.
2. **Run build-ssdt** to emit per-table DDL and **manifest.json**.
3. **(Optional) DMM parity**: run comparator; **fail** if diffs.
4. **Create PR** into SSDT repo (or copy files) with a standard layout.
5. **Review gates**:

   * No missing tables/files (check `manifest.json` vs DB).
   * No nullability violations unless pre-scripts included.
   * DMM parity passes (if you use DMM as source-of-deploy).
   * `dmm-compare` returns non-zero and writes a diff artifact whenever drift is detected (tracked in `tasks.md` §7).

---

## 12. Testing Strategy

* **Golden tests**: assert scripted DDL equals expected snapshots for small models — see the `Osm.Etl.Integration.Tests` suite for the fixture-to-emission parity check.
* **Property tests**: randomly generate entity/attribute combos and ensure builder+emitter don’t throw; output compiles in SSDT.
* **Policy tests**: verify EvidenceGated mode only flips `NOT NULL` when `NullCount==0`.
* **DMM parser tests**: parse curated T-SQL variants (CREATE TABLE PK inline; PK via ALTER TABLE; case/quote variants).
* **Performance**: profile a 100+ table model; ensure single pass per layer and per-table dynamic profiling.
* **Evidence cache longevity**: validate cache eviction/refresh semantics when module selections change and smoke the forthcoming live SQL adapter. *(See `notes/test-plan.md` §18.5–§18.6.)*

---

## 13. Configuration & Environment

**Baseline toggles**

The repository ships with `config/default-tightening.json`, which the configuration deserializer loads into `TighteningOptions` (EvidenceGated policy, FK creation enabled, platform auto-indexes suppressed). Use it as the starting point for local runs or copy it into environment-specific settings before overriding individual flags.

```jsonc
"emission": {
  "perTableFiles": true,
  "includePlatformAutoIndexes": false,
  "sanitizeModuleNames": true,
  "emitConcatenatedConstraints": false,
  "namingOverrides": {
    "tables": [
      { "schema": "dbo", "table": "OSUSR_ABC_CUSTOMER", "override": "CUSTOMER_PORTAL" }
    ]
  }
}
```

The `namingOverrides.tables` collection remaps the emitted table name (and derived PK/FK/manifest identifiers) without mutating the original OutSystems metadata. CLI callers can layer ad-hoc renames with `--rename-table dbo.OSUSR_ABC_CUSTOMER=CUSTOMER_PORTAL`, separating multiple overrides with `;` or `,`.

**AppSettings (example)**

```json
{
  "Profiling": {
    "ConnectionString": "Server=.;Database=MyDb;Integrated Security=true",
    "NullBudget": 0.0
  },
  "Policy": { "Mode": "EvidenceGated" },
  "Output": { "Root": "./out" }
}
```

**CLI flags**

* `extract-model`
  * `--mock-advanced-sql <manifest.json>` — replay deterministic Advanced SQL payloads (until the live SQL adapter ships).
  * `--modules <csv>` — optional module filter; trimmed, case-insensitive.
  * `--include-system-modules` — include OutSystems system producers.
  * `--include-inactive-attributes` — future toggle to rehydrate inactive columns when downstream tooling still expects them.
  * `--out <path>` — destination for the JSON payload (defaults to `model.extracted.json`).
* `build-ssdt`
  * `--model <model.json>` / `--profile <profile.json>` — deterministic inputs (fixtures or cached extraction outputs).
  * `--config <tightening.json>` — optional policy overrides.
  * `--out <directory>` — emission root (`./out` by default).
  * `--cache-root <directory>` / `--refresh-cache` — evidence cache control for model/profile/DMM/config artifacts.
  * `--rename-table schema.table=Override` — rename the emitted table/constraint identifiers (separate multiple overrides with `;` or `,`).
* `dmm-compare`
  * `--model <model.json>` / `--profile <profile.json>` — same as `build-ssdt`.
  * `--dmm <path>` — baseline DMM script to compare against SMO output.
  * `--config`, `--cache-root`, `--refresh-cache` — same semantics as `build-ssdt`.

---

## 14. Troubleshooting & Gotchas

* **“Mandatory” vs DB `NOT NULL`**: OutSystems `isMandatory` is logical; our policy upgrades to `NOT NULL` only with evidence (or Aggressive + pre-fix).
* **Index ASC/DESC**: OutSystems model doesn’t expose per-column sort direction; DDL omits direction (default ASC).
* **Cross-catalog FKs**: metamodel can show logical refs that DB can’t enforce; policy won’t create FK when catalogs/schemas differ (or when orphans exist).
* **Inactive attributes**: columns flagged `isActive = false` or `physical.isPresentButInactive = 1` are omitted from emission by default while remaining in the decision log for audit trails.
* **Constraint casing**: emitted PK/IX/FK identifiers are regenerated using PascalCase table/column names; table rename overrides propagate across every constraint artifact.
* **Name collisions**: sanitized module names keep paths safe; use `emission.namingOverrides.tables` or `--rename-table` when downstream tooling requires human-friendly table/constraint names.
* **ScriptDom parsing errors**: DMM DDL must be valid T-SQL; errors list file & line.

---

## 15. Security, Performance, and Operations

* **Security**: profiling uses `SELECT`; no DDL or data mutation occurs unless you run pre-scripts manually. Keep connection strings in KeyVault/Secrets.
* **Performance**: per-table dynamic NULL queries are O(columns); avoid running on peak hours. For very large tables, consider sampling (configurable) before full run.
* **Observability**: log module/entity counts, decision rationale (`PK`, `DB_NOT_NULL`, `UNIQUE_NO_NULLS`, etc.), and any generated pre-scripts.

---

## 16. Extensibility Roadmap

* **ScriptDom type parser** for `external.dbType` → exact SMO `DataType`.
* **Check constraints**: model custom checks from your domain JSON (not native to OS), and emit `CHECK` statements.
* **Seed data** for static entities: dump rows and emit idempotent `MERGE` scripts.
* **Automated pre-deploy runner**: Wire pre-scripts into a controlled pre-deployment phase before SSDT publish.
* **Bidirectional diff**: parse SSDT project files and detect drift vs model.

---

### Appendix A — Representative C# Snippets

**TighteningPolicy core**

```csharp
bool D1zero = (p.NullCount ?? 0) == 0 || nullRate <= _nullBudget;
makeNotNull = _mode switch
{
  TighteningMode.Cautious      => S1 || S2,
  TighteningMode.EvidenceGated => S1 || S2 || ((S3 || S4 || (S5 && S7)) && D1zero),
  TighteningMode.Aggressive    => S1 || S2 || S3 || S4 || S5,
};
```

**SMO PK creation**

```csharp
var pk = new Index(table, $"PK_{entity.PhysicalName}")
{
  IndexKeyType = IndexKeyType.DriPrimaryKey,
  IsClustered = true
};
pk.IndexedColumns.Add(new IndexedColumn(pk, idAttr.PhysicalName));
table.Indexes.Add(pk);
```

**FK creation (policy enforced)**

```csharp
var fk = new ForeignKey(fromTable, $"FK_{fromTable.Schema}_{fromTable.Name}_{viaCol}_{toTable.Name}")
{
  ReferencedTable = toTable.Name, ReferencedTableSchema = toTable.Schema
};
fk.Columns.Add(new ForeignKeyColumn(fk, viaCol, "ID"));
fromTable.ForeignKeys.Add(fk);
```

**Per-table scripting helper**

```csharp
string JoinBatches(IEnumerable batches)
{
  var sb = new StringBuilder();
  foreach (var b in batches) { sb.AppendLine(b.ToString()); sb.AppendLine("GO"); }
  return sb.ToString().Trim();
}
```

**ScriptDom type normalization (example)**

```csharp
private static string TypeToString(DataTypeReference dtr)
{
  var name = string.Join("", dtr.Name.Identifiers.Select(i => i.Value)).ToLowerInvariant();
  var (len, prec, scale) = ExtractFacet(dtr);
  return name switch
  {
    "nvarchar" => len is null ? "nvarchar(max)" : $"nvarchar({len})",
    "varchar"  => len is null ? "varchar(max)"  : $"varchar({len})",
    "decimal" or "numeric" => $"decimal({prec ?? 18},{scale ?? 0})",
    _ => name
  };
}
```

---

### Appendix B — Example CLI Usage

**Emit SSDT-ready DDL (EvidenceGated)**

```bash
dotnet run --project src/Osm.Cli build-ssdt \
  --in ./model.json \
  --profile-conn "Server=.;Database=ProdClone;Trusted_Connection=True" \
  --mode EvidenceGated \
  --out ./out
```

**Aggressive mode with remediation**

```bash
dotnet run --project src/Osm.Cli build-ssdt \
  --in ./model.json \
  --profile-conn "Server=.;Database=ProdClone;Trusted_Connection=True" \
  --mode Aggressive \
  --out ./out
# Inspect out/Modules/*/PreRemediation/*.pre.sql before running
```

**DMM Parity Check**

```bash
dotnet run --project src/Osm.Cli dmm-compare \
  --in ./model.json \
  --dmm ./dmm/*.sql \
  --out ./out/dmm-diff.json
```

---

### Appendix C — Manifest & README Generated

**manifest.json** (sample)

```json
{
  "generatedAtUtc": "2025-09-26T01:23:45Z",
  "modules": [
    {
      "name": "AppCore",
      "entities": [
        {
          "schema": "dbo",
          "table": "OSUSR_ABC_CUSTOMER",
          "paths": {
            "table": "Modules/AppCore/Tables/dbo.OSUSR_ABC_CUSTOMER.sql",
            "indexes": "Modules/AppCore/Indexes/dbo.OSUSR_ABC_CUSTOMER.indexes.sql",
            "fks": "Modules/AppCore/ForeignKeys/dbo.OSUSR_ABC_CUSTOMER.fks.sql",
            "pre": "Modules/AppCore/PreRemediation/dbo.OSUSR_ABC_CUSTOMER.pre.sql"
          }
        }
      ]
    }
  ]
}
```

**README.txt** (emitted alongside artifacts)

```
This folder contains per-table DDL organized by OutSystems Module.

Import guidance (SSDT):
1) Create a new SQL Server Database Project.
2) Add items from Modules/<Module>/Tables first, then Indexes, then ForeignKeys.
3) Optionally add PreRemediation/*.pre.sql as Pre-Deployment, or run manually once.
4) Build & publish / open PR.

Emission rules:
- Tables: CREATE TABLE with PRIMARY KEY only (no non-PK indexes, no FKs).
- Indexes: non-PK indexes (unique and nonunique).
- ForeignKeys: ALTER TABLE ... ADD CONSTRAINT for outgoing FKs.
```

---

You now have **everything** needed to implement, operate, and extend this pipeline—end-to-end—from OutSystems Advanced SQL through profiling and policy-driven tightening to SSDT-ready per-table DDL, plus a DMM comparator for PK-only, NOT-NULL parity. If you want me to tailor the default **type map** (e.g., treat OutSystems `Identifier` as `bigint`), say which variant you prefer and I’ll inline the exact mapper.
