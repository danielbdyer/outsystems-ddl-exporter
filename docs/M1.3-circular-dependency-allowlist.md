# M1.3: Circular Dependency Allowlist with Manual Ordering

## Overview

When the exporter detects circular dependencies (e.g., User ↔ Organization), you have two options:

1. **Let it fail** (default) - Get detailed diagnostics about what's wrong
2. **Allow and manually order** (M1.3) - Explicitly control load order with z-index-style positioning

## When to Use the Allowlist

✅ **Use allowlist when**:
- Circular dependency is **intentional** (e.g., bidirectional ownership)
- At least one FK is **nullable** (enables phased loading)
- You understand the **load sequence** required

❌ **Don't use allowlist when**:
- All FKs are **NOT NULL** (can't be loaded without schema changes)
- CASCADE deletes in both directions (data loss risk)
- Cycle is **accidental** (indicates schema design issue)

## Configuration Model

### CircularDependencyOptions

```csharp
public sealed record CircularDependencyOptions
{
    /// <summary>
    /// List of allowed circular dependencies with explicit ordering
    /// </summary>
    public ImmutableArray<AllowedCycle> AllowedCycles { get; init; }

    /// <summary>
    /// When true, fail on ANY cycle (even if allowed). Default: false.
    /// </summary>
    public bool StrictMode { get; init; } = false;
}
```

### AllowedCycle

```csharp
public sealed record AllowedCycle
{
    /// <summary>
    /// Tables with explicit z-index-style ordering (lower = earlier)
    /// </summary>
    public ImmutableArray<TableOrdering> TableOrdering { get; init; }

    /// <summary>
    /// Why this cycle is intentional
    /// </summary>
    public string Reason { get; init; }

    /// <summary>
    /// Who approved this (audit trail)
    /// </summary>
    public string? ApprovedBy { get; init; }

    /// <summary>
    /// When approved
    /// </summary>
    public DateTimeOffset? ApprovedDate { get; init; }
}
```

### TableOrdering

```csharp
public sealed record TableOrdering
{
    /// <summary>
    /// Physical table name (e.g., "OSUSR_USER")
    /// </summary>
    public string TableName { get; init; }

    /// <summary>
    /// Load position (lower numbers load first, like z-index)
    /// </summary>
    public int Position { get; init; }
}
```

## Example: User ↔ Organization Cycle

### The Problem

```
User.OrganizationId → Organization.Id
Organization.CreatedBy → User.Id
```

Both tables reference each other. Which loads first?

### The Solution

```json
{
  "allowedCycles": [
    {
      "tableOrdering": [
        {
          "tableName": "OSUSR_ORGANIZATION",
          "position": 100
        },
        {
          "tableName": "OSUSR_USER",
          "position": 200
        }
      ],
      "reason": "Organization has CreatedBy (nullable FK to User). Load Organization first with NULL CreatedBy, then User, then UPDATE Organization.CreatedBy.",
      "approvedBy": "Danny Dyer",
      "approvedDate": "2025-11-19T00:00:00Z"
    }
  ],
  "strictMode": false
}
```

### Load Sequence

**Position 100**: OSUSR_ORGANIZATION
```sql
INSERT INTO OSUSR_ORGANIZATION (Id, Name, CreatedBy)
VALUES (1, 'Acme Corp', NULL); -- NULL because User doesn't exist yet
```

**Position 200**: OSUSR_USER
```sql
INSERT INTO OSUSR_USER (Id, Name, OrganizationId)
VALUES (1, 'John Doe', 1); -- Can reference Organization (already exists)
```

**Post-load UPDATE** (handled externally):
```sql
UPDATE OSUSR_ORGANIZATION
SET CreatedBy = 1
WHERE Id = 1;
```

## Z-Index Style Positioning

Positions work like CSS z-index:
- **Lower numbers load first**
- **Higher numbers load later**
- **Gaps are OK** (use 100, 200, 300 to leave room for future insertions)

### Example: Multiple Cycles

```json
{
  "allowedCycles": [
    {
      "tableOrdering": [
        {"tableName": "OSUSR_ORG", "position": 100},
        {"tableName": "OSUSR_USER", "position": 200}
      ],
      "reason": "User ↔ Organization cycle"
    },
    {
      "tableOrdering": [
        {"tableName": "OSUSR_PRODUCT", "position": 300},
        {"tableName": "OSUSR_CATEGORY", "position": 400}
      ],
      "reason": "Product ↔ Category cycle"
    }
  ]
}
```

**Load order**: ORG (100) → USER (200) → PRODUCT (300) → CATEGORY (400)

## Bootstrap Script Output

### Without Allowlist (Cycle Detected)
```sql
-- ⚠️  CIRCULAR DEPENDENCY DETECTED
--
--   ⚠️  DISALLOWED Cycle: OSUSR_USER → OSUSR_ORGANIZATION → OSUSR_USER
--
--   Recommendation:
--     Cycle can be handled with phased loading (nullable FKs: FK_ORG_CREATOR)
--     Strategy: INSERT with NULL → INSERT dependents → UPDATE with FK values
```

### With Allowlist (Cycle Allowed)
```sql
-- ℹ️  ALLOWED CIRCULAR DEPENDENCY (Manual Ordering Applied)
--
--   ✓ ALLOWED Cycle: OSUSR_ORGANIZATION → OSUSR_USER → OSUSR_ORGANIZATION
--     Reason: Organization has CreatedBy (nullable FK). Load Org first, then User.
--     Manual ordering override active - see TableOrdering configuration
--
--   Note: Manual ordering applied from CircularDependencyOptions configuration
```

## Strict Mode

When `strictMode: true`, **ALL cycles fail** (even if allowed):

```json
{
  "allowedCycles": [...],
  "strictMode": true
}
```

**Use case**: Zero-tolerance environments where circular dependencies must never exist, regardless of configuration.

## Business Logic Rules

### Allowlist Matching
- Cycle matches if **all tables** in allowlist are in the detected cycle
- Table names compared **case-insensitively**
- Must match **exact table count** (no partial matches)

### Position Validation
- Each table must have **unique position** (no duplicates)
- Positions must be **non-negative**
- Gaps between positions are allowed and encouraged

### Recommendations Still Shown
- Even for allowed cycles, FK metadata is displayed
- Helps operators understand **why** cycle is safe
- Warns about CASCADE deletes even in allowed cycles

## Integration with Exporter

### Current State (M1.3 MVP)
- Configuration model defined
- Allowlist matching implemented
- Bootstrap script shows allowed vs. disallowed cycles
- **NOT YET INTEGRATED**: Need to wire up to load actual config from file/CLI

### Future Work (Post-MVP)
1. **Configuration loader**: Read JSON file or CLI args
2. **Apply manual ordering**: Use positions to override topological sort
3. **Validation**: Ensure nullable FKs exist for phased loading
4. **CLI flags**: `--allow-circular-deps` and `--strict-mode`

## Example Workflow

1. **Run exporter** - Detects User ↔ Organization cycle
2. **Review diagnostics** - See FK_ORG_CREATOR is nullable
3. **Create allowlist** - Add configuration with positions
4. **Re-run exporter** - Cycle now allowed, manual ordering applied
5. **Load data** - Follow recommended phased loading strategy

## FAQ

**Q: Do I need to specify ALL tables, or just the ones in the cycle?**
A: Just the ones in the cycle. Other tables load normally via topological sort.

**Q: What if I have multiple independent cycles?**
A: Create one `AllowedCycle` entry per cycle. Each gets its own position range.

**Q: Can positions overlap between cycles?**
A: Yes! Positions only need to be unique **within** each cycle, not globally.

**Q: What happens if I forget a table in the allowlist?**
A: Cycle won't match, will be reported as DISALLOWED.

**Q: Can I use negative positions?**
A: No, positions must be non-negative.

## Summary

M1.3 Allowlist provides:
- ✅ **Explicit control** over cycle handling
- ✅ **Z-index-style ordering** for intuitive positioning
- ✅ **Audit trail** (reason, approver, date)
- ✅ **Strict mode** for zero-tolerance environments
- ✅ **Clear diagnostics** for allowed vs. disallowed cycles

This gives operators the power to **intentionally** handle circular dependencies when they're unavoidable, while still maintaining visibility and control.
