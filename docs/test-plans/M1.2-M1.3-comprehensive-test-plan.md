# M1.2/M1.3 Comprehensive Test Plan: Circular Dependency Diagnostics

**Date**: 2025-11-19
**Status**: READY FOR IMPLEMENTATION
**Priority**: ðŸ”´ CRITICAL - User blocked by unclear circular dependency errors

---

## Executive Summary

### The Problem

User reports circular dependency failures with **insufficient diagnostics**:
- Export fails with generic "cycle detected" message
- No information about **which tables** are involved in the cycle
- No guidance on **how to resolve** the cycle
- Unclear whether circular dependencies are **genuinely problematic** or can be handled

### The Solution

Implement comprehensive circular dependency diagnostics with:
1. **Cycle Detection & Reporting**: Identify exact tables and FKs involved in cycles
2. **Cycle Visualization**: Show the dependency path that creates the cycle
3. **Operator Guidance**: Provide actionable recommendations for resolution
4. **Flexible Handling**: Support operator override for acceptable cycles (self-references, nullable FKs)

---

## Test-Driven Design Philosophy

This test plan follows **strict TDD principles**:

1. **Write failing tests FIRST** - Every feature starts with a red test
2. **Minimal implementation** - Make tests pass with simplest code
3. **Refactor mercilessly** - Clean up while keeping tests green
4. **No untested code** - 100% coverage for critical paths
5. **Test behavior, not implementation** - Focus on observable outcomes

---

## Test Categories

### Category 1: Circular Dependency Detection (M1.2 Core)

**Goal**: Detect and report all types of circular dependencies with maximum diagnostic detail

#### Test 1.1: Simple Two-Way Cycle (A â†” B)

```csharp
[Fact]
public void DetectCircularDependency_TwoWayCycle_ReportsExactCycle()
{
    // Arrange: A references B, B references A
    var validator = new CircularDependencyDetector();

    var tableA = CreateTableWithFK("A", "OSUSR_A", fkTo: "OSUSR_B");
    var tableB = CreateTableWithFK("B", "OSUSR_B", fkTo: "OSUSR_A");

    var tables = ImmutableArray.Create(tableA, tableB);
    var model = CreateModelWithRelationships(
        ("A", "OSUSR_A") => ("B", "OSUSR_B", "FK_A_B"),
        ("B", "OSUSR_B") => ("A", "OSUSR_A", "FK_B_A"));

    // Act
    var result = validator.DetectCycles(tables, model);

    // Assert
    Assert.True(result.HasCycles);
    Assert.Single(result.Cycles);

    var cycle = result.Cycles[0];
    Assert.Equal(2, cycle.Tables.Length);
    Assert.Contains("OSUSR_A", cycle.Tables);
    Assert.Contains("OSUSR_B", cycle.Tables);

    // Verify cycle path is reported clearly
    Assert.Equal("A â†’ B â†’ A", cycle.Path);
    Assert.Contains("FK_A_B", cycle.ForeignKeys);
    Assert.Contains("FK_B_A", cycle.ForeignKeys);
}
```

**Expected Diagnostic Output**:
```
âš ï¸  Circular Dependency Detected (Cycle 1 of 1)

  Path: A â†’ B â†’ A

  Tables involved:
    - [OSUSR_A] (dbo.OSUSR_A)
    - [OSUSR_B] (dbo.OSUSR_B)

  Foreign Keys in cycle:
    - FK_A_B: A.BId â†’ B.Id
    - FK_B_A: B.AId â†’ A.Id

  Recommendation:
    This is a true circular reference. Consider:
    1. Make one FK nullable (allow breaking the cycle during data load)
    2. Use SET NULL or NO ACTION on delete for one FK
    3. Load data in two phases (insert with NULL, then UPDATE)
```

#### Test 1.2: Three-Way Cycle (A â†’ B â†’ C â†’ A)

```csharp
[Fact]
public void DetectCircularDependency_ThreeWayCycle_ReportsFullPath()
{
    // Arrange: A â†’ B â†’ C â†’ A
    var validator = new CircularDependencyDetector();

    var tableA = CreateTableWithFK("A", "OSUSR_A", fkTo: "OSUSR_B");
    var tableB = CreateTableWithFK("B", "OSUSR_B", fkTo: "OSUSR_C");
    var tableC = CreateTableWithFK("C", "OSUSR_C", fkTo: "OSUSR_A");

    var tables = ImmutableArray.Create(tableA, tableB, tableC);
    var model = CreateModelWithChainedRelationships(
        "A" => "B",
        "B" => "C",
        "C" => "A");

    // Act
    var result = validator.DetectCycles(tables, model);

    // Assert
    Assert.True(result.HasCycles);
    Assert.Single(result.Cycles);

    var cycle = result.Cycles[0];
    Assert.Equal(3, cycle.Tables.Length);
    Assert.Equal("A â†’ B â†’ C â†’ A", cycle.Path);
    Assert.Equal(3, cycle.ForeignKeys.Count);
}
```

**Expected Diagnostic Output**:
```
âš ï¸  Circular Dependency Detected (Cycle 1 of 1)

  Path: A â†’ B â†’ C â†’ A

  Tables involved:
    - [OSUSR_A] (dbo.OSUSR_A)
    - [OSUSR_B] (dbo.OSUSR_B)
    - [OSUSR_C] (dbo.OSUSR_C)

  Foreign Keys in cycle:
    - FK_A_B: A.BId â†’ B.Id
    - FK_B_C: B.CId â†’ C.Id
    - FK_C_A: C.AId â†’ A.Id

  Recommendation:
    This is a multi-table circular reference. Consider:
    1. Break the cycle by making FK_C_A nullable
    2. Review domain model - circular dependencies often indicate design issues
```

#### Test 1.3: Self-Referencing Table (Employee â†’ Manager)

```csharp
[Fact]
public void DetectCircularDependency_SelfReference_AllowedByDefault()
{
    // Arrange: Employee references itself (ManagerId â†’ Employee)
    var validator = new CircularDependencyDetector();

    var employee = CreateTableWithSelfReference("Employee", "OSUSR_EMPLOYEE", "ManagerId");
    var tables = ImmutableArray.Create(employee);
    var model = CreateModelWithSelfReference("Employee", "OSUSR_EMPLOYEE", "ManagerId");

    // Act
    var result = validator.DetectCycles(tables, model);

    // Assert - Self-references should NOT be reported as cycles
    Assert.False(result.HasCycles);
    Assert.Empty(result.Cycles);

    // BUT should be documented in diagnostic info
    Assert.Single(result.SelfReferences);
    Assert.Equal("OSUSR_EMPLOYEE", result.SelfReferences[0].TableName);
}
```

**Expected Diagnostic Output**:
```
â„¹ï¸  Self-Referencing Tables Detected (1)

  [OSUSR_EMPLOYEE] (dbo.OSUSR_EMPLOYEE)
    - FK: FK_EMPLOYEE_MANAGER (ManagerId â†’ Id)
    - Nullable: Yes
    - Status: âœ… Allowed (self-references are valid with nullable FK)
```

#### Test 1.4: Multiple Independent Cycles

```csharp
[Fact]
public void DetectCircularDependency_MultipleIndependentCycles_ReportsAll()
{
    // Arrange: Cycle 1: A â†” B, Cycle 2: X â†” Y
    var validator = new CircularDependencyDetector();

    var tableA = CreateTableWithFK("A", "OSUSR_A", fkTo: "OSUSR_B");
    var tableB = CreateTableWithFK("B", "OSUSR_B", fkTo: "OSUSR_A");
    var tableX = CreateTableWithFK("X", "OSUSR_X", fkTo: "OSUSR_Y");
    var tableY = CreateTableWithFK("Y", "OSUSR_Y", fkTo: "OSUSR_X");

    var tables = ImmutableArray.Create(tableA, tableB, tableX, tableY);
    var model = CreateModelWithTwoIndependentCycles();

    // Act
    var result = validator.DetectCycles(tables, model);

    // Assert
    Assert.True(result.HasCycles);
    Assert.Equal(2, result.Cycles.Length);

    // Verify both cycles are reported
    var cycleAB = result.Cycles.FirstOrDefault(c => c.Path.Contains("A") && c.Path.Contains("B"));
    var cycleXY = result.Cycles.FirstOrDefault(c => c.Path.Contains("X") && c.Path.Contains("Y"));

    Assert.NotNull(cycleAB);
    Assert.NotNull(cycleXY);
}
```

**Expected Diagnostic Output**:
```
âš ï¸  Circular Dependencies Detected (2 cycles found)

Cycle 1 of 2:
  Path: A â†’ B â†’ A
  Tables: OSUSR_A, OSUSR_B
  Foreign Keys: FK_A_B, FK_B_A

Cycle 2 of 2:
  Path: X â†’ Y â†’ X
  Tables: OSUSR_X, OSUSR_Y
  Foreign Keys: FK_X_Y, FK_Y_X

Recommendation:
  Multiple independent cycles detected. Address each cycle separately.
```

#### Test 1.5: Complex Cycle (Diamond Pattern)

```csharp
[Fact]
public void DetectCircularDependency_DiamondPattern_ReportsShortestCycle()
{
    // Arrange:
    //   A â†’ B â†’ D â†’ A  (cycle)
    //   A â†’ C â†’ D      (alternative path to D, not a cycle)
    var validator = new CircularDependencyDetector();

    var tableA = CreateTableWithMultipleFKs("A", "OSUSR_A", fkTo: ["OSUSR_B", "OSUSR_C"]);
    var tableB = CreateTableWithFK("B", "OSUSR_B", fkTo: "OSUSR_D");
    var tableC = CreateTableWithFK("C", "OSUSR_C", fkTo: "OSUSR_D");
    var tableD = CreateTableWithFK("D", "OSUSR_D", fkTo: "OSUSR_A");

    var tables = ImmutableArray.Create(tableA, tableB, tableC, tableD);
    var model = CreateDiamondDependencyModel();

    // Act
    var result = validator.DetectCycles(tables, model);

    // Assert
    Assert.True(result.HasCycles);
    Assert.Single(result.Cycles); // Only the actual cycle (A â†’ B â†’ D â†’ A)

    var cycle = result.Cycles[0];
    Assert.Contains("A â†’ B â†’ D â†’ A", cycle.Path); // Shortest cycle path
    Assert.DoesNotContain("C", cycle.Path); // C is not part of the cycle
}
```

---

### Category 2: Diagnostic Quality (M1.2 Enhancement)

**Goal**: Provide actionable, human-readable diagnostics for operators

#### Test 2.1: FK Nullability Analysis

```csharp
[Fact]
public void DiagnoseCycle_AnalyzesFKNullability_SuggestsBreakPoints()
{
    // Arrange: Cycle where one FK is nullable
    var validator = new CircularDependencyDiagnosticAnalyzer();

    var cycle = new DetectedCycle(
        Tables: ["OSUSR_A", "OSUSR_B"],
        Path: "A â†’ B â†’ A",
        ForeignKeys: [
            new FKInfo("FK_A_B", "A", "B", IsNullable: false),
            new FKInfo("FK_B_A", "B", "A", IsNullable: true)
        ]);

    // Act
    var diagnostic = validator.Analyze(cycle);

    // Assert
    Assert.True(diagnostic.HasNullableFK);
    Assert.Equal("FK_B_A", diagnostic.RecommendedBreakPoint);
    Assert.Contains("FK_B_A is already nullable", diagnostic.Recommendation);
}
```

**Expected Diagnostic Output**:
```
âš ï¸  Circular Dependency Analysis

  Cycle: A â†’ B â†’ A

  Foreign Key Analysis:
    - FK_A_B: A.BId â†’ B.Id
      â€¢ Nullable: NO
      â€¢ Delete Rule: CASCADE
      â€¢ Break Potential: âš ï¸  Low (not nullable, cascade delete)

    - FK_B_A: B.AId â†’ A.Id
      â€¢ Nullable: YES âœ…
      â€¢ Delete Rule: SET NULL
      â€¢ Break Potential: âœ… High (already nullable, safe to break)

  Recommendation:
    FK_B_A is already nullable and can safely break the cycle during data load.
    Load sequence: Insert A with NULL â†’ Insert B â†’ UPDATE A.BId
```

#### Test 2.2: Delete Rule Analysis

```csharp
[Fact]
public void DiagnoseCycle_AnalyzesDeleteRules_WarnsCascadeRisks()
{
    // Arrange: Cycle with CASCADE delete rules (dangerous!)
    var validator = new CircularDependencyDiagnosticAnalyzer();

    var cycle = new DetectedCycle(
        Tables: ["OSUSR_A", "OSUSR_B"],
        Path: "A â†’ B â†’ A",
        ForeignKeys: [
            new FKInfo("FK_A_B", "A", "B", DeleteRule: "CASCADE"),
            new FKInfo("FK_B_A", "B", "A", DeleteRule: "CASCADE")
        ]);

    // Act
    var diagnostic = validator.Analyze(cycle);

    // Assert
    Assert.True(diagnostic.HasCascadeRisk);
    Assert.Contains("CASCADE delete in circular", diagnostic.Warnings);
}
```

**Expected Diagnostic Output**:
```
ðŸš¨ CRITICAL WARNING: CASCADE Delete in Circular Dependency

  Cycle: A â†’ B â†’ A

  Delete Rule Analysis:
    - FK_A_B: CASCADE
    - FK_B_A: CASCADE

  Risk:
    Deleting a single row from A or B will trigger CASCADE deletes in both directions,
    potentially deleting both tables completely!

  Recommendation:
    Change at least one FK to use "NO ACTION" or "SET NULL" to prevent cascade loops.
```

#### Test 2.3: Module Cross-Boundary Cycle Detection

```csharp
[Fact]
public void DiagnoseCycle_CrossModuleCycle_ReportsModuleInfo()
{
    // Arrange: Cycle spans multiple modules
    var validator = new CircularDependencyDiagnosticAnalyzer();

    var cycle = new DetectedCycle(
        Tables: [
            new TableInfo("OSUSR_USER", Module: "Core"),
            new TableInfo("OSUSR_ORDER", Module: "Sales"),
            new TableInfo("OSUSR_AUDIT", Module: "Logging")
        ],
        Path: "User â†’ Order â†’ Audit â†’ User",
        ForeignKeys: [...]);

    // Act
    var diagnostic = validator.Analyze(cycle);

    // Assert
    Assert.True(diagnostic.IsCrossModuleCycle);
    Assert.Equal(3, diagnostic.ModulesInvolved.Count);
}
```

**Expected Diagnostic Output**:
```
âš ï¸  Cross-Module Circular Dependency Detected

  Cycle: User â†’ Order â†’ Audit â†’ User

  Modules Involved:
    - Core (OSUSR_USER)
    - Sales (OSUSR_ORDER)
    - Logging (OSUSR_AUDIT)

  Recommendation:
    This cycle spans 3 modules. Consider:
    1. Review domain boundaries - cross-module cycles indicate tight coupling
    2. Move entities to same module if they're tightly related
    3. Break dependency with nullable FK at module boundary
```

---

### Category 3: Operator Override Mechanisms (M1.3 Core)

**Goal**: Allow operators to override cycle handling when circular dependencies are intentional

#### Test 3.1: Configuration-Based Cycle Allowlist

```csharp
[Fact]
public void AllowCircularDependency_ViaConfiguration_SkipsValidation()
{
    // Arrange
    var config = new CircularDependencyOptions
    {
        AllowedCycles = new[]
        {
            new CycleAllowlist
            {
                Tables = ["OSUSR_A", "OSUSR_B"],
                Reason = "Intentional cycle - represents bidirectional relationship",
                ApprovedBy = "Danny Dyer",
                ApprovedDate = new DateTimeOffset(2025, 11, 19, 0, 0, 0, TimeSpan.Zero)
            }
        }
    };

    var validator = new CircularDependencyDetector(config);
    var cycle = CreateABCycle();

    // Act
    var result = validator.DetectCycles([...], model);

    // Assert - Cycle detected but allowed
    Assert.True(result.HasCycles);
    Assert.Single(result.Cycles);
    Assert.True(result.Cycles[0].IsAllowed);
    Assert.Equal("Intentional cycle - represents bidirectional relationship",
                 result.Cycles[0].AllowanceReason);
}
```

**Configuration File Example** (`circular-dependencies.json`):
```json
{
  "allowedCycles": [
    {
      "tables": ["OSUSR_USER", "OSUSR_ORGANIZATION"],
      "reason": "User owns Organization, Organization has Creator (User)",
      "approvedBy": "Danny Dyer",
      "approvedDate": "2025-11-19T00:00:00Z",
      "loadStrategy": "PhaseLoad",
      "notes": "Insert User with NULL OrgId, then Org, then UPDATE User"
    }
  ],
  "strictMode": false
}
```

#### Test 3.2: Self-Reference Auto-Allowance

```csharp
[Fact]
public void AllowCircularDependency_SelfReferenceWithNullableFK_AutoAllowed()
{
    // Arrange
    var config = new CircularDependencyOptions
    {
        AutoAllowSelfReferences = true, // Default
        RequireNullableFKForSelfReference = true // Safety check
    };

    var validator = new CircularDependencyDetector(config);
    var selfRef = CreateSelfReferenceTable("Employee", nullable: true);

    // Act
    var result = validator.DetectCycles([selfRef], model);

    // Assert
    Assert.False(result.HasCycles); // Not reported as cycle
    Assert.Single(result.SelfReferences);
    Assert.True(result.SelfReferences[0].IsAllowed);
    Assert.Equal("Auto-allowed: Self-reference with nullable FK",
                 result.SelfReferences[0].AllowanceReason);
}
```

#### Test 3.3: Strict Mode - Fail on Any Cycle

```csharp
[Fact]
public void StrictMode_AnyCycleDetected_FailsExport()
{
    // Arrange
    var config = new CircularDependencyOptions
    {
        StrictMode = true, // Fail on any cycle, even allowed ones
        AllowedCycles = [] // Ignored in strict mode
    };

    var validator = new CircularDependencyDetector(config);
    var cycle = CreateABCycle();

    // Act
    var result = validator.DetectCycles([...], model);

    // Assert
    Assert.True(result.HasCycles);
    Assert.False(result.Cycles[0].IsAllowed); // Strict mode overrides allowlist
    Assert.Equal(ExportValidationStatus.Failure, result.Status);
}
```

#### Test 3.4: Warning Mode - Allow but Warn

```csharp
[Fact]
public void WarningMode_CycleDetected_AllowsWithWarning()
{
    // Arrange
    var config = new CircularDependencyOptions
    {
        FailOnCycle = false, // Warning mode
        LogWarnings = true
    };

    var validator = new CircularDependencyDetector(config);
    var cycle = CreateABCycle();

    // Act
    var result = validator.DetectCycles([...], model);

    // Assert
    Assert.True(result.HasCycles);
    Assert.Equal(ExportValidationStatus.Warning, result.Status);
    Assert.True(result.AllowExport); // Export continues despite cycle
    Assert.Contains("Circular dependency detected but export allowed",
                    result.Warnings);
}
```

---

### Category 4: Integration with TopologicalOrderingValidator (M1.2)

**Goal**: Ensure CircularDependencyDetector integrates smoothly with existing TopologicalOrderingValidator

#### Test 4.1: Validator Integration - Cycle Detected Before Ordering

```csharp
[Fact]
public async Task BuildBootstrapSnapshot_CycleDetected_FailsWithDiagnostics()
{
    // Arrange
    var step = new BuildSsdtBootstrapSnapshotStep(/* deps */);
    var state = CreateStateWithCircularDependency(); // A â†” B

    // Act
    var result = await step.ExecuteAsync(state, CancellationToken.None);

    // Assert
    Assert.False(result.IsSuccess);
    Assert.Contains("Circular dependency detected", result.Error.Message);
    Assert.Contains("A â†’ B â†’ A", result.Error.Message); // Cycle path
    Assert.Contains("FK_A_B", result.Error.Message); // FK details

    // Verify log contains full diagnostic
    var logEntry = state.Log.Entries.Single(e => e.Event == "bootstrap.circularDependency.detected");
    Assert.NotNull(logEntry.Metadata["cyclePath"]);
    Assert.NotNull(logEntry.Metadata["foreignKeys"]);
}
```

#### Test 4.2: Validator Integration - Allowed Cycle Continues

```csharp
[Fact]
public async Task BuildBootstrapSnapshot_AllowedCycle_ContinuesWithWarning()
{
    // Arrange
    var config = new CircularDependencyOptions
    {
        AllowedCycles = [new CycleAllowlist { Tables = ["OSUSR_A", "OSUSR_B"] }]
    };

    var step = new BuildSsdtBootstrapSnapshotStep(/* deps with config */);
    var state = CreateStateWithAllowedCycle();

    // Act
    var result = await step.ExecuteAsync(state, CancellationToken.None);

    // Assert
    Assert.True(result.IsSuccess);

    // Verify warning logged
    var warning = state.Log.Entries.Single(e => e.Event == "bootstrap.circularDependency.allowed");
    Assert.Equal("Cycle A â†’ B â†’ A detected but allowed via configuration",
                 warning.Message);
}
```

#### Test 4.3: TopologicalValidator Post-Sort Verification

```csharp
[Fact]
public void TopologicalValidator_WithAllowedCycle_StillDetectsViolations()
{
    // Arrange: Allowed cycle but WRONG ORDERING
    var validator = new TopologicalOrderingValidator();

    var tableA = CreateTable("A", "OSUSR_A");
    var tableB = CreateTable("B", "OSUSR_B");

    // WRONG ORDER: Child before parent (even though cycle is allowed)
    var tables = ImmutableArray.Create(tableB, tableA); // B depends on A

    var model = CreateModelWithCycle("A" <-> "B");

    // Act
    var result = validator.Validate(tables, model);

    // Assert - Should still detect ordering violation
    Assert.False(result.IsValid);
    Assert.Single(result.Violations);
    Assert.Equal("ChildBeforeParent", result.Violations[0].ViolationType);

    // Note: Cycle allowance doesn't exempt from correct ordering within the cycle!
}
```

---

### Category 5: Performance & Scale Tests

**Goal**: Ensure cycle detection performs well on large datasets

#### Test 5.1: Large Dataset (1000 entities, no cycles)

```csharp
[Fact]
public void DetectCircularDependency_LargeDataset_CompletesQuickly()
{
    // Arrange: 1000 entities in a linear chain (no cycles)
    var validator = new CircularDependencyDetector();
    var tables = CreateLinearChain(entityCount: 1000); // E0 â†’ E1 â†’ E2 â†’ ... â†’ E999
    var model = CreateLinearModel(1000);

    // Act
    var stopwatch = Stopwatch.StartNew();
    var result = validator.DetectCycles(tables, model);
    stopwatch.Stop();

    // Assert
    Assert.False(result.HasCycles);
    Assert.True(stopwatch.ElapsedMilliseconds < 500,
                $"Cycle detection took {stopwatch.ElapsedMilliseconds}ms (expected < 500ms)");
}
```

#### Test 5.2: Multiple Small Cycles in Large Dataset

```csharp
[Fact]
public void DetectCircularDependency_MultipleCyclesInLargeDataset_FindsAll()
{
    // Arrange: 100 independent 2-way cycles (200 entities total)
    var validator = new CircularDependencyDetector();
    var tables = CreateMultipleIndependentCycles(cycleCount: 100, entitiesPerCycle: 2);
    var model = CreateModelWithCycles(100);

    // Act
    var stopwatch = Stopwatch.StartNew();
    var result = validator.DetectCycles(tables, model);
    stopwatch.Stop();

    // Assert
    Assert.True(result.HasCycles);
    Assert.Equal(100, result.Cycles.Length); // All cycles found
    Assert.True(stopwatch.ElapsedMilliseconds < 1000,
                $"Cycle detection took {stopwatch.ElapsedMilliseconds}ms (expected < 1s)");
}
```

#### Test 5.3: Deep Cycle (100 entities in single cycle)

```csharp
[Fact]
public void DetectCircularDependency_DeepCycle_DetectsEvenVeryLongCycles()
{
    // Arrange: Single cycle with 100 entities: A â†’ B â†’ C â†’ ... â†’ ZZ â†’ A
    var validator = new CircularDependencyDetector();
    var tables = CreateDeepCycle(entityCount: 100);
    var model = CreateCyclicModel(100);

    // Act
    var result = validator.DetectCycles(tables, model);

    // Assert
    Assert.True(result.HasCycles);
    Assert.Single(result.Cycles);
    Assert.Equal(100, result.Cycles[0].Tables.Length);
    Assert.StartsWith("Entity0 â†’ Entity1 â†’ ", result.Cycles[0].Path);
    Assert.EndsWith(" â†’ Entity99 â†’ Entity0", result.Cycles[0].Path);
}
```

---

### Category 6: Error Messages & User Experience

**Goal**: Ensure error messages are clear, actionable, and helpful

#### Test 6.1: Error Message Readability

```csharp
[Fact]
public void CircularDependencyError_FormattedForOperatorReadability()
{
    // Arrange
    var error = CircularDependencyErrorBuilder.Build(
        cycle: new DetectedCycle(
            Tables: ["OSUSR_USER", "OSUSR_ORGANIZATION"],
            Path: "User â†’ Organization â†’ User",
            ForeignKeys: [
                new FKInfo("FK_USER_ORG", "User", "Organization"),
                new FKInfo("FK_ORG_CREATOR", "Organization", "User")
            ]));

    // Act
    var message = error.FormatForDisplay();

    // Assert
    Assert.Contains("âš ï¸", message); // Warning emoji
    Assert.Contains("User â†’ Organization â†’ User", message); // Path
    Assert.Contains("FK_USER_ORG", message); // FK names
    Assert.Contains("FK_ORG_CREATOR", message);
    Assert.Contains("Recommendation:", message); // Actionable guidance

    // Verify message is NOT a wall of text
    var lines = message.Split('\n');
    Assert.True(lines.Length < 25, "Error message should be concise (< 25 lines)");
}
```

#### Test 6.2: Multiple Cycles - Summary First

```csharp
[Fact]
public void MultipleCyclesError_ShowsSummaryBeforeDetails()
{
    // Arrange
    var errors = CreateMultipleCycleErrors(cycleCount: 5);

    // Act
    var message = CircularDependencyErrorBuilder.BuildSummary(errors);

    // Assert
    var lines = message.Split('\n');

    // First lines should be summary
    Assert.Contains("5 circular dependencies detected", lines[0]);
    Assert.Contains("Cycle 1:", message);
    Assert.Contains("Cycle 2:", message);
    Assert.Contains("Cycle 5:", message);

    // Full details follow summary
    Assert.Contains("Full Details:", message);
}
```

#### Test 6.3: Export Failure Message Links to Documentation

```csharp
[Fact]
public void CircularDependencyFailure_IncludesDocumentationLink()
{
    // Arrange
    var result = CreateCycleDetectionResult(hasCycles: true, allowed: false);

    // Act
    var exportError = result.ToExportError();

    // Assert
    Assert.Contains("https://", exportError.Message); // Documentation URL
    Assert.Contains("circular-dependencies", exportError.Message.ToLower());
    Assert.Contains("For more information", exportError.Message);
}
```

---

### Category 7: Configuration & Extensibility

**Goal**: Support flexible configuration for different operator needs

#### Test 7.1: Load Configuration from JSON File

```csharp
[Fact]
public async Task LoadCircularDependencyConfig_FromJsonFile_ParsesCorrectly()
{
    // Arrange
    var jsonConfig = @"{
      ""allowedCycles"": [
        {
          ""tables"": [""OSUSR_A"", ""OSUSR_B""],
          ""reason"": ""Bidirectional relationship"",
          ""approvedBy"": ""Danny Dyer"",
          ""approvedDate"": ""2025-11-19T00:00:00Z""
        }
      ],
      ""strictMode"": false,
      ""autoAllowSelfReferences"": true
    }";

    var configPath = Path.GetTempFileName();
    await File.WriteAllTextAsync(configPath, jsonConfig);

    // Act
    var config = await CircularDependencyConfigLoader.LoadAsync(configPath);

    // Assert
    Assert.NotNull(config);
    Assert.Single(config.AllowedCycles);
    Assert.False(config.StrictMode);
    Assert.True(config.AutoAllowSelfReferences);

    var allowedCycle = config.AllowedCycles[0];
    Assert.Equal(["OSUSR_A", "OSUSR_B"], allowedCycle.Tables);
    Assert.Equal("Danny Dyer", allowedCycle.ApprovedBy);
}
```

#### Test 7.2: CLI Flag to Enable Strict Mode

```csharp
[Fact]
public async Task FullExportCommand_WithStrictCycleMode_FailsOnAnyCycle()
{
    // Arrange
    var args = new[]
    {
        "full-export",
        "--connection-string", "...",
        "--output", "./output",
        "--strict-circular-dependencies" // NEW FLAG
    };

    var app = CreateCliApp();

    // Act
    var exitCode = await app.RunAsync(args);

    // Assert
    Assert.NotEqual(0, exitCode); // Fails due to cycle

    // Verify error message
    var output = GetConsoleOutput();
    Assert.Contains("Strict mode enabled", output);
    Assert.Contains("Circular dependency detected", output);
    Assert.Contains("Export failed", output);
}
```

#### Test 7.3: Environment Variable Override

```csharp
[Fact]
public async Task CircularDependencyDetector_ReadsEnvironmentVariable()
{
    // Arrange
    Environment.SetEnvironmentVariable("OSM_ALLOW_CIRCULAR_DEPENDENCIES", "true");

    try
    {
        var detector = new CircularDependencyDetector(); // Uses env var
        var cycle = CreateABCycle();

        // Act
        var result = detector.DetectCycles([...], model);

        // Assert
        Assert.Equal(ExportValidationStatus.Warning, result.Status);
        Assert.True(result.AllowExport); // Allowed via env var
    }
    finally
    {
        Environment.SetEnvironmentVariable("OSM_ALLOW_CIRCULAR_DEPENDENCIES", null);
    }
}
```

---

## Implementation Checklist

### Phase 1: Core Cycle Detection (M1.2 - Days 1-3)

- [ ] **Day 1**: Create `CircularDependencyDetector` class
  - [ ] Write failing tests for 2-way cycle detection
  - [ ] Implement basic cycle detection using DFS/Tarjan's algorithm
  - [ ] Make tests pass
  - [ ] Write failing tests for 3-way cycles
  - [ ] Extend implementation to detect arbitrary-length cycles
  - [ ] Make tests pass

- [ ] **Day 2**: Enhanced Diagnostics
  - [ ] Write failing tests for cycle path reporting
  - [ ] Implement `DetectedCycle` model with path tracking
  - [ ] Make tests pass
  - [ ] Write failing tests for FK nullability analysis
  - [ ] Implement FK metadata extraction and analysis
  - [ ] Make tests pass

- [ ] **Day 3**: Self-Reference Handling
  - [ ] Write failing tests for self-reference detection
  - [ ] Implement self-reference allowance logic
  - [ ] Make tests pass
  - [ ] Write failing tests for module cross-boundary detection
  - [ ] Implement module tracking in cycle detection
  - [ ] Make tests pass

### Phase 2: Integration (M1.2 - Days 4-5)

- [ ] **Day 4**: TopologicalOrderingValidator Integration
  - [ ] Write failing integration tests for cycle detection in bootstrap step
  - [ ] Integrate `CircularDependencyDetector` into `BuildSsdtBootstrapSnapshotStep`
  - [ ] Make tests pass
  - [ ] Write failing tests for logging and telemetry
  - [ ] Implement diagnostic logging
  - [ ] Make tests pass

- [ ] **Day 5**: Error Message Quality
  - [ ] Write failing tests for error message formatting
  - [ ] Implement `CircularDependencyErrorBuilder`
  - [ ] Make tests pass
  - [ ] User acceptance testing with real-world cycle examples
  - [ ] Iterate on error message clarity

### Phase 3: Operator Override (M1.3 - Days 6-8)

- [ ] **Day 6**: Configuration Model
  - [ ] Write failing tests for configuration parsing
  - [ ] Implement `CircularDependencyOptions` model
  - [ ] Implement JSON configuration loader
  - [ ] Make tests pass

- [ ] **Day 7**: Allowlist Implementation
  - [ ] Write failing tests for cycle allowlist matching
  - [ ] Implement allowlist checking in detector
  - [ ] Make tests pass
  - [ ] Write failing tests for strict mode
  - [ ] Implement strict mode enforcement
  - [ ] Make tests pass

- [ ] **Day 8**: CLI Integration
  - [ ] Write failing tests for CLI flag handling
  - [ ] Add `--strict-circular-dependencies` flag to CLI
  - [ ] Add `--allow-circular-dependencies` flag
  - [ ] Make tests pass
  - [ ] Create sample configuration files
  - [ ] Documentation updates

### Phase 4: Performance & Polish (Days 9-10)

- [ ] **Day 9**: Performance Testing
  - [ ] Write failing performance tests (large datasets)
  - [ ] Profile cycle detection algorithm
  - [ ] Optimize if needed (memoization, early exit)
  - [ ] Make tests pass with acceptable performance

- [ ] **Day 10**: User Acceptance
  - [ ] Run against user's real dataset
  - [ ] Verify circular dependency is clearly diagnosed
  - [ ] Verify recommendations are actionable
  - [ ] Iterate on UX based on feedback

---

## Success Criteria

### Functional

- âœ… All circular dependencies detected (2-way, 3-way, N-way, self-references)
- âœ… Cycle paths clearly reported with table names and FK names
- âœ… FK nullability and delete rules analyzed and reported
- âœ… Operators can allowlist specific cycles via configuration
- âœ… Strict mode available for zero-tolerance deployments
- âœ… Self-references auto-allowed when FK is nullable

### Quality

- âœ… 100% test coverage for critical paths (cycle detection, allowlist matching)
- âœ… All tests follow TDD principles (red â†’ green â†’ refactor)
- âœ… Error messages reviewed by non-developers for clarity
- âœ… Documentation includes examples for common scenarios

### Performance

- âœ… Cycle detection completes in < 500ms for 1000 entities
- âœ… Multiple cycle detection scales linearly with entity count
- âœ… No memory leaks with large datasets

### User Experience

- âœ… User can understand what cycle was detected
- âœ… User knows which tables are involved
- âœ… User receives actionable recommendations
- âœ… User can override detection when cycle is intentional

---

## Risk Mitigation

### Risk 1: False Positives

**Mitigation**:
- Extensive test coverage for edge cases
- Self-references explicitly excluded from cycles
- Allowlist mechanism for intentional cycles
- Warning mode available (detect but don't fail)

### Risk 2: Performance Degradation

**Mitigation**:
- Tarjan's algorithm (O(V+E) complexity)
- Early exit on first cycle detected (if strict mode)
- Performance tests in CI/CD
- Memoization of expensive lookups

### Risk 3: Unclear Error Messages

**Mitigation**:
- User acceptance testing with real-world examples
- Iterative refinement based on feedback
- Documentation with examples
- Links to troubleshooting guide

---

## Test Execution Strategy

### Unit Tests

- Run on every commit
- Must pass before merge
- Fail-fast on any failure
- Code coverage reported to CI

### Integration Tests

- Run nightly
- Test against real OutSystems database dumps
- Performance metrics tracked over time

### User Acceptance Tests

- Manual testing with user's dataset
- Verify diagnostics are actionable
- Iterate on error message clarity

---

## Appendix: Test Helper Methods

```csharp
// Test fixture builders for common scenarios

private static StaticEntityTableData CreateTableWithFK(
    string logicalName,
    string physicalName,
    string fkTo)
{
    // Creates table with single FK to specified target
}

private static StaticEntityTableData CreateTableWithSelfReference(
    string logicalName,
    string physicalName,
    string fkColumnName,
    bool nullable = true)
{
    // Creates table with self-referencing FK
}

private static OsmModel CreateModelWithCycle(params string[] tablePath)
{
    // Creates model with specified circular dependency path
}

private static DetectedCycle CreateABCycle()
{
    // Standard A â†” B cycle for testing
}
```

---

**End of Test Plan**
