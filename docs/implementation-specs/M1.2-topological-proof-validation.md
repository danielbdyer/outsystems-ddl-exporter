# M1.2: Topological Ordering Validation (MVP)

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION
**Dependencies**: M1.0 (Global Topological Ordering)
**Priority**: ðŸŸ¡ Ship after M1.0+M1.1, before M1.5

## Executive Summary

### The Specific Problem

After M1.0 generates a topologically-sorted bootstrap snapshot, **there is no automated validation that the ordering is actually correct**. The existing `EntityDependencySorter` could have bugs that cause incorrect ordering, leading to:

- **Silent Ordering Errors**: Child entities may appear before parent entities without detection
- **Late Failure**: FK constraint violations only discovered during SSDT deployment, not at generation time
- **No Fail-Fast**: Even when cycles are detected, export continues with fallback ordering (potentially incorrect)
- **Unclear Root Cause**: When FK violations occur, operators can't determine which dependency was violated

**Example**: A bug in cycle detection causes `Order` (child) to appear before `Customer` (parent) in bootstrap snapshot. Deploy to SSDT â†’ FK constraint violation during data load.

### Recommended Solution

**Runtime Topological Ordering Validation**

Add a post-sort validation step that verifies ordering correctness immediately after `EntityDependencySorter` runs:

1. **Position-Based Validation**: For each entity, verify all FK-referenced parents appear earlier in the sort order
2. **Fail-Fast on Violations**: If child-before-parent detected, fail export immediately with actionable error
3. **Diagnostic Logging**: Show which specific FK constraint was violated (table names, positions)
4. **Minimal Overhead**: Single-pass validation without generating proof artifacts

This runs as a quick validation pass (<100ms) during export generation, catching ordering bugs before deployment.

### How It Fixes the Problem

1. **Early Detection**: Catches ordering violations at generation time, not during deployment
2. **Fail-Fast**: Stops export immediately if violations detected, preventing invalid artifacts
3. **Actionable Errors**: Shows specific FK causing violation (e.g., "Order at position 5 references Customer at position 10")
4. **Confidence**: Proves bootstrap snapshot ordering is correct before deployment

### Alternative Approaches Considered

**Alternative 1: No Validation (Trust EntityDependencySorter)**
- Assume sorter is always correct, skip validation
- **Rejected**: Risky (bugs can occur), doesn't catch data inconsistencies, silent failures possible

**Alternative 2: Full Proof Generation (M1.7)**
- Generate complete topological proof with dependency graph
- **Rejected**: Too slow for MVP (file generation overhead), overkill for basic validation

**Alternative 3: SSDT Build-Time Validation**
- Let SSDT deployment detect FK violations
- **Rejected**: Fails too late, cryptic errors, wastes deployment time

**Alternative 4: Test Database Execution**
- Apply bootstrap to test database, catch FK violations there
- **Rejected**: Too slow (requires database setup), that's M1.8's domain

**Why Runtime Validation Wins**: Fast (<100ms), catches bugs early, actionable errors, no external dependencies, minimal code changes.

**MVP Scope**:
1. âœ… Validate no child-before-parent violations in bootstrap snapshot
2. âœ… Log warnings for detected cycles or missing FK edges
3. âœ… Add basic dependency count to execution log
4. âŒ NOT creating proof artifacts (deferred to M1.7)
5. âŒ NOT generating visualization reports (deferred to M1.7)

**Key Difference from M1.7**:
- M1.2 = **Runtime validation** during export (fail-fast, operator feedback)
- M1.7 = **Proof artifacts** after export (documentation, auditing, visualization)

---

## Problem Statement

### Current State (After M1.0)

M1.0 generates bootstrap snapshot with topological ordering, but:
- No validation that ordering is actually correct
- If `EntityDependencySorter` has a bug, FK violations occur silently
- Operators discover issues only during SSDT deployment (too late)
- Cycle detection logs a warning but doesn't fail the export

### Desired State (M1.2 MVP)

- **Validate ordering post-sort**: After `EntityDependencySorter` runs, verify no child appears before parent
- **Fail-fast on violations**: If validation detects child-before-parent, fail export immediately
- **Log actionable diagnostics**: Show which FK dependency was violated
- **Minimal overhead**: Single-pass validation, no file generation

---

## Architecture

### Component Overview

```
BuildSsdtBootstrapSnapshotStep (M1.0)
  â†“ calls
EntityDependencySorter.SortByForeignKeys()
  â†“ returns
EntityDependencySortResult { Tables, TopologicalOrderingApplied, ... }
  â†“ passed to (NEW)
TopologicalOrderingValidator.Validate()
  â†“ verifies
  - No child-before-parent violations
  - Cycles logged as warnings
  - Missing edges logged
  â†“ returns
ValidationResult { IsValid, Violations }
  â†“ if invalid
  FAIL export with actionable error message
```

### Data Models

#### ValidationResult

```csharp
public sealed record TopologicalValidationResult(
    bool IsValid,
    ImmutableArray<OrderingViolation> Violations,
    int TotalEntities,
    int TotalForeignKeys,
    int MissingEdges,
    bool CycleDetected);

public sealed record OrderingViolation(
    string ChildTable,
    string ParentTable,
    string ForeignKeyName,
    int ChildPosition,
    int ParentPosition,
    string ViolationType); // "ChildBeforeParent", "MissingParent", "Cycle"
```

---

## Implementation Details

### 1. Create TopologicalOrderingValidator

**File**: `src/Osm.Pipeline/Orchestration/TopologicalOrderingValidator.cs`

```csharp
using System.Collections.Immutable;
using Osm.Domain.Abstractions;
using Osm.Emission.Seeds;

namespace Osm.Pipeline.Orchestration;

public sealed class TopologicalOrderingValidator
{
    public TopologicalValidationResult Validate(
        ImmutableArray<StaticEntityTableData> orderedTables,
        FilteredOsmModel model,
        NamingOverrideOptions namingOverrides)
    {
        if (orderedTables.IsDefaultOrEmpty)
        {
            return new TopologicalValidationResult(
                IsValid: true,
                Violations: ImmutableArray<OrderingViolation>.Empty,
                TotalEntities: 0,
                TotalForeignKeys: 0,
                MissingEdges: 0,
                CycleDetected: false);
        }

        // Build position lookup: TableName -> Index
        var positions = orderedTables
            .Select((table, index) => (table.Definition.PhysicalName, Index: index))
            .ToDictionary(x => x.PhysicalName, x => x.Index, StringComparer.OrdinalIgnoreCase);

        var violations = ImmutableArray.CreateBuilder<OrderingViolation>();
        var totalFks = 0;
        var missingEdges = 0;

        // For each table, verify all FK parents appear BEFORE it
        foreach (var (table, childIndex) in orderedTables.Select((t, i) => (t, i)))
        {
            var entity = model.TryGetEntityByPhysicalName(table.Definition.PhysicalName);
            if (entity is null)
            {
                continue;
            }

            foreach (var relationship in entity.Relationships)
            {
                if (!relationship.IsForeignKey || relationship.TargetEntity is null)
                {
                    continue;
                }

                totalFks++;

                var parentPhysicalName = relationship.TargetEntity.PhysicalTableName;
                if (!positions.TryGetValue(parentPhysicalName, out var parentIndex))
                {
                    // Parent not in sorted list (excluded entity)
                    missingEdges++;
                    violations.Add(new OrderingViolation(
                        ChildTable: table.Definition.PhysicalName,
                        ParentTable: parentPhysicalName,
                        ForeignKeyName: relationship.Name ?? "<unnamed>",
                        ChildPosition: childIndex,
                        ParentPosition: -1,
                        ViolationType: "MissingParent"));
                    continue;
                }

                // CRITICAL: Parent must appear BEFORE child
                if (parentIndex >= childIndex)
                {
                    violations.Add(new OrderingViolation(
                        ChildTable: table.Definition.PhysicalName,
                        ParentTable: parentPhysicalName,
                        ForeignKeyName: relationship.Name ?? "<unnamed>",
                        ChildPosition: childIndex,
                        ParentPosition: parentIndex,
                        ViolationType: "ChildBeforeParent"));
                }
            }
        }

        var cycleDetected = violations.Any(v => v.ViolationType == "ChildBeforeParent");

        return new TopologicalValidationResult(
            IsValid: violations.Count == 0 || violations.All(v => v.ViolationType == "MissingParent"),
            Violations: violations.ToImmutable(),
            TotalEntities: orderedTables.Length,
            TotalForeignKeys: totalFks,
            MissingEdges: missingEdges,
            CycleDetected: cycleDetected);
    }
}
```

### 2. Integrate into BuildSsdtBootstrapSnapshotStep

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtBootstrapSnapshotStep.cs`

```csharp
// After EntityDependencySorter.SortByForeignKeys() call:
var sortResult = EntityDependencySorter.SortByForeignKeys(
    allEntities,
    state.Bootstrap.FilteredModel,
    namingOverrides,
    sortOptions);

// NEW: Validate ordering
var validator = new TopologicalOrderingValidator();
var validationResult = validator.Validate(
    sortResult.Tables,
    state.Bootstrap.FilteredModel,
    namingOverrides);

// Log validation results
state.Log.Record(
    "bootstrap.ordering.validated",
    $"Topological ordering validation: {validationResult.TotalEntities} entities, {validationResult.TotalForeignKeys} FKs",
    new PipelineLogMetadataBuilder()
        .WithCount("entities", validationResult.TotalEntities)
        .WithCount("foreignKeys", validationResult.TotalForeignKeys)
        .WithCount("violations", validationResult.Violations.Length)
        .WithCount("missingEdges", validationResult.MissingEdges)
        .WithValue("isValid", validationResult.IsValid ? "true" : "false")
        .WithValue("cycleDetected", validationResult.CycleDetected ? "true" : "false")
        .Build());

// Fail-fast if child-before-parent violations detected
if (!validationResult.IsValid)
{
    var errorMessage = BuildValidationErrorMessage(validationResult);
    state.Log.Record(
        "bootstrap.ordering.validationFailed",
        errorMessage);

    return Result<BootstrapSnapshotGenerated>.Failure(
        new PipelineError(
            "TopologicalOrderingValidationFailed",
            errorMessage,
            severity: PipelineErrorSeverity.Error));
}

// Log warnings for missing edges (excluded entities)
if (validationResult.MissingEdges > 0)
{
    state.Log.Record(
        "bootstrap.ordering.missingEdges",
        $"Detected {validationResult.MissingEdges} FK(s) to entities not included in export. This is expected for system tables or excluded modules.",
        new PipelineLogMetadataBuilder()
            .WithCount("missingEdges", validationResult.MissingEdges)
            .Build());
}
```

### 3. Error Message Builder

```csharp
private static string BuildValidationErrorMessage(TopologicalValidationResult validation)
{
    var sb = new StringBuilder();
    sb.AppendLine("Topological ordering validation FAILED:");
    sb.AppendLine();
    sb.AppendLine($"  Total Entities: {validation.TotalEntities}");
    sb.AppendLine($"  Total Foreign Keys: {validation.TotalForeignKeys}");
    sb.AppendLine($"  Violations: {validation.Violations.Length}");
    sb.AppendLine();

    if (validation.CycleDetected)
    {
        sb.AppendLine("  ðŸ”´ CYCLE DETECTED: Circular FK dependencies prevent correct ordering");
        sb.AppendLine();
    }

    sb.AppendLine("  Ordering Violations:");
    foreach (var violation in validation.Violations.Take(10)) // Show first 10
    {
        if (violation.ViolationType == "ChildBeforeParent")
        {
            sb.AppendLine($"    - [{violation.ChildTable}] (pos {violation.ChildPosition}) has FK to [{violation.ParentTable}] (pos {violation.ParentPosition})");
            sb.AppendLine($"      FK: {violation.ForeignKeyName}");
            sb.AppendLine($"      âŒ Child appears BEFORE parent (violation)");
        }
    }

    if (validation.Violations.Length > 10)
    {
        sb.AppendLine($"    ... and {validation.Violations.Length - 10} more violations");
    }

    sb.AppendLine();
    sb.AppendLine("  This indicates a bug in EntityDependencySorter or a genuine cycle in FK relationships.");
    sb.AppendLine("  Please report this issue with the full export log.");

    return sb.ToString();
}
```

---

## Integration Points

### M1.0 Bootstrap Generation
- Runs AFTER `EntityDependencySorter.SortByForeignKeys()`
- Validates sorted order before generating MERGE scripts
- Fails export if violations detected

### M1.1 Export Verification
- Validation results logged to `PipelineExecutionLogBuilder`
- Metrics included in manifest metadata

### M1.7 Topological Proof (Future)
- M1.7 can reuse `TopologicalOrderingValidator` for detailed proof generation
- M1.2 validation is subset of M1.7's capabilities

---

## Test Scenarios

### Test 1: Valid Topological Order
```csharp
[Fact]
public void Validate_ValidOrder_ReturnsSuccess()
{
    // Arrange: Parent at index 0, Child at index 1
    var parent = CreateTable("Parent");
    var child = CreateTableWithFkTo("Child", "Parent");
    var ordered = ImmutableArray.Create(parent, child);

    // Act
    var result = validator.Validate(ordered, model, namingOverrides);

    // Assert
    Assert.True(result.IsValid);
    Assert.Empty(result.Violations);
}
```

### Test 2: Child Before Parent (Violation)
```csharp
[Fact]
public void Validate_ChildBeforeParent_ReturnsFailure()
{
    // Arrange: Child at index 0, Parent at index 1 (WRONG)
    var child = CreateTableWithFkTo("Child", "Parent");
    var parent = CreateTable("Parent");
    var ordered = ImmutableArray.Create(child, parent);

    // Act
    var result = validator.Validate(ordered, model, namingOverrides);

    // Assert
    Assert.False(result.IsValid);
    Assert.Single(result.Violations);
    Assert.Equal("ChildBeforeParent", result.Violations[0].ViolationType);
}
```

### Test 3: Missing Parent (Excluded Entity)
```csharp
[Fact]
public void Validate_MissingParent_LogsWarning()
{
    // Arrange: Child references Parent, but Parent not in export
    var child = CreateTableWithFkTo("Child", "ExcludedParent");
    var ordered = ImmutableArray.Create(child);

    // Act
    var result = validator.Validate(ordered, model, namingOverrides);

    // Assert
    Assert.True(result.IsValid); // Missing edges are warnings, not errors
    Assert.Single(result.Violations);
    Assert.Equal("MissingParent", result.Violations[0].ViolationType);
    Assert.Equal(1, result.MissingEdges);
}
```

---

## Success Criteria

1. âœ… Validation runs after every `EntityDependencySorter.SortByForeignKeys()` call
2. âœ… Child-before-parent violations fail the export immediately
3. âœ… Missing edges (excluded entities) logged as warnings, not errors
4. âœ… Validation metrics logged to execution log
5. âœ… Operators see actionable error message on violation
6. âœ… All existing tests pass
7. âœ… New validation tests cover valid order, violations, missing edges

---

## Migration Path

**M1.2 is purely additive**:
- No changes to `EntityDependencySorter` (still works the same)
- Validation happens after sort, before file generation
- No breaking changes to existing exports
- If validation passes (expected), behavior unchanged

**Future M1.7 Enhancement**:
- M1.7 extends M1.2 validator to generate proof artifacts
- Same validation logic, different output format
- M1.2 = fail-fast runtime check
- M1.7 = comprehensive proof documentation

---

## Summary

**M1.2 MVP provides essential safety**:
1. Catches ordering bugs immediately during export
2. Prevents FK violations from reaching SSDT deployment
3. Minimal overhead (single validation pass)
4. Actionable operator feedback

**Deferred to M1.7** (nice-to-have):
- JSON proof artifacts
- Human-readable reports
- Dependency graph visualization
- Cycle analysis and recommendations
