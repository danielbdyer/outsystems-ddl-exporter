# M1.2: Topological Ordering Validation (MVP)

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION
**Dependencies**: M1.0 (Global Topological Ordering)
**Priority**: üü° Ship after M1.0+M1.1, before M1.5

## Executive Summary

This specification defines **minimal validation** to verify topological ordering correctness during bootstrap snapshot generation. Unlike M1.7 (full observability), M1.2 focuses on catching critical ordering errors with minimal overhead.

**MVP Scope**:
1. ‚úÖ Validate no child-before-parent violations in bootstrap snapshot
2. ‚úÖ Log warnings for detected cycles or missing FK edges
3. ‚úÖ Add basic dependency count to execution log
4. ‚ùå NOT creating proof artifacts (deferred to M1.7)
5. ‚ùå NOT generating visualization reports (deferred to M1.7)

**Key Difference from M1.7**:
- M1.2 = **Runtime validation** during export (fail-fast, operator feedback)
- M1.7 = **Proof artifacts** after export (documentation, auditing, visualization)

---

## Problem Statement

### Current State (After M1.0)

M1.0 generates bootstrap snapshot with topological ordering, but:
- No validation that ordering is actually correct
- If `EntityDependencySorter` has a bug, FK violations occur silently
- Operators discover issues only during SSDT deployment (too late)
- Cycle detection logs a warning but doesn't fail the export

### Desired State (M1.2 MVP)

- **Validate ordering post-sort**: After `EntityDependencySorter` runs, verify no child appears before parent
- **Fail-fast on violations**: If validation detects child-before-parent, fail export immediately
- **Log actionable diagnostics**: Show which FK dependency was violated
- **Minimal overhead**: Single-pass validation, no file generation

---

## Architecture

### Component Overview

```
BuildSsdtBootstrapSnapshotStep (M1.0)
  ‚Üì calls
EntityDependencySorter.SortByForeignKeys()
  ‚Üì returns
EntityDependencySortResult { Tables, TopologicalOrderingApplied, ... }
  ‚Üì passed to (NEW)
TopologicalOrderingValidator.Validate()
  ‚Üì verifies
  - No child-before-parent violations
  - Cycles logged as warnings
  - Missing edges logged
  ‚Üì returns
ValidationResult { IsValid, Violations }
  ‚Üì if invalid
  FAIL export with actionable error message
```

### Data Models

#### ValidationResult

```csharp
public sealed record TopologicalValidationResult(
    bool IsValid,
    ImmutableArray<OrderingViolation> Violations,
    int TotalEntities,
    int TotalForeignKeys,
    int MissingEdges,
    bool CycleDetected);

public sealed record OrderingViolation(
    string ChildTable,
    string ParentTable,
    string ForeignKeyName,
    int ChildPosition,
    int ParentPosition,
    string ViolationType); // "ChildBeforeParent", "MissingParent", "Cycle"
```

---

## Implementation Details

### 1. Create TopologicalOrderingValidator

**File**: `src/Osm.Pipeline/Orchestration/TopologicalOrderingValidator.cs`

```csharp
using System.Collections.Immutable;
using Osm.Domain.Abstractions;
using Osm.Emission.Seeds;

namespace Osm.Pipeline.Orchestration;

public sealed class TopologicalOrderingValidator
{
    public TopologicalValidationResult Validate(
        ImmutableArray<StaticEntityTableData> orderedTables,
        FilteredOsmModel model,
        NamingOverrideOptions namingOverrides)
    {
        if (orderedTables.IsDefaultOrEmpty)
        {
            return new TopologicalValidationResult(
                IsValid: true,
                Violations: ImmutableArray<OrderingViolation>.Empty,
                TotalEntities: 0,
                TotalForeignKeys: 0,
                MissingEdges: 0,
                CycleDetected: false);
        }

        // Build position lookup: TableName -> Index
        var positions = orderedTables
            .Select((table, index) => (table.Definition.PhysicalName, Index: index))
            .ToDictionary(x => x.PhysicalName, x => x.Index, StringComparer.OrdinalIgnoreCase);

        var violations = ImmutableArray.CreateBuilder<OrderingViolation>();
        var totalFks = 0;
        var missingEdges = 0;

        // For each table, verify all FK parents appear BEFORE it
        foreach (var (table, childIndex) in orderedTables.Select((t, i) => (t, i)))
        {
            var entity = model.TryGetEntityByPhysicalName(table.Definition.PhysicalName);
            if (entity is null)
            {
                continue;
            }

            foreach (var relationship in entity.Relationships)
            {
                if (!relationship.IsForeignKey || relationship.TargetEntity is null)
                {
                    continue;
                }

                totalFks++;

                var parentPhysicalName = relationship.TargetEntity.PhysicalTableName;
                if (!positions.TryGetValue(parentPhysicalName, out var parentIndex))
                {
                    // Parent not in sorted list (excluded entity)
                    missingEdges++;
                    violations.Add(new OrderingViolation(
                        ChildTable: table.Definition.PhysicalName,
                        ParentTable: parentPhysicalName,
                        ForeignKeyName: relationship.Name ?? "<unnamed>",
                        ChildPosition: childIndex,
                        ParentPosition: -1,
                        ViolationType: "MissingParent"));
                    continue;
                }

                // CRITICAL: Parent must appear BEFORE child
                if (parentIndex >= childIndex)
                {
                    violations.Add(new OrderingViolation(
                        ChildTable: table.Definition.PhysicalName,
                        ParentTable: parentPhysicalName,
                        ForeignKeyName: relationship.Name ?? "<unnamed>",
                        ChildPosition: childIndex,
                        ParentPosition: parentIndex,
                        ViolationType: "ChildBeforeParent"));
                }
            }
        }

        var cycleDetected = violations.Any(v => v.ViolationType == "ChildBeforeParent");

        return new TopologicalValidationResult(
            IsValid: violations.Count == 0 || violations.All(v => v.ViolationType == "MissingParent"),
            Violations: violations.ToImmutable(),
            TotalEntities: orderedTables.Length,
            TotalForeignKeys: totalFks,
            MissingEdges: missingEdges,
            CycleDetected: cycleDetected);
    }
}
```

### 2. Integrate into BuildSsdtBootstrapSnapshotStep

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtBootstrapSnapshotStep.cs`

```csharp
// After EntityDependencySorter.SortByForeignKeys() call:
var sortResult = EntityDependencySorter.SortByForeignKeys(
    allEntities,
    state.Bootstrap.FilteredModel,
    namingOverrides,
    sortOptions);

// NEW: Validate ordering
var validator = new TopologicalOrderingValidator();
var validationResult = validator.Validate(
    sortResult.Tables,
    state.Bootstrap.FilteredModel,
    namingOverrides);

// Log validation results
state.Log.Record(
    "bootstrap.ordering.validated",
    $"Topological ordering validation: {validationResult.TotalEntities} entities, {validationResult.TotalForeignKeys} FKs",
    new PipelineLogMetadataBuilder()
        .WithCount("entities", validationResult.TotalEntities)
        .WithCount("foreignKeys", validationResult.TotalForeignKeys)
        .WithCount("violations", validationResult.Violations.Length)
        .WithCount("missingEdges", validationResult.MissingEdges)
        .WithValue("isValid", validationResult.IsValid ? "true" : "false")
        .WithValue("cycleDetected", validationResult.CycleDetected ? "true" : "false")
        .Build());

// Fail-fast if child-before-parent violations detected
if (!validationResult.IsValid)
{
    var errorMessage = BuildValidationErrorMessage(validationResult);
    state.Log.Record(
        "bootstrap.ordering.validationFailed",
        errorMessage);

    return Result<BootstrapSnapshotGenerated>.Failure(
        new PipelineError(
            "TopologicalOrderingValidationFailed",
            errorMessage,
            severity: PipelineErrorSeverity.Error));
}

// Log warnings for missing edges (excluded entities)
if (validationResult.MissingEdges > 0)
{
    state.Log.Record(
        "bootstrap.ordering.missingEdges",
        $"Detected {validationResult.MissingEdges} FK(s) to entities not included in export. This is expected for system tables or excluded modules.",
        new PipelineLogMetadataBuilder()
            .WithCount("missingEdges", validationResult.MissingEdges)
            .Build());
}
```

### 3. Error Message Builder

```csharp
private static string BuildValidationErrorMessage(TopologicalValidationResult validation)
{
    var sb = new StringBuilder();
    sb.AppendLine("Topological ordering validation FAILED:");
    sb.AppendLine();
    sb.AppendLine($"  Total Entities: {validation.TotalEntities}");
    sb.AppendLine($"  Total Foreign Keys: {validation.TotalForeignKeys}");
    sb.AppendLine($"  Violations: {validation.Violations.Length}");
    sb.AppendLine();

    if (validation.CycleDetected)
    {
        sb.AppendLine("  üî¥ CYCLE DETECTED: Circular FK dependencies prevent correct ordering");
        sb.AppendLine();
    }

    sb.AppendLine("  Ordering Violations:");
    foreach (var violation in validation.Violations.Take(10)) // Show first 10
    {
        if (violation.ViolationType == "ChildBeforeParent")
        {
            sb.AppendLine($"    - [{violation.ChildTable}] (pos {violation.ChildPosition}) has FK to [{violation.ParentTable}] (pos {violation.ParentPosition})");
            sb.AppendLine($"      FK: {violation.ForeignKeyName}");
            sb.AppendLine($"      ‚ùå Child appears BEFORE parent (violation)");
        }
    }

    if (validation.Violations.Length > 10)
    {
        sb.AppendLine($"    ... and {validation.Violations.Length - 10} more violations");
    }

    sb.AppendLine();
    sb.AppendLine("  This indicates a bug in EntityDependencySorter or a genuine cycle in FK relationships.");
    sb.AppendLine("  Please report this issue with the full export log.");

    return sb.ToString();
}
```

---

## Integration Points

### M1.0 Bootstrap Generation
- Runs AFTER `EntityDependencySorter.SortByForeignKeys()`
- Validates sorted order before generating MERGE scripts
- Fails export if violations detected

### M1.1 Export Verification
- Validation results logged to `PipelineExecutionLogBuilder`
- Metrics included in manifest metadata

### M1.7 Topological Proof (Future)
- M1.7 can reuse `TopologicalOrderingValidator` for detailed proof generation
- M1.2 validation is subset of M1.7's capabilities

---

## Test Scenarios

### Test 1: Valid Topological Order
```csharp
[Fact]
public void Validate_ValidOrder_ReturnsSuccess()
{
    // Arrange: Parent at index 0, Child at index 1
    var parent = CreateTable("Parent");
    var child = CreateTableWithFkTo("Child", "Parent");
    var ordered = ImmutableArray.Create(parent, child);

    // Act
    var result = validator.Validate(ordered, model, namingOverrides);

    // Assert
    Assert.True(result.IsValid);
    Assert.Empty(result.Violations);
}
```

### Test 2: Child Before Parent (Violation)
```csharp
[Fact]
public void Validate_ChildBeforeParent_ReturnsFailure()
{
    // Arrange: Child at index 0, Parent at index 1 (WRONG)
    var child = CreateTableWithFkTo("Child", "Parent");
    var parent = CreateTable("Parent");
    var ordered = ImmutableArray.Create(child, parent);

    // Act
    var result = validator.Validate(ordered, model, namingOverrides);

    // Assert
    Assert.False(result.IsValid);
    Assert.Single(result.Violations);
    Assert.Equal("ChildBeforeParent", result.Violations[0].ViolationType);
}
```

### Test 3: Missing Parent (Excluded Entity)
```csharp
[Fact]
public void Validate_MissingParent_LogsWarning()
{
    // Arrange: Child references Parent, but Parent not in export
    var child = CreateTableWithFkTo("Child", "ExcludedParent");
    var ordered = ImmutableArray.Create(child);

    // Act
    var result = validator.Validate(ordered, model, namingOverrides);

    // Assert
    Assert.True(result.IsValid); // Missing edges are warnings, not errors
    Assert.Single(result.Violations);
    Assert.Equal("MissingParent", result.Violations[0].ViolationType);
    Assert.Equal(1, result.MissingEdges);
}
```

---

## Success Criteria

1. ‚úÖ Validation runs after every `EntityDependencySorter.SortByForeignKeys()` call
2. ‚úÖ Child-before-parent violations fail the export immediately
3. ‚úÖ Missing edges (excluded entities) logged as warnings, not errors
4. ‚úÖ Validation metrics logged to execution log
5. ‚úÖ Operators see actionable error message on violation
6. ‚úÖ All existing tests pass
7. ‚úÖ New validation tests cover valid order, violations, missing edges

---

## Migration Path

**M1.2 is purely additive**:
- No changes to `EntityDependencySorter` (still works the same)
- Validation happens after sort, before file generation
- No breaking changes to existing exports
- If validation passes (expected), behavior unchanged

**Future M1.7 Enhancement**:
- M1.7 extends M1.2 validator to generate proof artifacts
- Same validation logic, different output format
- M1.2 = fail-fast runtime check
- M1.7 = comprehensive proof documentation

---

## Summary

**M1.2 MVP provides essential safety**:
1. Catches ordering bugs immediately during export
2. Prevents FK violations from reaching SSDT deployment
3. Minimal overhead (single validation pass)
4. Actionable operator feedback

**Deferred to M1.7** (nice-to-have):
- JSON proof artifacts
- Human-readable reports
- Dependency graph visualization
- Cycle analysis and recommendations
