# M2.5: INSERT Transformation Verification

**Status**: READY FOR IMPLEMENTATION (after M2.4 ships)
**Dependencies**: M2.1 (UAT-Users Verification Framework), M2.4 (INSERT Transformation Implementation)
**Priority**: ðŸŸ¡ Enhanced Verification (ship after M2.4 adoption)
**Scope**: Automated verification that generated INSERT scripts contain correct transformations

---

## Executive Summary

### Problem Statement

M2.4 implements INSERT transformation (pre-transformed INSERTs during full-export), but there's **no automated verification that transformations were correctly applied**.

**Current Gap After M2.4**:
- INSERTs generated with transformation context passed to DynamicEntityInsertGenerator
- No programmatic proof that orphan IDs were transformed to target IDs
- Manual SQL inspection required to verify correctness
- Risk of transformation bugs going undetected (e.g., wrong column transformed, type mismatch)

**Risk**: Silent bugs where transformation context is present but not applied correctly (e.g., column name mismatch, type conversion error).

### Solution Approach

Build an **INSERT verification layer** that:
- **Parses generated INSERT scripts** to extract VALUES literals
- **Verifies orphan elimination** (no orphan user IDs in generated INSERTs)
- **Validates transformation correctness** (transformed IDs match user map exactly)
- **Verifies NULL preservation** (NULLs not transformed)
- **Emits INSERT verification report** (JSON) for audit trails

**This extends M2.1 artifact verification with INSERT transformation correctness proof.**

### Scope (M2.5)

**Ship This**:
- âœ… INSERT script parser (extracts VALUES from SQL scripts using TSql150Parser)
- âœ… Orphan detector (verifies no orphan IDs remain in INSERTs)
- âœ… Transformation validator (all transformations match user map)
- âœ… NULL preservation verifier (NULLs preserved in user FK columns)
- âœ… INSERT verification report generator (JSON output)

**Out of Scope**:
- Cross-mode validation (INSERT vs UPDATE equivalence - see M2.6)
- Live database verification (deferred to M3.2)
- UPDATE script verification (covered in M2.2)

---

## Critical Path Analysis

### Why This Matters

**Without INSERT verification**:
- Transformation bugs go undetected until UAT deployment
- Column name mismatches cause silent transformation failures
- Type conversion bugs may cause SQL errors or wrong values
- No audit proof that INSERTs are UAT-ready

**With INSERT verification**:
- Catch transformation bugs before deployment
- Prove no orphan IDs remain in generated scripts
- Audit trail showing exact transformations applied
- CI/CD can gate deployments on transformation correctness

### Dependencies and Parallelization

**Depends On**:
- M2.1 (verification framework, report patterns)
- M2.4 (INSERT transformation implementation)

**Enables**:
- M2.6 (cross-mode validation - INSERT vs UPDATE equivalence)
- M3.2 (load harness with live verification)

**Can Parallel With**:
- M2.2 (UPDATE verification - different domain)
- M2.3 (integration tests)

---

## Architecture

### Component Overview

```
Generated INSERT Scripts
  â†“ parse
TSql150Parser (SQL DOM)
  â†“ extract
VALUES Literals
  â†“ analyze
InsertTransformationVerifier
  â†“ performs
  1. Orphan detection (verify no orphans in INSERTs)
  2. Transformation validation (all transformations match map)
  3. NULL preservation (NULLs not transformed)
  â†“ outputs
InsertVerificationReport (JSON)
```

### Data Models

#### InsertVerificationReport

```csharp
public sealed record InsertVerificationReport(
    bool Passed,
    DateTimeOffset VerifiedAtUtc,
    int TablesVerified,
    int ColumnsVerified,
    long ValuesInspected,
    int TransformationsVerified,
    ImmutableArray<InsertVerificationResult> TableResults,
    ImmutableArray<InsertVerificationWarning> Warnings);

public sealed record InsertVerificationResult(
    string Schema,
    string TableName,
    string ColumnName,
    bool IsUserFkColumn,
    int ValuesInspected,
    int OrphanIdsFound, // Should be 0 if transformations applied correctly
    int TargetIdsFound, // Should match expected transformation count
    int NullsFound,
    ImmutableArray<UserIdentifier> OrphanIds); // Empty if verification passes

public sealed record InsertVerificationWarning(
    string Schema,
    string TableName,
    string ColumnName,
    string WarningType, // "OrphanDetected", "NullTransformed", "UnexpectedValue"
    UserIdentifier? OrphanId,
    string Message);
```

---

## Implementation Details

### 1. Create InsertScriptParser

**File**: `src/Osm.Pipeline/UatUsers/Verification/InsertScriptParser.cs`

**Purpose**: Parse INSERT scripts to extract VALUES literals per column

```csharp
using Microsoft.SqlServer.TransactSql.ScriptDom;
using System.Collections.Immutable;

namespace Osm.Pipeline.UatUsers.Verification;

public sealed class InsertScriptParser
{
    private readonly TSql150Parser _parser;

    public InsertScriptParser()
    {
        _parser = new TSql150Parser(initialQuotedIdentifiers: true);
    }

    public Result<ParsedInsertScript> ParseScript(string scriptContent, string scriptPath)
    {
        using var reader = new StringReader(scriptContent);
        var fragment = _parser.Parse(reader, out var errors);

        if (errors.Any())
        {
            return Result<ParsedInsertScript>.Failure(
                ValidationError.Create($"SQL parse errors in {scriptPath}: {string.Join(", ", errors.Select(e => e.Message))}"));
        }

        var insertStatements = ExtractInsertStatements(fragment);
        var valuesByColumn = ExtractValuesByColumn(insertStatements);

        return Result<ParsedInsertScript>.Success(new ParsedInsertScript(
            ScriptPath: scriptPath,
            InsertStatementCount: insertStatements.Count,
            ValuesByColumn: valuesByColumn));
    }

    private ImmutableArray<InsertStatement> ExtractInsertStatements(TSqlFragment fragment)
    {
        var visitor = new InsertStatementVisitor();
        fragment.Accept(visitor);
        return visitor.InsertStatements.ToImmutableArray();
    }

    private ImmutableDictionary<ColumnIdentifier, ImmutableArray<string>> ExtractValuesByColumn(
        ImmutableArray<InsertStatement> insertStatements)
    {
        var valuesByColumn = new Dictionary<ColumnIdentifier, List<string>>();

        foreach (var insert in insertStatements)
        {
            var tableName = GetTableName(insert.InsertSpecification.Target);
            var columns = GetColumnNames(insert.InsertSpecification);
            var valuesSource = insert.InsertSpecification.InsertSource as ValuesInsertSource;

            if (valuesSource == null) continue;

            foreach (var rowValues in valuesSource.RowValues)
            {
                for (var i = 0; i < columns.Length && i < rowValues.ColumnValues.Count; i++)
                {
                    var columnId = new ColumnIdentifier(tableName, columns[i]);
                    var literal = ExtractLiteral(rowValues.ColumnValues[i]);

                    if (!valuesByColumn.ContainsKey(columnId))
                        valuesByColumn[columnId] = new List<string>();

                    valuesByColumn[columnId].Add(literal);
                }
            }
        }

        return valuesByColumn.ToImmutableDictionary(
            kvp => kvp.Key,
            kvp => kvp.Value.ToImmutableArray());
    }

    private string ExtractLiteral(ScalarExpression expression)
    {
        return expression switch
        {
            IntegerLiteral intLit => intLit.Value,
            StringLiteral strLit => strLit.Value,
            NumericLiteral numLit => numLit.Value,
            NullLiteral => "NULL",
            _ => expression.ToString()
        };
    }
}

public sealed record ParsedInsertScript(
    string ScriptPath,
    int InsertStatementCount,
    ImmutableDictionary<ColumnIdentifier, ImmutableArray<string>> ValuesByColumn);

public sealed record ColumnIdentifier(string TableName, string ColumnName);
```

---

### 2. Create InsertTransformationVerifier

**File**: `src/Osm.Pipeline/UatUsers/Verification/InsertTransformationVerifier.cs`

**Purpose**: Verify transformation correctness using parsed INSERT values

```csharp
namespace Osm.Pipeline.UatUsers.Verification;

public sealed class InsertTransformationVerifier
{
    private readonly ILogger<InsertTransformationVerifier> _logger;

    public InsertTransformationVerifier(ILogger<InsertTransformationVerifier> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<Result<InsertVerificationReport>> VerifyAsync(
        ParsedInsertScript parsedScript,
        IReadOnlyDictionary<UserIdentifier, UserIdentifier> transformationMap,
        IReadOnlyList<UserFkColumn> userFkCatalog,
        CancellationToken cancellationToken = default)
    {
        var warnings = ImmutableArray.CreateBuilder<InsertVerificationWarning>();
        var tableResults = ImmutableArray.CreateBuilder<InsertVerificationResult>();
        var userFkLookup = BuildUserFkLookup(userFkCatalog);
        var orphanIds = transformationMap.Keys.ToHashSet();

        long totalValuesInspected = 0;
        int totalTransformationsVerified = 0;

        foreach (var (columnId, values) in parsedScript.ValuesByColumn)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var fqColumnName = $"dbo.{columnId.TableName}.{columnId.ColumnName}";
            var isUserFk = userFkLookup.Contains(fqColumnName);

            var orphanIdsFound = ImmutableArray.CreateBuilder<UserIdentifier>();
            int nullsFound = 0;
            int targetIdsFound = 0;

            foreach (var literal in values)
            {
                totalValuesInspected++;

                if (literal == "NULL")
                {
                    nullsFound++;
                    continue;
                }

                if (!isUserFk)
                    continue;

                var userId = UserIdentifier.FromDatabaseValue(literal);

                // Check if this is an orphan (should NOT appear in INSERTs after transformation)
                if (orphanIds.Contains(userId))
                {
                    orphanIdsFound.Add(userId);
                    warnings.Add(new InsertVerificationWarning(
                        Schema: "dbo",
                        TableName: columnId.TableName,
                        ColumnName: columnId.ColumnName,
                        WarningType: "OrphanDetected",
                        OrphanId: userId,
                        Message: $"Orphan ID {userId} found in INSERT - transformation not applied"));
                }

                // Check if this is a target ID (expected after transformation)
                if (transformationMap.Values.Contains(userId))
                {
                    targetIdsFound++;
                    totalTransformationsVerified++;
                }
            }

            tableResults.Add(new InsertVerificationResult(
                Schema: "dbo",
                TableName: columnId.TableName,
                ColumnName: columnId.ColumnName,
                IsUserFkColumn: isUserFk,
                ValuesInspected: values.Length,
                OrphanIdsFound: orphanIdsFound.Count,
                TargetIdsFound: targetIdsFound,
                NullsFound: nullsFound,
                OrphanIds: orphanIdsFound.ToImmutable()));
        }

        var report = new InsertVerificationReport(
            Passed: warnings.Count == 0,
            VerifiedAtUtc: DateTimeOffset.UtcNow,
            TablesVerified: parsedScript.ValuesByColumn.Keys.Select(c => c.TableName).Distinct().Count(),
            ColumnsVerified: parsedScript.ValuesByColumn.Count,
            ValuesInspected: totalValuesInspected,
            TransformationsVerified: totalTransformationsVerified,
            TableResults: tableResults.ToImmutable(),
            Warnings: warnings.ToImmutable());

        return Result<InsertVerificationReport>.Success(report);
    }

    private IReadOnlySet<string> BuildUserFkLookup(IReadOnlyList<UserFkColumn> catalog)
    {
        return catalog
            .Select(c => $"{c.SchemaName}.{c.TableName}.{c.ColumnName}")
            .ToHashSet(StringComparer.OrdinalIgnoreCase);
    }
}
```

---

### 3. Integrate with FullExportPipeline

**File**: `src/Osm.Pipeline/Application/FullExportApplicationService.cs`

**Integration Point**: After build completes and UAT-users artifacts emitted

```csharp
// After UAT-users emission:
if (uatUsersResult != null && options.VerifyInsertTransformations)
{
    var parser = new InsertScriptParser();
    var verifier = new InsertTransformationVerifier(_logger);

    var insertScriptPath = Path.Combine(buildOutputDir, "DynamicData", "DynamicData.insert.sql");
    var scriptContent = await File.ReadAllTextAsync(insertScriptPath, cancellationToken);

    var parsedScript = await parser.ParseScript(scriptContent, insertScriptPath);
    var verificationResult = await verifier.VerifyAsync(
        parsedScript.Value,
        uatUsersResult.TransformationMap,
        uatUsersResult.UserFkCatalog,
        cancellationToken);

    // Emit verification report
    var reportPath = Path.Combine(uatUsersOutputDir, "insert_verification.json");
    await File.WriteAllTextAsync(
        reportPath,
        JsonSerializer.Serialize(verificationResult.Value, new JsonSerializerOptions { WriteIndented = true }),
        cancellationToken);

    log.Record(
        "fullExport.insertVerification.completed",
        $"INSERT verification: {verificationResult.Value.Passed ? "PASSED" : "FAILED"}",
        new PipelineLogMetadataBuilder()
            .WithValue("passed", verificationResult.Value.Passed ? "true" : "false")
            .WithCount("valuesInspected", verificationResult.Value.ValuesInspected)
            .WithCount("transformationsVerified", verificationResult.Value.TransformationsVerified)
            .WithCount("warnings", verificationResult.Value.Warnings.Length)
            .Build());

    if (!verificationResult.Value.Passed)
    {
        foreach (var warning in verificationResult.Value.Warnings.Take(10))
        {
            log.Record("fullExport.insertVerification.warning", warning.Message);
        }
    }
}
```

---

## Test Scenarios

### Test 1: Orphan Elimination

```csharp
[Fact]
public async Task VerifyAsync_NoOrphansInInserts_ReturnsSuccess()
{
    // Arrange: INSERT contains only target IDs (orphans transformed)
    var transformationMap = new Dictionary<UserIdentifier, UserIdentifier>
    {
        [new UserIdentifier(42)] = new UserIdentifier(99)
    };

    var insertScript = @"
        INSERT INTO [User] ([Id], [Name]) VALUES (99, 'Alice');
        INSERT INTO [Order] ([UserId]) VALUES (99);
    ";

    var parsed = _parser.ParseScript(insertScript);

    // Act
    var result = await _verifier.VerifyAsync(parsed.Value, transformationMap, catalog);

    // Assert
    Assert.True(result.Value.Passed);
    Assert.Equal(0, result.Value.Warnings.Length);
    Assert.All(result.Value.TableResults, tr => Assert.Equal(0, tr.OrphanIdsFound));
}
```

### Test 2: Orphan Detection (Transformation Bug)

```csharp
[Fact]
public async Task VerifyAsync_OrphanInInsert_ReturnsWarning()
{
    // Arrange: INSERT contains orphan ID (transformation NOT applied - BUG!)
    var transformationMap = new Dictionary<UserIdentifier, UserIdentifier>
    {
        [new UserIdentifier(42)] = new UserIdentifier(99)
    };

    var insertScript = @"
        INSERT INTO [Order] ([UserId]) VALUES (42); -- Orphan! Should be 99
    ";

    var parsed = _parser.ParseScript(insertScript);

    // Act
    var result = await _verifier.VerifyAsync(parsed.Value, transformationMap, catalog);

    // Assert
    Assert.False(result.Value.Passed);
    Assert.Single(result.Value.Warnings);
    Assert.Equal("OrphanDetected", result.Value.Warnings[0].WarningType);
    Assert.Equal(new UserIdentifier(42), result.Value.Warnings[0].OrphanId);
}
```

### Test 3: NULL Preservation

```csharp
[Fact]
public async Task VerifyAsync_NullsPreserved_CountsNulls()
{
    // Arrange: INSERTs contain NULLs (should NOT be transformed)
    var insertScript = @"
        INSERT INTO [Order] ([UserId]) VALUES (NULL);
        INSERT INTO [Order] ([UserId]) VALUES (99);
    ";

    var parsed = _parser.ParseScript(insertScript);

    // Act
    var result = await _verifier.VerifyAsync(parsed.Value, transformationMap, catalog);

    // Assert
    var orderUserIdResult = result.Value.TableResults
        .First(tr => tr.TableName == "Order" && tr.ColumnName == "UserId");

    Assert.Equal(1, orderUserIdResult.NullsFound);
    Assert.Equal(0, orderUserIdResult.OrphanIdsFound);
}
```

---

## Codebase Integration Guide

### Existing Infrastructure (Leverage These)

âœ… **TSql150Parser** - Already used in ScriptDomDmmLens.cs
- Reuse for INSERT script parsing
- Extract VALUES literals via SQL DOM visitor pattern

âœ… **UserFkColumn catalog** - Already generated by M2.1
- Contains list of user FK columns
- Use for column identification during verification

âœ… **Transformation map** - Already loaded from CSV
- Contains orphan â†’ target mappings
- Use to detect orphans in generated INSERTs

âœ… **Verification report pattern** - Established in M2.1
- JSON report structure
- Warnings array for issues

### Required Changes

**New Files**:
- `src/Osm.Pipeline/UatUsers/Verification/InsertScriptParser.cs` (~200 lines)
- `src/Osm.Pipeline/UatUsers/Verification/InsertTransformationVerifier.cs` (~150 lines)
- `tests/Osm.Pipeline.Tests/UatUsers/InsertScriptParserTests.cs` (~300 lines)
- `tests/Osm.Pipeline.Tests/UatUsers/InsertTransformationVerifierTests.cs` (~400 lines)

**Modified Files**:
- `src/Osm.Pipeline/Application/FullExportApplicationService.cs` (add verification step)
- `src/Osm.Cli/Commands/FullExportCommandFactory.cs` (add `--verify-insert-transformations` flag)

---

## Success Criteria

M2.5 is successful if:

âœ… INSERT scripts parsed successfully using TSql150Parser

âœ… Orphan IDs detected when present in INSERTs (catch transformation bugs)

âœ… NULLs counted correctly (verify NULL preservation)

âœ… Verification report emitted as JSON

âœ… CI/CD can gate deployments on verification passing

âœ… All tests pass (unit, integration)

âœ… Manual inspection confirms correct detection of transformation issues

---

*Generated: 2025-11-19*
*Status: Ready for Implementation (after M2.4 ships)*
*Provides automated proof that INSERT transformations were correctly applied*
