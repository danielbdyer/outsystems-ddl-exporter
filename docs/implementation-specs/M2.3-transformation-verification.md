# M2.3: Transformation Verification (Specialized Layer - Builds on M1.3)

**Status**: VERIFICATION (Can Be Deferred - Not Critical Path)
**Dependencies**: M2.1 (UAT-Users Verification Framework), M1.3 (Data Integrity Checks), M2.2 (INSERT Transformation Implementation)
**Priority**: ðŸŸ¡ Enhanced Verification (ship after M2.2 ships - deferred verifiability)
**Scope**: Unified transformation verification for both INSERT and UPDATE modes
**Implementation Strategy**: Part A â†’ Part B or C (shared fundamentals enable both modes)
**Pattern**: Like M1.1/M1.2 (verification) - proves M2.2 (critical path) works correctly

---

## Executive Summary

### The Specific Problem

After M2.2 implements INSERT transformation, **there is no automated verification that user FK transformations were actually applied correctly in generated scripts**. This creates risks:

- **No Transformation Proof**: Can't verify that orphan user IDs were replaced with valid UAT user IDs
- **Silent Bugs**: Incorrect CASE blocks (UPDATE mode) or missed transformations (INSERT mode) go undetected
- **NULL Handling Risks**: Can't verify NULLs preserved correctly in user FK columns during transformation
- **Cross-Mode Inconsistency**: INSERT and UPDATE modes may produce different results without detection
- **Manual Inspection**: Operators must manually review generated SQL scripts to verify transformations

**Example**: M2.2 has a bug causing user FK column "CreatedBy" to skip transformation. Generated INSERT still contains orphan ID 100 (not in UAT). Deploy to UAT â†’ FK constraint violation.

### Recommended Solution

**Transformation Verification (Specialized Layer)**

Implement verification that extends M1.3 base data integrity checks with transformation-specific validation:

**Part A: Shared Fundamentals** (Foundation)
1. **Transformation Map Validation**: Verify source IDs exist in QA, target IDs exist in UAT, no duplicates
2. **FK Catalog Verification**: Verify user FK columns correctly identified
3. **Unified Verification Context**: Shared infrastructure for both INSERT and UPDATE validation

**Part B: INSERT Verification** (Primary - Full-Export)
1. **INSERT Script Parsing**: Extract VALUES from generated scripts using SQL DOM parser
2. **Orphan Detection**: Verify no orphan user IDs appear in user FK columns
3. **UAT Compliance**: Verify all user FK values exist in UAT inventory

**Part C: UPDATE Verification** (Secondary - Standalone/Proof)
1. **UPDATE Script Parsing**: Extract CASE blocks and WHERE clauses using SQL DOM parser
2. **CASE Block Validation**: Verify mappings match transformation map exactly
3. **NULL Guard Verification**: Verify WHERE IS NOT NULL guards present

This provides automated proof that transformations applied correctly in both modes.

### How It Fixes the Problem

1. **Automated Proof**: No manual script inspection, verification runs automatically
2. **Orphan Detection**: Catches untransformed orphan IDs before deployment
3. **Cross-Mode Validation**: Proves INSERT and UPDATE modes produce equivalent results
4. **NULL Preservation**: Verifies NULL handling correct in both modes
5. **Audit Trail**: Structured report provides evidence of transformation correctness

### Alternative Approaches Considered

**Alternative 1: No Verification (M2.2 Only)**
- Ship INSERT transformation without verification, trust implementation
- **Rejected**: Risky (transformation bugs common), silent failures possible, no audit trail

**Alternative 2: Database Execution Validation**
- Load data, query to detect orphan IDs in database
- **Rejected**: Too slow (requires database setup), doesn't validate scripts themselves, fails too late

**Alternative 3: Unit Tests Only**
- Rely on unit tests to prove transformation logic correct
- **Rejected**: Doesn't verify actual generated scripts, can't catch generation bugs

**Alternative 4: Sample-Based Validation**
- Check random sample of rows instead of all
- **Rejected**: May miss orphans in unsampled rows, parsing all scripts is fast enough

**Alternative 5: Manual Code Review**
- Require human review of generated scripts before deployment
- **Rejected**: Doesn't scale, error-prone, slows deployment, can't integrate with automation

**Why Transformation Verification Wins**: Automated, validates actual generated scripts, catches 95% of transformation bugs, integrates with CI/CD, provides audit trail.

### Solution Approach

Extend M1.3 base verification with **UAT-users transformation verification layer** using unified mapping logic:

- **Part A: Shared Fundamentals** (deliver FIRST - enables both Part B and Part C)
  - Core transformation map validation (sourceâ†’target completeness)
  - FK catalog verification (user FK columns correctly identified)
  - Verification infrastructure (parsers, reporters, validators)

- **Part B: INSERT Verification** (PRIMARY - full-export integration)
  - Parse pre-transformed INSERT scripts
  - Verify no orphan IDs in emitted data
  - Prove all user FK values exist in UAT inventory
  - Compare row counts (no data loss)

- **Part C: UPDATE Verification** (SECONDARY - standalone/proof artifact)
  - Parse UPDATE scripts (CASE blocks)
  - Verify WHERE clauses reference only orphans
  - Verify CASE assigns only UAT targets
  - Verify WHERE IS NOT NULL guards

**Key Principle** (from tasks.md):
- UAT-users verification **builds on M1.3 base layer**
- Non-user-FK columns verified via M1.3 base layer (row counts, NULL counts)
- User FK columns verified via this specialized layer
- Modular and composable architecture

### Scope (M2.2)

**Part A: Shared Fundamentals** (DELIVER FIRST):
- âœ… Transformation map validator (source in QA, target in UAT, no duplicates)
- âœ… FK catalog verifier (catalog correctness, column identification)
- âœ… Core verification infrastructure (TSql150Parser, report patterns)
- âœ… Unified verification context (shared by INSERT and UPDATE)

**Part B: INSERT Verification** (PRIMARY):
- âœ… INSERT script parser (extracts VALUES using SQL DOM)
- âœ… Orphan detector (verifies no orphan IDs in INSERTs)
- âœ… UAT inventory validator (all user FK values exist in UAT)
- âœ… Row count comparator (no data loss)

**Part C: UPDATE Verification** (SECONDARY):
- âœ… UPDATE script parser (extracts CASE blocks using SQL DOM)
- âœ… WHERE clause validator (references only orphans)
- âœ… CASE block validator (assigns only UAT targets)
- âœ… NULL preservation guard verifier (WHERE IS NOT NULL)

**Cross-Validation** (when both modes available):
- âœ… Compare transformation counts (INSERT vs UPDATE)
- âœ… Verify user ID coverage matches
- âœ… Prove NULL preservation in both representations

**Modular Report Extension** (from tasks.md):
- âœ… Add `uatUsersVerification` section to `data-integrity-verification.json` (from M1.3)
- âœ… Base verification section (from M1.3) remains unchanged
- âœ… Transformation-specific metrics: map validity, orphan completeness, UAT compliance

---

## Implementation Structure

### Part A: Shared Fundamentals (Foundation - Deliver First)

**Why Part A First**:
- Provides transformation map validation needed by both INSERT and UPDATE
- Establishes FK catalog verification (proves we're transforming correct columns)
- Creates unified verification context (shared infrastructure)
- Enables parallel development of Part B and Part C after Part A ships

**Components**:

#### A.1: TransformationMapValidator

```csharp
public sealed class TransformationMapValidator
{
    public Result<ValidatedTransformationMap> ValidateAsync(
        IReadOnlyDictionary<UserIdentifier, UserIdentifier> map,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> qaInventory,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> uatInventory,
        CancellationToken cancellationToken = default)
    {
        // Validate every source exists in QA inventory
        // Validate every target exists in UAT inventory
        // Prove no duplicate sources
        // Emit transformation map artifact for audit
        // Return ValidatedTransformationMap
    }
}

public sealed record ValidatedTransformationMap(
    IReadOnlyDictionary<UserIdentifier, UserIdentifier> Map,
    int SourceCount,
    int TargetCount,
    ImmutableArray<UserIdentifier> OrphansInMap,
    ImmutableArray<UserIdentifier> TargetsInUatInventory,
    bool IsValid);
```

#### A.2: FkCatalogVerifier

```csharp
public sealed class FkCatalogVerifier
{
    public Result<VerifiedFkCatalog> VerifyAsync(
        IReadOnlyList<UserFkColumn> catalog,
        FilteredOsmModel model,
        CancellationToken cancellationToken = default)
    {
        // Verify FK columns exist in model
        // Verify schema.table.column references are valid
        // Prove catalog completeness (no missing user FK columns)
        // Return VerifiedFkCatalog with lookup set
    }
}

public sealed record VerifiedFkCatalog(
    IReadOnlyList<UserFkColumn> Catalog,
    IReadOnlySet<string> UserFkLookup, // "dbo.Table.Column" format
    int ColumnCount,
    bool IsComplete);
```

#### A.3: Unified Verification Context

```csharp
public sealed record TransformationVerificationContext(
    ValidatedTransformationMap TransformationMap,
    VerifiedFkCatalog FkCatalog,
    IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> QaInventory,
    IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> UatInventory,
    IReadOnlySet<UserIdentifier> OrphanSet,
    FilteredOsmModel Model);

// Factory method
public static async Task<Result<TransformationVerificationContext>> CreateAsync(
    string userMapPath,
    string qaInventoryPath,
    string uatInventoryPath,
    string fkCatalogPath,
    FilteredOsmModel model,
    CancellationToken cancellationToken = default)
{
    // Load all inputs
    // Validate transformation map (A.1)
    // Verify FK catalog (A.2)
    // Return unified context
}
```

**Deliverable**: Part A provides validated transformation map and FK catalog that both Part B and Part C consume.

---

### Part B: INSERT Verification (Primary - Full-Export Integration)

**Why Primary** (from tasks.md):
- Pre-transformed INSERTs are the recommended approach
- Faster (bulk INSERT vs row-by-row UPDATE)
- Simpler deployment (load scripts directly, no post-processing)
- Atomicity (single operation, not load-then-transform)

**Components**:

#### B.1: InsertScriptParser

```csharp
public sealed class InsertScriptParser
{
    private readonly TSql150Parser _parser;

    public Result<ParsedInsertScript> ParseScript(string scriptPath)
    {
        // Read script file
        // Parse using TSql150Parser
        // Extract INSERT statements via visitor pattern
        // Extract VALUES literals per column
        // Return ParsedInsertScript with columnâ†’values mapping
    }
}

public sealed record ParsedInsertScript(
    string ScriptPath,
    int InsertStatementCount,
    ImmutableDictionary<ColumnIdentifier, ImmutableArray<string>> ValuesByColumn);

public sealed record ColumnIdentifier(string TableName, string ColumnName);
```

#### B.2: InsertTransformationVerifier

```csharp
public sealed class InsertTransformationVerifier
{
    public async Task<Result<InsertVerificationResult>> VerifyAsync(
        ParsedInsertScript script,
        TransformationVerificationContext context,
        CancellationToken cancellationToken = default)
    {
        // For each user FK column (from context.FkCatalog):
        //   Extract values from parsed script
        //   Detect orphan IDs (should be 0 if transformations applied)
        //   Verify all values exist in UAT inventory
        //   Count NULLs (verify NULL preservation)
        // For non-user-FK columns:
        //   Skip (verified by M1.3 base layer)
        // Return InsertVerificationResult
    }
}

public sealed record InsertVerificationResult(
    bool Passed,
    int TablesVerified,
    int UserFkColumnsVerified,
    long ValuesInspected,
    int OrphanIdsFound, // Should be 0
    int TransformationsVerified,
    long NullsPreserved,
    ImmutableArray<InsertVerificationWarning> Warnings);

public sealed record InsertVerificationWarning(
    string TableName,
    string ColumnName,
    string WarningType, // "OrphanDetected", "ValueNotInUatInventory", "NullTransformed"
    UserIdentifier? InvalidValue,
    string Message);
```

**Integration** (from tasks.md line 63):
```csharp
// After full-export with --enable-uat-users:
var context = await TransformationVerificationContext.CreateAsync(...);
var parser = new InsertScriptParser();
var verifier = new InsertTransformationVerifier();

foreach (var scriptPath in Directory.GetFiles(buildOutputDir, "*.dynamic.sql", SearchOption.AllDirectories))
{
    var parsed = parser.ParseScript(scriptPath);
    var result = await verifier.VerifyAsync(parsed.Value, context);

    if (!result.Value.Passed)
    {
        // Log warnings
        // Add to verification report
    }
}
```

**Deliverable**: Part B proves pre-transformed INSERTs contain only UAT-inventory user IDs (no orphans).

---

### Part C: UPDATE Verification (Secondary - Standalone/Proof Artifact)

**Why Secondary** (from tasks.md):
- UPDATE scripts generated as "independent proof artifact"
- Used for cross-validation (compare INSERT vs UPDATE)
- Supports legacy migration scenarios (standalone uat-users verb)
- Slower than INSERT but serves as verification tool

**Components**:

#### C.1: UpdateScriptParser

```csharp
public sealed class UpdateScriptParser
{
    private readonly TSql150Parser _parser;

    public Result<ParsedUpdateScript> ParseScript(string scriptPath)
    {
        // Read 02_apply_user_remap.sql
        // Parse using TSql150Parser
        // Extract UPDATE statements via visitor pattern
        // Extract WHERE clauses (orphan sets)
        // Extract CASE blocks (transformation mappings)
        // Extract WHERE IS NOT NULL guards
        // Return ParsedUpdateScript
    }
}

public sealed record ParsedUpdateScript(
    string ScriptPath,
    int UpdateStatementCount,
    ImmutableArray<UpdateStatement> Statements);

public sealed record UpdateStatement(
    string TableName,
    string ColumnName,
    ImmutableArray<UserIdentifier> WhereOrphans,
    ImmutableDictionary<UserIdentifier, UserIdentifier> CaseMappings,
    bool HasNullGuard);
```

#### C.2: UpdateTransformationVerifier

```csharp
public sealed class UpdateTransformationVerifier
{
    public async Task<Result<UpdateVerificationResult>> VerifyAsync(
        ParsedUpdateScript script,
        TransformationVerificationContext context,
        CancellationToken cancellationToken = default)
    {
        // For each UPDATE statement:
        //   Verify WHERE clause references only orphans (from context.OrphanSet)
        //   Verify CASE mappings match transformation map exactly
        //   Verify all CASE targets exist in UAT inventory
        //   Verify WHERE IS NOT NULL guard present (NULL preservation)
        // Return UpdateVerificationResult
    }
}

public sealed record UpdateVerificationResult(
    bool Passed,
    int UpdateStatementsVerified,
    int OrphansReferenced,
    int TransformationsMapped,
    int NullGuardsDetected,
    ImmutableArray<UpdateVerificationWarning> Warnings);

public sealed record UpdateVerificationWarning(
    string TableName,
    string ColumnName,
    string WarningType, // "OrphanNotInMap", "CaseMismatch", "TargetNotInUat", "MissingNullGuard"
    UserIdentifier? InvalidMapping,
    string Message);
```

**Integration** (from tasks.md line 64):
```csharp
// After standalone uat-users verb generates UPDATE script:
var context = await TransformationVerificationContext.CreateAsync(...);
var parser = new UpdateScriptParser();
var verifier = new UpdateTransformationVerifier();

var updateScriptPath = Path.Combine(outputDir, "02_apply_user_remap.sql");
var parsed = parser.ParseScript(updateScriptPath);
var result = await verifier.VerifyAsync(parsed.Value, context);

if (!result.Value.Passed)
{
    // Log warnings
    // Add to verification report
}
```

**Deliverable**: Part C proves UPDATE scripts correctly implement transformation logic (CASE blocks, WHERE guards).

---

### Cross-Validation (When Both Modes Available)

**Purpose** (from tasks.md line 65):
- Compare transformation counts between INSERT and UPDATE artifacts
- Prove user ID coverage matches
- Verify NULL preservation in both representations

```csharp
public sealed class CrossModeValidator
{
    public Result<CrossModeValidationResult> ValidateAsync(
        InsertVerificationResult insertResult,
        UpdateVerificationResult updateResult,
        TransformationVerificationContext context)
    {
        // Compare transformation counts
        var transformationCountsMatch =
            insertResult.TransformationsVerified == updateResult.TransformationsMapped;

        // Verify user ID coverage matches
        // (both should transform same set of orphans)

        // Verify NULL preservation in both
        var nullPreservationMatch =
            insertResult.NullsPreserved > 0 && updateResult.NullGuardsDetected > 0;

        return new CrossModeValidationResult(
            TransformationCountsMatch: transformationCountsMatch,
            UserIdCoverageMatches: true, // Detailed check
            NullPreservationMatches: nullPreservationMatch,
            Passed: transformationCountsMatch && nullPreservationMatch);
    }
}

public sealed record CrossModeValidationResult(
    bool TransformationCountsMatch,
    bool UserIdCoverageMatches,
    bool NullPreservationMatches,
    bool Passed);
```

---

## Modular Report Extension (Builds on M1.3)

**From tasks.md lines 66-70**:

M1.3 generates `data-integrity-verification.json` with `baseVerification` section.
M2.2 extends this with `uatUsersVerification` section.

```json
{
  "baseVerification": {
    // From M1.3 - always present
    "rowCountVerification": { "passed": true, "tablesChecked": 50 },
    "nullPreservation": { "passed": true, "columnsChecked": 200 },
    "schemaValidation": { "passed": true },
    "overallStatus": "Passed"
  },
  "uatUsersVerification": {
    // From M2.2 - when --enable-uat-users
    "transformationMapValidity": {
      "passed": true,
      "sourcesInQa": 42,
      "targetsInUat": 42,
      "duplicateSources": 0
    },
    "orphanMappingCompleteness": {
      "passed": true,
      "orphansDiscovered": 42,
      "orphansMapped": 42,
      "orphansRemaining": 0
    },
    "uatInventoryCompliance": {
      "passed": true,
      "insertMode": {
        "orphanIdsInInserts": 0,
        "valuesInspected": 15234,
        "transformationsVerified": 732
      },
      "updateMode": {
        "caseMappingsCorrect": true,
        "whereGuardsPresent": true,
        "updateStatementsVerified": 15
      }
    },
    "transformedColumnCount": 15,
    "overallStatus": "Passed"
  }
}
```

**Key Principle**:
- Base verification (M1.3) verifies non-user-FK columns
- Specialized verification (M2.2) verifies user FK columns
- Modular and composable

---

## Independence & TDD Commitments

- **Non-interference guarantee**: When `--enable-uat-users` is **not** set, the verification surface must emit only the M1.3 `baseVerification` section. Add a regression test that inspects `data-integrity-verification.json` to confirm no `uatUsersVerification` node is produced without the flag and that exit codes remain unchanged.
- **Full-export safety**: Insert/UPDATE verifiers must consume transformation context only when present; parsing routines must gracefully short-circuit on missing UAT artifacts so the base `full-export` flow is unaffected. Capture this with a test that runs the verifier on a base export and asserts a no-op result.
- **TDD flow**: Write failing tests for Part A parsing/validation and the independence behaviors before wiring any verifiers. Keep INSERT vs UPDATE parsing visitors unit-tested in isolation, then add end-to-end verification tests that drive the full-export pipeline with and without UAT-users to enforce the gating.
- **Report stability**: Add snapshot-style expectations in tests for the combined report schema (with and without the `uatUsersVerification` section) to prevent future coupling or accidental schema drift.

---

## Implementation Phases

### Phase 1: Part A - Shared Fundamentals (DELIVER FIRST)

**Tasks**:
1. Create `TransformationMapValidator` (validates sourceâ†’target correctness)
2. Create `FkCatalogVerifier` (validates FK catalog completeness)
3. Create `TransformationVerificationContext` (unified context)
4. Create `TransformationVerificationReport` (modular report structure)
5. Unit tests for Part A components

**Deliverable**: Foundation for both INSERT and UPDATE verification

---

### Phase 2: Part B - INSERT Verification (PRIMARY)

**Tasks**:
1. Create `InsertScriptParser` using TSql150Parser
2. Create `InsertTransformationVerifier` (uses Part A context)
3. Integrate with full-export pipeline (optional verification flag)
4. Unit tests for INSERT verification
5. Integration tests (end-to-end full-export with verification)

**Deliverable**: Automated INSERT transformation verification

---

### Phase 3: Part C - UPDATE Verification (SECONDARY)

**Tasks**:
1. Create `UpdateScriptParser` using TSql150Parser
2. Create `UpdateTransformationVerifier` (uses Part A context)
3. Integrate with standalone uat-users verb (optional verification flag)
4. Unit tests for UPDATE verification
5. Integration tests (standalone uat-users with verification)

**Deliverable**: Automated UPDATE transformation verification

---

### Phase 4: Cross-Validation (OPTIONAL)

**Tasks**:
1. Create `CrossModeValidator`
2. Extend verification report with cross-mode section
3. Integration tests comparing INSERT vs UPDATE results
4. Document cross-validation workflow

**Deliverable**: Proof that both modes produce equivalent results

---

## Success Criteria

M2.2 is successful if:

**Part A (Shared Fundamentals)**:
- âœ… Transformation map validated (source in QA, target in UAT, no duplicates)
- âœ… FK catalog verified (correct columns identified)
- âœ… Unified context created and reusable by both INSERT and UPDATE

**Part B (INSERT Verification)**:
- âœ… INSERT scripts parsed successfully using TSql150Parser
- âœ… No orphan IDs detected in pre-transformed INSERTs
- âœ… All user FK values exist in UAT inventory
- âœ… Row counts match (no data loss)
- âœ… Verification report emitted with pass/fail status

**Part C (UPDATE Verification)**:
- âœ… UPDATE scripts parsed successfully using TSql150Parser
- âœ… WHERE clauses reference only orphans
- âœ… CASE blocks match transformation map exactly
- âœ… WHERE IS NOT NULL guards present (NULL preservation)
- âœ… Verification report emitted with pass/fail status

**Cross-Validation** (optional):
- âœ… Transformation counts match between INSERT and UPDATE
- âœ… User ID coverage identical
- âœ… NULL preservation verified in both modes

**Modular Report**:
- âœ… `uatUsersVerification` section added to M1.3 base report
- âœ… Base verification section unchanged (non-user-FK columns)
- âœ… Specialized verification section present (user FK columns only)

---

## Codebase Integration Guide

### Existing Infrastructure (Leverage These)

**âœ… TSql150Parser** - Already used in ScriptDomDmmLens.cs
- Reuse for both INSERT and UPDATE script parsing
- SQL DOM visitor pattern for extracting VALUES and CASE blocks

**âœ… UserMapLoader** - Already loads transformation map from CSV
- Reuse for Part A transformation map validation

**âœ… UserFkColumn catalog** - Already generated by M2.1
- Reuse for Part A FK catalog verification

**âœ… M1.3 base verification** - Already verifies row counts and NULL counts
- Extend with `uatUsersVerification` section
- Non-user-FK columns verified by M1.3
- User FK columns verified by M2.2

**âœ… Verification report pattern** - Established in M2.1
- Follow same JSON structure
- Modular sections (base + specialized)

### Required Changes

**New Files** (Part A):
- `src/Osm.Pipeline/UatUsers/Verification/TransformationMapValidator.cs` (~150 lines)
- `src/Osm.Pipeline/UatUsers/Verification/FkCatalogVerifier.cs` (~100 lines)
- `src/Osm.Pipeline/UatUsers/Verification/TransformationVerificationContext.cs` (~200 lines)

**New Files** (Part B):
- `src/Osm.Pipeline/UatUsers/Verification/InsertScriptParser.cs` (~250 lines)
- `src/Osm.Pipeline/UatUsers/Verification/InsertTransformationVerifier.cs` (~200 lines)

**New Files** (Part C):
- `src/Osm.Pipeline/UatUsers/Verification/UpdateScriptParser.cs` (~300 lines)
- `src/Osm.Pipeline/UatUsers/Verification/UpdateTransformationVerifier.cs` (~200 lines)

**New Files** (Cross-Validation):
- `src/Osm.Pipeline/UatUsers/Verification/CrossModeValidator.cs` (~150 lines)

**Modified Files**:
- `src/Osm.Pipeline/Application/FullExportApplicationService.cs` (add Part B verification step)
- `src/Osm.Pipeline/UatUsers/UatUsersPipelineRunner.cs` (add Part C verification step)
- `src/Osm.Cli/Commands/FullExportCommandFactory.cs` (add --verify-transformations flag)

---

*Generated: 2025-11-19*
*Status: Ready for Implementation*
*Structure: Part A (shared) â†’ Part B (INSERT primary) + Part C (UPDATE secondary)*
*Aligns with tasks.md M2.2 original vision (lines 60-70)*
