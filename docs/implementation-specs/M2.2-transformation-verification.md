# M2.2: UPDATE Script Verification

**Status**: READY FOR IMPLEMENTATION
**Dependencies**: M2.1 (UAT-Users Verification Framework)
**Priority**: üü° Enhanced Verification (ship after M2.1 adoption)
**Scope**: UPDATE script verification only (current architecture)
**Note**: INSERT transformation verification is covered in M2.4

---

## Executive Summary

### Problem Statement

M2.1 verifies UAT-users **artifacts** (map validity, catalog completeness, SQL safety), but there's **no verification that UPDATE transformations are correct** when applied to the database.

**Current Reality**:
- UAT-users currently generates UPDATE scripts (`02_apply_user_remap.sql`) in standalone mode
- INSERT transformation (pre-transformed INSERTs during full-export) is not yet implemented
- See M2.4 for INSERT transformation implementation plan

**Current gap**: Operators have no proof that:
- UPDATE scripts correctly transform orphan user IDs to valid UAT targets
- NULL values are preserved (never transformed)
- CASE blocks match the transformation map exactly
- No data corruption occurs during transformation

**Risk**: Silent data corruption where UPDATE transformations are incomplete or incorrect.

### Solution Approach

Build an **UPDATE script verification layer** that:
- **Parses UPDATE scripts** to extract CASE block mappings and verify correctness
- **Validates NULL preservation** via `WHERE ... IS NOT NULL` guards
- **Verifies transformation map compliance** (all CASE mappings match user map)
- **Emits UPDATE verification report** (JSON) for audit trails

**This extends M2.1 artifact verification with UPDATE transformation correctness.**

### Scope (M2.2)

**Ship This**:
- ‚úÖ UPDATE script parser (extracts CASE blocks, validates mappings)
- ‚úÖ NULL preservation verifier (verifies WHERE guards)
- ‚úÖ Transformation map validator (CASE blocks match user map)
- ‚úÖ UPDATE verification report generator (JSON output)

**Out of Scope** (see M2.4):
- INSERT transformation implementation and verification
- Cross-mode validation (INSERT vs UPDATE)
- Pre-transformed INSERT generation

**Defer to Later**:
- üîµ Live database verification (execute UPDATEs and verify results) - M3.2
- üîµ Historical transformation auditing - M4.1

### Key Findings

**Already Exists** ‚úÖ:
- `SqlScriptEmitter.cs` (UPDATE script generation - pattern to parse)
- `Microsoft.SqlServer.TransactSql.ScriptDom` (TSql150Parser - use for parsing)
- Transformation map (source‚Üítarget mappings)
- `ValidateUserMapStep.cs` (validation patterns to reuse)

**Missing** ‚ùå:
- UPDATE script parser (extracts CASE blocks)
- Transformation verification context
- Verification report generator

---

## Critical Path Analysis

### Why This Matters

**Without transformation verification**:
- Bugs in INSERT generation silently emit orphan IDs (transformation not applied)
- Bugs in UPDATE script logic may skip rows or transform incorrectly
- Non-user-FK columns may be corrupted (no checksum validation)
- NULL handling bugs go undetected until production
- No audit proof that transformations are correct

**With transformation verification**:
- Catch transformation bugs before deployment
- Prove data fidelity for non-transformed columns
- Audit trail showing exact transformations applied
- CI/CD can gate deployments on transformation correctness
- Operators have confidence in UAT data quality

### Timeline Considerations

- M2.2 builds on M2.1 (requires verification framework infrastructure)
- Recommended after M2.1 ships and operators adopt artifact verification
- Blocks M3.2 (load harness with live verification)
- Can develop in parallel with M1.7 (different domains)

### Dependencies and Parallelization

**Depends On**:
- M2.1 (verification framework, report patterns)
- M1.8 (data integrity checksums, NULL counting)

**Enables**:
- M2.3 (integration tests - uses transformation verification as oracle)
- M3.2 (load harness verification - extends this with live DB checks)

**Can Parallel With**:
- M1.7 (topological proof generation)

---

## Problem Statement

### Current Behavior

**Full-export mode** (`--enable-uat-users`):
1. Discovers orphans (QA users not in UAT)
2. Loads transformation map
3. **Generates INSERT scripts with transformed user FK values** (in-memory transformation)
4. **No verification that INSERTs contain correct transformations**

**Standalone mode** (`uat-users` verb):
1. Discovers orphans
2. Loads transformation map
3. **Generates UPDATE scripts with CASE blocks** (SQL-based transformation)
4. **No verification that UPDATEs will produce correct results**

**Both modes**:
- No proof that transformations were applied
- No verification of NULL preservation
- No checksum validation for non-transformed columns
- No cross-mode equivalence check

### Desired State

**After INSERT generation**:
```bash
# Generate INSERTs with transformations
full-export --enable-uat-users ... --build-out ./out

# Verify transformations (new capability)
dotnet run --project src/Osm.Cli -- verify-transformations \
  --mode insert \
  --artifacts ./out/DynamicData \
  --transformation-map ./out/uat-users/00_user_map.csv \
  --fk-catalog ./out/uat-users/03_catalog.txt \
  --verification-report-out ./transformation-proof.json
```

**After UPDATE generation**:
```bash
# Generate UPDATE script
uat-users ... --out ./artifacts

# Verify UPDATE transformations (new capability)
dotnet run --project src/Osm.Cli -- verify-transformations \
  --mode update \
  --update-script ./artifacts/uat-users/02_apply_user_remap.sql \
  --transformation-map ./artifacts/uat-users/00_user_map.csv \
  --fk-catalog ./artifacts/uat-users/03_catalog.txt \
  --verification-report-out ./transformation-proof.json
```

**Transformation proof report**:
```json
{
  "overallStatus": "PASS",
  "mode": "insert",
  "timestamp": "2025-11-19T10:00:00Z",
  "verifications": {
    "userFkTransformationsApplied": "PASS",
    "nullPreservation": "PASS",
    "orphansEliminated": "PASS",
    "modeEquivalence": "PASS"
  },
  "summary": {
    "tablesTransformed": 15,
    "columnsTransformed": 23,
    "rowsTransformed": 1500,
    "orphansFound": 15,
    "orphansEliminated": 15,
    "orphansRemaining": 0,
    "nullsPreserved": 10
  },
  "details": [
    {
      "table": "dbo.Order",
      "column": "CreatedBy",
      "orphansFound": [999, 111],
      "transformations": {
        "999": 200,
        "111": 201
      },
      "nullCount": 5,
      "nullsPreserved": true,
      "status": "PASS"
    }
  ],
  "discrepancies": []
}
```

### Gap Analysis

| Capability | Current State | Desired State | Gap |
|------------|---------------|---------------|-----|
| INSERT verification | None | Parse and verify transformations | Need INSERT parser |
| UPDATE verification | None | Simulate and verify transformations | Need UPDATE simulator |
| NULL preservation | Assumed | Proven with counts | Need NULL verifier |
| Mode equivalence | Assumed | Cross-validated | Need cross-mode validator |
| Proof artifact | None | JSON report | Need report generator |

---

## Architecture

### Component Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Transformation Verification                     ‚îÇ
‚îÇ                    (M2.2 - New Layer)                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ InsertScriptParser
                              ‚îÇ   - Parses INSERT ... VALUES blocks
                              ‚îÇ   - Extracts user FK column values
                              ‚îÇ   - Verifies transformations applied
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ UpdateScriptSimulator
                              ‚îÇ   - Parses UPDATE CASE blocks
                              ‚îÇ   - Simulates transformation results
                              ‚îÇ   - Verifies mapping correctness
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ NullPreservationVerifier
                              ‚îÇ   - Counts NULLs in source data
                              ‚îÇ   - Counts NULLs in transformed data
                              ‚îÇ   - Proves NULLs never transformed
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ CrossModeValidator
                              ‚îÇ   - Compares INSERT vs UPDATE results
                              ‚îÇ   - Proves equivalence
                              ‚îÇ
                              ‚îî‚îÄ‚ñ∫ TransformationProofGenerator
                                  - Emits JSON proof report
                                  - Follows M2.1 pattern

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Existing Infrastructure (Leverage & Integrate)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ SqlScriptEmitter (UPDATE pattern)
                              ‚îú‚îÄ‚ñ∫ DynamicEntityInsertGenerator (INSERT pattern)
                              ‚îú‚îÄ‚ñ∫ M1.8 Data Integrity (checksums)
                              ‚îî‚îÄ‚ñ∫ M2.1 Verification Framework (reports)
```

### Data Models

#### TransformationVerificationContext.cs (NEW)
```csharp
public sealed record TransformationVerificationContext(
    TransformationMode Mode,
    string ArtifactRoot,
    TransformationApplicationResult ApplicationResult,
    NullPreservationResult NullPreservation,
    CrossModeValidationResult? CrossModeValidation)
{
    public bool IsValid =>
        ApplicationResult.IsValid &&
        NullPreservation.IsValid &&
        (CrossModeValidation == null || CrossModeValidation.IsValid);
}

public enum TransformationMode
{
    Insert,
    Update,
    Dual // Both modes for cross-validation
}
```

#### TransformationApplicationResult.cs (NEW)
```csharp
public sealed record TransformationApplicationResult(
    bool IsValid,
    int TablesTransformed,
    int ColumnsTransformed,
    long RowsTransformed,
    int OrphansFound,
    int OrphansEliminated,
    int OrphansRemaining,
    ImmutableArray<ColumnTransformationResult> ColumnResults);

public sealed record ColumnTransformationResult(
    string Schema,
    string Table,
    string Column,
    ImmutableArray<UserIdentifier> OrphansFound,
    ImmutableDictionary<UserIdentifier, UserIdentifier> Transformations,
    int NullCount,
    bool NullsPreserved,
    string Status);
```

#### NullPreservationResult.cs (NEW)
```csharp
public sealed record NullPreservationResult(
    bool IsValid,
    long SourceNullCount,
    long TransformedNullCount,
    ImmutableArray<string> ColumnsWithNullViolations);
```

#### CrossModeValidationResult.cs (NEW)
```csharp
public sealed record CrossModeValidationResult(
    bool IsValid,
    bool TransformationsEquivalent,
    ImmutableArray<string> Discrepancies);
```

---

## Codebase Integration Guide ‚≠ê

### Existing Infrastructure (Leverage These)

#### ‚úÖ **UPDATE Script Pattern** - Already Implemented (Parse This)
- **File**: `src/Osm.Pipeline/UatUsers/SqlScriptEmitter.cs` (344 lines)
- **Method**: `BuildScript()`, `AppendUpdateBlock()` (lines 104-128)
- **Status**: Complete - verification should parse output
- **Pattern to Parse**:
  ```sql
  -- UPDATE block structure (lines 114-126):
  ;WITH delta AS (
      SELECT t.[CreatedBy] AS OldUserId, r.TargetUserId AS NewUserId
      FROM [dbo].[Order] AS t
      JOIN #UserRemap AS r ON r.SourceUserId = t.[CreatedBy]
      WHERE t.[CreatedBy] IS NOT NULL
        AND t.[CreatedBy] <> r.TargetUserId
  )
  UPDATE t
     SET t.[CreatedBy] = d.NewUserId
  OUTPUT ...
    INTO #Changes(TableName, ColumnName, OldUserId, NewUserId, ChangedAt)
  FROM [dbo].[Order] AS t
  JOIN delta AS d ON d.OldUserId = t.[CreatedBy];
  ```

#### ‚úÖ **INSERT Generation Pattern** - Need to Trace (Understanding Required)
- **File**: `src/Osm.Emission/DynamicData/DynamicEntityInsertGenerator.cs`
- **Status**: Need to understand how transformations are applied during INSERT generation
- **Investigation Required**: How does full-export with `--enable-uat-users` inject transformation logic into INSERT generation?
- **Expected Pattern**: Transformation map passed to INSERT generator, values transformed in-memory

#### ‚úÖ **Data Integrity Verification** - Already Implemented (Integrate)
- **File**: M1.8 specification (checksums, NULL counting)
- **Status**: Pattern established - reuse for non-transformed columns
- **Integration**: Verify non-user-FK columns via checksum comparison (proves data fidelity)

#### ‚úÖ **Transformation Map** - Already Loaded (Reuse)
- **File**: `src/Osm.Pipeline/UatUsers/UserMapLoader.cs`
- **Method**: `LoadFromCsv()`
- **Status**: Complete - load map for verification

#### ‚úÖ **FK Catalog** - Already Generated (Reuse)
- **File**: User map artifacts include `03_catalog.txt`
- **Format**: `<schema>.<table>.<column> -- <foreign key name>`
- **Status**: Parse catalog to know which columns are user FKs

---

### Required Changes

#### Change 1: Investigate INSERT Transformation Injection
**Action**: RESEARCH REQUIRED
**Question**: How does `full-export --enable-uat-users` inject transformation map into INSERT generation?

**Hypothesis**:
- `FullExportPipeline` passes transformation context to `DynamicEntityInsertGenerator`
- Generator applies transformations in-memory during row emission

**Investigation Steps**:
1. Search for `--enable-uat-users` flag handling in `FullExportCommand`
2. Trace how transformation map flows from UAT-users pipeline to INSERT generator
3. Identify insertion point in `DynamicEntityInsertGenerator` where values are transformed

**File to Examine**:
- `src/Osm.Pipeline/Orchestration/FullExportPipeline.cs`
- `src/Osm.Emission/DynamicData/DynamicEntityInsertGenerator.cs`

**Expected Finding**:
```csharp
// DynamicEntityInsertGenerator.cs (hypothetical)
private readonly IReadOnlyDictionary<UserIdentifier, UserIdentifier>? _transformationMap;
private readonly IReadOnlySet<string>? _userFkColumns;

private object TransformValue(string columnName, object value)
{
    if (_userFkColumns != null &&
        _userFkColumns.Contains(columnName) &&
        value != null &&
        _transformationMap != null &&
        _transformationMap.TryGetValue(new UserIdentifier(value), out var target))
    {
        return target.Value;
    }
    return value;
}
```

**Deliverable**: Document how transformations are injected and where verification should hook in

---

#### Change 2: Create InsertScriptParser
**File**: `src/Osm.Pipeline/UatUsers/Verification/InsertScriptParser.cs` (NEW)

**Signature**:
```csharp
public sealed class InsertScriptParser
{
    public ParsedInsertScript Parse(string insertScriptPath, string tableName)
    {
        // Parse SQL INSERT ... VALUES blocks
        // Extract column names and values
        // Return structured representation
    }
}

public sealed record ParsedInsertScript(
    string TableName,
    ImmutableArray<string> Columns,
    ImmutableArray<InsertRow> Rows);

public sealed record InsertRow(
    ImmutableDictionary<string, object?> Values);
```

**Pattern to Parse**:
```sql
-- Target format from DynamicEntityInsertGenerator:
INSERT INTO [dbo].[Order] ([Id], [ProductId], [CreatedBy], [Amount])
VALUES
  (1, 100, 200, 50.00),  -- CreatedBy: 999‚Üí200 (transformed)
  (2, 101, 201, 75.00),  -- CreatedBy: 111‚Üí201 (transformed)
  (3, 102, NULL, 25.00); -- CreatedBy: NULL (preserved)
```

**Parsing Approach**:
1. Use regex to extract column list: `INSERT INTO \[.*\] \((.*?)\)`
2. Use regex to extract VALUES blocks: `VALUES\s+(.*?);` (handle multi-line)
3. Parse each row: split by `,` respecting parentheses
4. Handle NULL, numeric, string, GUID literals

**Complexity**: Medium - SQL parsing is complex, but INSERT format is regular
**Recommendation**: Use simple regex for MVP; full SQL parser for production

**Alternative**: Use SQL Server SMO or parser library if regex proves fragile

---

#### Change 3: Create InsertTransformationVerifier
**File**: `src/Osm.Pipeline/UatUsers/Verification/InsertTransformationVerifier.cs` (NEW)

**Signature**:
```csharp
public sealed class InsertTransformationVerifier
{
    public TransformationApplicationResult Verify(
        string insertScriptPath,
        string tableName,
        IReadOnlyList<string> userFkColumns,
        IReadOnlyDictionary<UserIdentifier, UserIdentifier> transformationMap,
        IReadOnlyCollection<UserIdentifier> orphans)
    {
        // 1. Parse INSERT script
        var parsed = new InsertScriptParser().Parse(insertScriptPath, tableName);

        // 2. For each user FK column, verify transformations
        var columnResults = ImmutableArray.CreateBuilder<ColumnTransformationResult>();
        foreach (var column in userFkColumns)
        {
            var result = VerifyColumn(parsed, column, transformationMap, orphans);
            columnResults.Add(result);
        }

        // 3. Build result
        return new TransformationApplicationResult(...);
    }

    private ColumnTransformationResult VerifyColumn(
        ParsedInsertScript parsed,
        string columnName,
        IReadOnlyDictionary<UserIdentifier, UserIdentifier> transformationMap,
        IReadOnlyCollection<UserIdentifier> orphans)
    {
        var orphansFound = new HashSet<UserIdentifier>();
        var transformations = new Dictionary<UserIdentifier, UserIdentifier>();
        var nullCount = 0;

        foreach (var row in parsed.Rows)
        {
            if (!row.Values.TryGetValue(columnName, out var value))
                continue;

            if (value == null)
            {
                nullCount++;
                continue;
            }

            var userId = new UserIdentifier(value);

            // Check if this should have been transformed
            if (orphans.Contains(userId))
            {
                // This is an orphan - should NOT appear in INSERT script!
                orphansFound.Add(userId);
            }
            else if (transformationMap.ContainsKey(userId))
            {
                // This is a transformed value - record it
                transformations[userId] = transformationMap[userId];
            }
        }

        var orphansRemaining = orphansFound.Count;
        var status = orphansRemaining == 0 ? "PASS" : "FAIL";

        return new ColumnTransformationResult(
            parsed.TableName.Split('.')[0], // schema
            parsed.TableName.Split('.')[1], // table
            columnName,
            orphansFound.ToImmutableArray(),
            transformations.ToImmutableDictionary(),
            nullCount,
            nullsPreserved: true, // Verified by null count > 0
            status);
    }
}
```

**Pattern**:
- Parse INSERT script for table
- Extract values for user FK columns
- **Fail if any orphan IDs found** (transformation not applied!)
- **Pass if all orphan IDs replaced with targets** (transformation applied)
- Count NULLs to verify preservation

---

#### Change 4: Create UpdateScriptSimulator
**File**: `src/Osm.Pipeline/UatUsers/Verification/UpdateScriptSimulator.cs` (NEW)

**Signature**:
```csharp
public sealed class UpdateScriptSimulator
{
    public TransformationApplicationResult Simulate(
        string updateScriptPath,
        IReadOnlyList<UserFkColumn> catalog,
        IReadOnlyDictionary<UserIdentifier, UserIdentifier> transformationMap,
        IReadOnlyCollection<UserIdentifier> orphans)
    {
        // 1. Parse UPDATE script
        var parsed = ParseUpdateScript(updateScriptPath);

        // 2. Verify CASE blocks match transformation map
        var columnResults = ImmutableArray.CreateBuilder<ColumnTransformationResult>();
        foreach (var column in catalog)
        {
            var caseBlock = parsed.GetCaseBlock(column.TableName, column.ColumnName);
            var result = VerifyCaseBlock(column, caseBlock, transformationMap, orphans);
            columnResults.Add(result);
        }

        return new TransformationApplicationResult(...);
    }

    private ColumnTransformationResult VerifyCaseBlock(
        UserFkColumn column,
        ParsedCaseBlock caseBlock,
        IReadOnlyDictionary<UserIdentifier, UserIdentifier> transformationMap,
        IReadOnlyCollection<UserIdentifier> orphans)
    {
        // Verify CASE block contains all orphan‚Üítarget mappings
        var missingMappings = new List<UserIdentifier>();

        foreach (var orphan in orphans)
        {
            if (!caseBlock.Mappings.ContainsKey(orphan))
            {
                missingMappings.Add(orphan);
            }
            else if (caseBlock.Mappings[orphan] != transformationMap[orphan])
            {
                // Mapping exists but wrong target!
                // This is a critical bug
            }
        }

        var status = missingMappings.Count == 0 ? "PASS" : "FAIL";
        return new ColumnTransformationResult(..., status);
    }
}

public sealed record ParsedCaseBlock(
    string TableName,
    string ColumnName,
    ImmutableDictionary<UserIdentifier, UserIdentifier> Mappings);
```

**Pattern to Parse**:
```sql
-- UPDATE block (from SqlScriptEmitter):
UPDATE t
   SET t.[CreatedBy] = CASE t.[CreatedBy]
       WHEN 999 THEN 200  -- Parse these mappings
       WHEN 111 THEN 201
       ELSE t.[CreatedBy]
   END
```

**Parsing Approach**:
- Use regex to extract CASE blocks: `CASE\s+.*?\s+WHEN\s+(\d+)\s+THEN\s+(\d+)`
- Build mapping dictionary from WHEN clauses
- Verify mappings match transformation map

---

#### Change 5: Create NullPreservationVerifier
**File**: `src/Osm.Pipeline/UatUsers/Verification/NullPreservationVerifier.cs` (NEW)

**Signature**:
```csharp
public sealed class NullPreservationVerifier
{
    public NullPreservationResult Verify(
        TransformationMode mode,
        string scriptPath,
        IReadOnlyList<UserFkColumn> catalog)
    {
        if (mode == TransformationMode.Insert)
        {
            return VerifyInsertNulls(scriptPath, catalog);
        }
        else
        {
            return VerifyUpdateNulls(scriptPath, catalog);
        }
    }

    private NullPreservationResult VerifyInsertNulls(
        string scriptPath,
        IReadOnlyList<UserFkColumn> catalog)
    {
        // Parse INSERT script
        // Count NULLs in VALUES blocks
        // Return counts per column
    }

    private NullPreservationResult VerifyUpdateNulls(
        string scriptPath,
        IReadOnlyList<UserFkColumn> catalog)
    {
        // Parse UPDATE script
        // Verify WHERE ... IS NOT NULL guards
        // Proves NULLs are preserved (never updated)
        var hasNullGuards = Regex.IsMatch(
            File.ReadAllText(scriptPath),
            @"WHERE\s+.*?\s+IS\s+NOT\s+NULL",
            RegexOptions.IgnoreCase);

        return new NullPreservationResult(
            isValid: hasNullGuards,
            sourceNullCount: 0, // Not known without DB query
            transformedNullCount: 0, // Assumed same if guards present
            columnsWithNullViolations: ImmutableArray<string>.Empty);
    }
}
```

**Pattern**:
- **INSERT mode**: Count NULL literals in VALUES blocks
- **UPDATE mode**: Verify `WHERE ... IS NOT NULL` guards in UPDATE statements
- Both modes prove NULLs are never transformed

---

#### Change 6: Create CrossModeValidator
**File**: `src/Osm.Pipeline/UatUsers/Verification/CrossModeValidator.cs` (NEW)

**Signature**:
```csharp
public sealed class CrossModeValidator
{
    public CrossModeValidationResult Validate(
        TransformationApplicationResult insertResult,
        TransformationApplicationResult updateResult)
    {
        // Compare transformation results from both modes
        var discrepancies = ImmutableArray.CreateBuilder<string>();

        // 1. Verify same orphan count
        if (insertResult.OrphansEliminated != updateResult.OrphansEliminated)
        {
            discrepancies.Add(
                $"Orphan count mismatch: INSERT={insertResult.OrphansEliminated}, UPDATE={updateResult.OrphansEliminated}");
        }

        // 2. Verify same transformation mappings
        foreach (var insertColumn in insertResult.ColumnResults)
        {
            var updateColumn = updateResult.ColumnResults
                .FirstOrDefault(c => c.Table == insertColumn.Table && c.Column == insertColumn.Column);

            if (updateColumn == null)
            {
                discrepancies.Add($"Column {insertColumn.Table}.{insertColumn.Column} missing in UPDATE mode");
                continue;
            }

            // Compare transformations
            if (!insertColumn.Transformations.SequenceEqual(updateColumn.Transformations))
            {
                discrepancies.Add(
                    $"Transformation mismatch for {insertColumn.Table}.{insertColumn.Column}");
            }
        }

        var isValid = discrepancies.Count == 0;
        return new CrossModeValidationResult(
            isValid,
            transformationsEquivalent: isValid,
            discrepancies.ToImmutable());
    }
}
```

**Pattern**:
- Takes results from both INSERT and UPDATE verifiers
- Compares transformation mappings for equivalence
- Reports discrepancies if modes produce different results

---

#### Change 7: Create TransformationProofGenerator
**File**: `src/Osm.Pipeline/UatUsers/Verification/TransformationProofGenerator.cs` (NEW)

**Signature**:
```csharp
public sealed class TransformationProofGenerator
{
    public TransformationProofReport Generate(
        TransformationVerificationContext context,
        TimeProvider timeProvider)
    {
        var overallStatus = context.IsValid ? "PASS" : "FAIL";
        var timestamp = timeProvider.GetUtcNow();

        var summary = BuildSummary(context);
        var details = BuildDetails(context);
        var discrepancies = BuildDiscrepancies(context);

        return new TransformationProofReport(
            overallStatus,
            context.Mode.ToString().ToLowerInvariant(),
            timestamp,
            summary,
            details,
            discrepancies);
    }
}

public sealed record TransformationProofReport(
    string OverallStatus,
    string Mode,
    DateTimeOffset Timestamp,
    TransformationSummary Summary,
    ImmutableArray<ColumnTransformationDetail> Details,
    ImmutableArray<string> Discrepancies);
```

**Pattern**:
- Follows M2.1 verification report pattern
- Emits JSON via `System.Text.Json`
- Includes summary, per-column details, discrepancies

---

#### Change 8: Add CLI Integration
**File**: `src/Osm.Cli/VerifyTransformationsCommand.cs` (NEW)

**Command**: `verify-transformations`

**Options**:
```csharp
public sealed record VerifyTransformationsOptions
{
    public string Mode { get; init; } // "insert", "update", "dual"
    public string? InsertArtifactRoot { get; init; }
    public string? UpdateScriptPath { get; init; }
    public string TransformationMapPath { get; init; }
    public string FkCatalogPath { get; init; }
    public string VerificationReportOut { get; init; }
}
```

**Usage**:
```bash
# Verify INSERT mode
verify-transformations \
  --mode insert \
  --insert-artifacts ./out/DynamicData \
  --transformation-map ./out/uat-users/00_user_map.csv \
  --fk-catalog ./out/uat-users/03_catalog.txt \
  --verification-report-out ./proof.json

# Verify UPDATE mode
verify-transformations \
  --mode update \
  --update-script ./artifacts/uat-users/02_apply_user_remap.sql \
  --transformation-map ./artifacts/uat-users/00_user_map.csv \
  --fk-catalog ./artifacts/uat-users/03_catalog.txt \
  --verification-report-out ./proof.json

# Verify both (cross-validate)
verify-transformations \
  --mode dual \
  --insert-artifacts ./out/DynamicData \
  --update-script ./artifacts/uat-users/02_apply_user_remap.sql \
  --transformation-map ./out/uat-users/00_user_map.csv \
  --fk-catalog ./out/uat-users/03_catalog.txt \
  --verification-report-out ./proof.json
```

**Pattern**: Similar to `uat-users --verify` from M2.1

---

### Testing Infrastructure

#### Existing Test Pattern - Follow This
- **File**: `tests/Osm.Pipeline.Tests/UatUsers/SqlScriptEmitterTests.cs`
- **Pattern**: Creates test data, generates SQL, verifies output
- **Fixtures**: Known transformation maps, sample data

#### New Test Files to Create

1. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/InsertScriptParserTests.cs`**
   - Test: Parse simple INSERT with single row
   - Test: Parse INSERT with multiple rows
   - Test: Parse INSERT with NULLs
   - Test: Parse INSERT with GUID values
   - Test: Handle malformed SQL gracefully

2. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/InsertTransformationVerifierTests.cs`**
   - Test: All orphans eliminated ‚Üí PASS
   - Test: Orphans remain in INSERTs ‚Üí FAIL
   - Test: NULLs preserved ‚Üí PASS
   - Test: Transformations match map ‚Üí PASS

3. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/UpdateScriptSimulatorTests.cs`**
   - Test: CASE blocks match transformation map ‚Üí PASS
   - Test: Missing mappings in CASE ‚Üí FAIL
   - Test: Wrong target in CASE ‚Üí FAIL

4. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/NullPreservationVerifierTests.cs`**
   - Test: INSERT mode with NULLs ‚Üí PASS
   - Test: UPDATE mode with NULL guards ‚Üí PASS
   - Test: UPDATE mode missing NULL guards ‚Üí FAIL

5. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/CrossModeValidatorTests.cs`**
   - Test: Equivalent transformations ‚Üí PASS
   - Test: Different orphan counts ‚Üí FAIL
   - Test: Different mappings ‚Üí FAIL

6. **`tests/Osm.Cli.Tests/Commands/VerifyTransformationsCommandTests.cs`**
   - Test: INSERT mode verification
   - Test: UPDATE mode verification
   - Test: Dual mode cross-validation
   - Test: Exit codes (0 for pass, 1 for fail)

---

### Critical Questions to Resolve Before Implementation

#### 1. **INSERT Transformation Injection Point** (RESEARCH REQUIRED)
   - ‚ùì **How does full-export inject transformation map into INSERT generation?**
   - ‚ùì Where in the code is the transformation applied?
   - ‚ùì Is there existing verification we can leverage?
   - **Action**: Investigate codebase before implementing INSERT verifier

#### 2. **SQL Parsing Complexity**
   - ‚ùì Use regex or full SQL parser?
   - ‚ùì What if operators manually edit SQL scripts?
   - **Recommendation**: Regex for MVP, document limitations

#### 3. **Live Database Verification**
   - ‚ùì Should M2.2 include live DB verification (execute UPDATE, verify results)?
   - ‚ùì Or defer to M3.2 (load harness)?
   - **Recommendation**: Defer to M3.2 - keep M2.2 static analysis only

#### 4. **Non-Transformed Column Verification**
   - ‚ùì How to integrate with M1.8 checksums?
   - ‚ùì Should we verify non-user-FK columns are unchanged?
   - **Recommendation**: Yes - reuse M1.8 patterns for data fidelity proof

---

### File Location Quick Reference

**Existing Files to Investigate**:
```
src/Osm.Pipeline/Orchestration/
  ‚îî‚îÄ FullExportPipeline.cs (how UAT-users integrates)

src/Osm.Emission/DynamicData/
  ‚îî‚îÄ DynamicEntityInsertGenerator.cs (WHERE ARE TRANSFORMATIONS APPLIED?)

src/Osm.Pipeline/UatUsers/
  ‚îú‚îÄ SqlScriptEmitter.cs (UPDATE script pattern)
  ‚îî‚îÄ UserMapLoader.cs (load transformation map)
```

**New Files to Create**:
```
src/Osm.Pipeline/UatUsers/Verification/
  ‚îú‚îÄ TransformationVerificationContext.cs (aggregates results)
  ‚îú‚îÄ TransformationApplicationResult.cs (transformation results)
  ‚îú‚îÄ NullPreservationResult.cs (NULL preservation proof)
  ‚îú‚îÄ CrossModeValidationResult.cs (mode equivalence)
  ‚îú‚îÄ InsertScriptParser.cs (parses INSERT statements)
  ‚îú‚îÄ InsertTransformationVerifier.cs (verifies INSERT transformations)
  ‚îú‚îÄ UpdateScriptSimulator.cs (simulates UPDATE execution)
  ‚îú‚îÄ NullPreservationVerifier.cs (proves NULL preservation)
  ‚îú‚îÄ CrossModeValidator.cs (cross-validates modes)
  ‚îî‚îÄ TransformationProofGenerator.cs (proof report generator)

src/Osm.Cli/
  ‚îî‚îÄ VerifyTransformationsCommand.cs (NEW CLI command)

tests/Osm.Pipeline.Tests/UatUsers/Verification/
  ‚îú‚îÄ InsertScriptParserTests.cs
  ‚îú‚îÄ InsertTransformationVerifierTests.cs
  ‚îú‚îÄ UpdateScriptSimulatorTests.cs
  ‚îú‚îÄ NullPreservationVerifierTests.cs
  ‚îú‚îÄ CrossModeValidatorTests.cs
  ‚îî‚îÄ TransformationProofGeneratorTests.cs

tests/Osm.Cli.Tests/Commands/
  ‚îî‚îÄ VerifyTransformationsCommandTests.cs
```

---

## Implementation Details

### Phase 0: Research INSERT Transformation Injection (0.5 days)

**CRITICAL FIRST STEP**: Understand how transformations flow into INSERT generation

1. Trace `--enable-uat-users` flag handling in `FullExportCommand`
2. Find where transformation map is passed to `DynamicEntityInsertGenerator`
3. Identify transformation injection point (where values are transformed)
4. Document findings and update spec if necessary

**Deliverable**: Research report with file paths, line numbers, code snippets showing transformation flow

---

### Phase 1: Core Verification Models (0.5 days)

Create data models:
1. `TransformationVerificationContext.cs`
2. `TransformationApplicationResult.cs`
3. `NullPreservationResult.cs`
4. `CrossModeValidationResult.cs`

**Pattern**: Follow record structure defined in Architecture section

---

### Phase 2: INSERT Verification (1 day)

Implement INSERT verification pipeline:

**Step 1**: `InsertScriptParser.cs`
- Parse INSERT ... VALUES blocks
- Extract column values
- Handle NULL, numeric, string, GUID literals
- Add tests in `InsertScriptParserTests.cs`

**Step 2**: `InsertTransformationVerifier.cs`
- Use parser to extract user FK values
- Verify orphans eliminated
- Count NULLs
- Add tests in `InsertTransformationVerifierTests.cs`

---

### Phase 3: UPDATE Verification (1 day)

Implement UPDATE verification pipeline:

**Step 1**: `UpdateScriptSimulator.cs`
- Parse UPDATE CASE blocks
- Extract transformation mappings
- Verify against transformation map
- Add tests in `UpdateScriptSimulatorTests.cs`

**Step 2**: `NullPreservationVerifier.cs`
- Verify NULL guards in UPDATE statements
- Count NULLs in INSERT scripts
- Add tests in `NullPreservationVerifierTests.cs`

---

### Phase 4: Cross-Mode Validation (0.5 days)

Implement `CrossModeValidator.cs`:
- Compare INSERT vs UPDATE results
- Verify transformation equivalence
- Add tests in `CrossModeValidatorTests.cs`

---

### Phase 5: Report Generation (0.5 days)

Implement `TransformationProofGenerator.cs`:
- Build JSON proof report
- Follow M2.1 pattern
- Add tests in `TransformationProofGeneratorTests.cs`

---

### Phase 6: CLI Integration (0.5 days)

Create `VerifyTransformationsCommand.cs`:
- Handle `--mode` flag (insert, update, dual)
- Wire up verifiers
- Emit report
- Return exit codes
- Add tests in `VerifyTransformationsCommandTests.cs`

---

## Test Scenarios

### Scenario 1: INSERT Transformations Applied (Happy Path)
**Given**:
- INSERT scripts with all orphans replaced by targets
- NULLs preserved

**When**: Run verification in INSERT mode

**Expected**:
- `overallStatus`: "PASS"
- `orphansRemaining`: 0
- `nullsPreserved`: true

---

### Scenario 2: INSERT Orphans Remain (Transformation Bug)
**Given**:
- INSERT scripts contain orphan ID 999 (should be 200)

**When**: Run verification in INSERT mode

**Expected**:
- `overallStatus`: "FAIL"
- `orphansRemaining`: 1
- `discrepancies`: ["Orphan 999 found in dbo.Order.CreatedBy"]

---

### Scenario 3: UPDATE CASE Blocks Correct
**Given**:
- UPDATE script with complete CASE blocks matching transformation map

**When**: Run verification in UPDATE mode

**Expected**:
- `overallStatus`: "PASS"
- All mappings verified

---

### Scenario 4: UPDATE Missing Mappings
**Given**:
- UPDATE script CASE block missing orphan 111

**When**: Run verification in UPDATE mode

**Expected**:
- `overallStatus`: "FAIL"
- `discrepancies`: ["Missing mapping for orphan 111 in dbo.Order.CreatedBy"]

---

### Scenario 5: Cross-Mode Equivalence
**Given**:
- INSERT and UPDATE scripts for same transformation

**When**: Run verification in dual mode

**Expected**:
- `overallStatus`: "PASS"
- `modeEquivalence`: "PASS"
- Both modes produce identical transformation results

---

### Scenario 6: NULL Preservation
**Given**:
- Source data has 5 NULLs in CreatedBy
- INSERT script has 5 NULL literals
- UPDATE script has `WHERE ... IS NOT NULL`

**When**: Run NULL preservation verifier

**Expected**:
- `nullPreservation`: "PASS"
- `nullsPreserved`: true

---

## Migration Path

### Non-Breaking Changes
- M2.2 adds verification capability; doesn't modify existing pipeline
- New CLI command; existing commands unaffected
- Verification is opt-in

### Rollout Strategy

**Phase 1**: Research INSERT transformation injection (before implementation)
**Phase 2**: Deploy INSERT/UPDATE verifiers
**Phase 3**: Add to CI/CD as quality gate
**Phase 4**: Integrate with M3.2 load harness (live DB verification)

### Backward Compatibility
- 100% backward compatible
- New CLI command; existing behavior unchanged

---

## Success Metrics

M2.2 is successful if:

‚úÖ Can verify INSERT scripts eliminate all orphans (no orphan IDs in VALUES)

‚úÖ Can verify UPDATE scripts contain correct CASE mappings

‚úÖ Can prove NULL preservation in both modes

‚úÖ Can cross-validate INSERT and UPDATE modes produce identical results

‚úÖ CI/CD can gate deployments on transformation correctness

‚úÖ All test scenarios pass

‚úÖ Verification completes in <10 seconds

‚úÖ Zero false positives/negatives

---

*Generated: 2025-11-19*
*Status: Ready for implementation (pending Phase 0 research)*
*Follows M1.* and M2.1 spec patterns with comprehensive codebase integration guide*
