# M2.1: UAT-Users Verification Framework

**Status**: READY FOR IMPLEMENTATION
**Dependencies**: M1.1 (Export Verification Framework), Existing UAT-Users Pipeline
**Priority**: üî¥ MVP (ship alongside UAT-users adoption)

---

## Executive Summary

### The Specific Problem

The UAT-users pipeline generates transformation artifacts (user mapping CSV, UPDATE scripts, FK catalog, preview report), but **there is no automated verification system to validate these artifacts**. This creates risks:

- **No Completeness Check**: Can't verify all orphan users have valid mappings before deployment
- **Invalid Target IDs**: Transformation map may reference UAT user IDs that don't exist in UAT inventory
- **Incomplete FK Catalog**: May miss user-referencing foreign key columns, leading to untransformed data
- **Unsafe SQL**: Generated UPDATE scripts may lack NULL guards or idempotence checks, risking data corruption
- **Manual Inspection**: Operators must manually review `01_preview.csv`, which is error-prone and doesn't scale

**Example**: Transformation map references non-existent UAT user ID 999. No validation catches this. Deploy UPDATE script ‚Üí foreign key violation in production UAT database.

### Recommended Solution

**UAT-Users Artifact Verification Framework**

Implement automated post-generation verification for UAT-users artifacts:

1. **Transformation Map Validation**: Verify every orphan has a mapping, no duplicates, all targets exist in UAT inventory
2. **FK Catalog Completeness**: Cross-reference discovered FK columns against model metadata, detect missing columns
3. **SQL Safety Analysis**: Parse generated UPDATE scripts, verify NULL guards, idempotence patterns, and target sanity checks present
4. **Verification Report**: Generate `uat-users-verification.json` with pass/fail status and detailed discrepancies

This runs as a post-generation step after UAT-users pipeline completes, extending M1.1's verification pattern to transformation-specific concerns.

### How It Fixes the Problem

1. **Automated Validation**: No manual CSV inspection, verification runs automatically
2. **Early Detection**: Catches invalid mappings before deployment, not during
3. **CI/CD Integration**: Machine-readable report enables automated gates
4. **SQL Safety**: Proves UPDATE scripts have required guards (NULL checks, idempotence)
5. **Audit Trail**: Structured report provides evidence of transformation correctness

### Alternative Approaches Considered

**Alternative 1: No Verification (Trust Pipeline)**
- Assume UAT-users pipeline always generates valid artifacts
- **Rejected**: Risky (manual mapping errors common), silent failures possible, no audit trail

**Alternative 2: Database Execution Validation**
- Apply UPDATE scripts to test database, catch errors there
- **Rejected**: Too slow (requires test database), doesn't validate artifacts themselves, that's M2.3's domain

**Alternative 3: Inline Validation Only**
- Keep existing `ValidateUserMapStep` validation during pipeline, skip post-generation checks
- **Rejected**: Doesn't validate emitted SQL scripts, no machine-readable report for CI/CD

**Alternative 4: Manual Code Review**
- Require human review of generated UPDATE scripts before deployment
- **Rejected**: Doesn't scale, error-prone, slows deployment, can't integrate with automation

**Alternative 5: Sample-Based Validation**
- Check random subset of mappings instead of all
- **Rejected**: May miss invalid mappings in unsampled portion, completeness check is fast enough

**Why Artifact Verification Wins**: Automated, fast (file-based validation), catches 90% of transformation errors before deployment, integrates with CI/CD, provides audit trail.

### MVP Scope (M2.1)

**Ship This First**:
- ‚úÖ Transformation map validator (completeness, duplicates, UAT compliance)
- ‚úÖ FK catalog completeness checker (compares discovered catalog vs model metadata)
- ‚úÖ SQL safety analyzer (parses generated UPDATE scripts for required guards)
- ‚úÖ Verification report generator (JSON output matching M1.1 pattern)
- ‚úÖ CLI integration (`--verify` flag for `uat-users` verb)

**Defer to Later**:
- üîµ Integration with full-export verification (M3.1)
- üîµ Load harness verification (M3.2)
- üîµ Historical trend analysis (M4.1)

### Key Findings

**Already Exists** ‚úÖ:
- `ValidateUserMapStep.cs` (validates map during pipeline execution)
- `DiscoverUserFkCatalogStep.cs` (FK catalog discovery)
- `UatUsersArtifacts.cs` (artifact emission patterns)
- `SqlScriptEmitter.cs` (UPDATE script generation with guards)

**Missing** ‚ùå:
- Post-generation verification layer (validates artifacts AFTER emission)
- Machine-readable verification report (JSON format for automation)
- Verification context model (captures validation results)
- CLI integration for standalone verification

---

## Critical Path Analysis

### Why This Matters

**Without verification**:
- Operators manually inspect CSV files (error-prone)
- CI/CD cannot gate UAT deployments on transformation validity
- Silent failures possible (missing FKs, invalid targets, unsafe SQL)
- No audit trail for transformation correctness

**With verification**:
- Automated validation gates CI/CD pipelines
- Machine-readable reports enable automation
- Catch errors before deployment (not during)
- Audit-friendly proof artifacts

### Timeline Considerations

- M2.1 should ship **before** UAT-users sees production adoption
- Blocks M3.1 (manifest integration) and M3.2 (load harness verification)
- Can develop in parallel with M1.x (no dependencies beyond M1.1 patterns)

### Dependencies and Parallelization

**Depends On**:
- M1.1 (verification report pattern, CLI integration pattern)

**Enables**:
- M2.2 (transformation verification - builds on this)
- M2.3 (integration tests - uses verification as oracle)
- M3.1 (manifest integration - embeds verification results)

**Can Parallel With**:
- M1.7, M1.8 (different domains)

---

## Problem Statement

### Current Behavior

When `uat-users` runs, it:
1. Discovers FK catalog from model
2. Loads QA + UAT inventories
3. Discovers orphans (QA users not in UAT)
4. Validates user map (during `ValidateUserMapStep`)
5. Emits artifacts (`00_user_map.csv`, `01_preview.csv`, `02_apply_user_remap.sql`, etc.)

**Validation happens during pipeline execution** (step 4), but **after artifacts are emitted**, there's no way to verify they're correct without manually inspecting files.

### Desired State

**Post-generation verification**:
```bash
# Generate artifacts
dotnet run --project src/Osm.Cli -- uat-users \
  --model ./model.json \
  --connection-string "..." \
  --uat-user-inventory ./uat_users.csv \
  --qa-user-inventory ./qa_users.csv \
  --out ./artifacts

# Verify artifacts (new capability)
dotnet run --project src/Osm.Cli -- uat-users \
  --verify ./artifacts/uat-users \
  --verification-report-out ./verification-report.json
```

**Verification report**:
```json
{
  "overallStatus": "PASS",
  "timestamp": "2025-11-19T10:00:00Z",
  "verifications": {
    "transformationMapCompleteness": "PASS",
    "fkCatalogCompleteness": "PASS",
    "uatInventoryCompliance": "PASS",
    "sqlSafety": "PASS"
  },
  "details": {
    "orphanCount": 15,
    "mappedCount": 15,
    "unmappedCount": 0,
    "fkCatalogSize": 23,
    "uatInventorySize": 500,
    "invalidTargets": []
  },
  "discrepancies": []
}
```

### Gap Analysis

| Capability | Current State | Desired State | Gap |
|------------|---------------|---------------|-----|
| Map validation | During pipeline only | Post-generation verification | Need standalone verifier |
| FK catalog check | Discovery only | Completeness verification | Need catalog validator |
| Report format | Console logs | Machine-readable JSON | Need report generator |
| CLI integration | N/A | `--verify` flag | Need CLI plumbing |
| Automation support | Manual inspection | CI/CD gate | Need exit codes |

---

## Architecture

### Component Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                   UAT-Users Verification                     ‚îÇ
‚îÇ                     (M2.1 - New Layer)                       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ TransformationMapVerifier
                              ‚îÇ   - Validates map completeness
                              ‚îÇ   - Checks for duplicates
                              ‚îÇ   - Verifies UAT compliance
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ FkCatalogCompletenessVerifier
                              ‚îÇ   - Compares catalog vs model
                              ‚îÇ   - Identifies missing FKs
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ SqlSafetyAnalyzer
                              ‚îÇ   - Parses UPDATE scripts
                              ‚îÇ   - Verifies NULL guards
                              ‚îÇ   - Checks idempotence patterns
                              ‚îÇ
                              ‚îî‚îÄ‚ñ∫ VerificationReportGenerator
                                  - Emits JSON report
                                  - Follows M1.1 pattern

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ            Existing UAT-Users Pipeline (Leverage)            ‚îÇ
‚îÇ          src/Osm.Pipeline/UatUsers/* (already exists)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                              ‚îú‚îÄ‚ñ∫ UatUsersPipeline (orchestrator)
                              ‚îú‚îÄ‚ñ∫ ValidateUserMapStep (reuse logic)
                              ‚îú‚îÄ‚ñ∫ DiscoverUserFkCatalogStep (reuse logic)
                              ‚îú‚îÄ‚ñ∫ SqlScriptEmitter (reuse patterns)
                              ‚îî‚îÄ‚ñ∫ UatUsersArtifacts (artifact paths)
```

### Data Models

#### UatUsersVerificationContext.cs (NEW)
```csharp
public sealed record UatUsersVerificationContext(
    string ArtifactRoot,
    UserMapVerificationResult MapVerification,
    FkCatalogVerificationResult CatalogVerification,
    SqlSafetyVerificationResult SqlSafety,
    UatInventoryComplianceResult InventoryCompliance)
{
    public bool IsValid =>
        MapVerification.IsValid &&
        CatalogVerification.IsValid &&
        SqlSafety.IsValid &&
        InventoryCompliance.IsValid;
}
```

#### UserMapVerificationResult.cs (NEW)
```csharp
public sealed record UserMapVerificationResult(
    bool IsValid,
    int OrphanCount,
    int MappedCount,
    int UnmappedCount,
    ImmutableArray<UserIdentifier> DuplicateSources,
    ImmutableArray<UserIdentifier> MissingSources,
    ImmutableArray<UserIdentifier> InvalidTargets);
```

#### FkCatalogVerificationResult.cs (NEW)
```csharp
public sealed record FkCatalogVerificationResult(
    bool IsValid,
    int DiscoveredColumnCount,
    int ExpectedColumnCount,
    ImmutableArray<string> MissingColumns);
```

#### SqlSafetyVerificationResult.cs (NEW)
```csharp
public sealed record SqlSafetyVerificationResult(
    bool IsValid,
    bool HasNullGuards,
    bool HasTargetSanityCheck,
    bool HasIdempotenceGuard,
    ImmutableArray<string> MissingGuards);
```

#### UatUsersVerificationReport.cs (NEW)
```csharp
public sealed record UatUsersVerificationReport(
    string OverallStatus,
    DateTimeOffset Timestamp,
    UatUsersVerificationContext Context,
    ImmutableArray<string> Discrepancies);
```

---

## Codebase Integration Guide ‚≠ê

### Existing Infrastructure (Leverage These)

#### ‚úÖ **Validation Logic** - Already Implemented (Reuse Patterns)
- **File**: `src/Osm.Pipeline/UatUsers/Steps/ValidateUserMapStep.cs` (103 lines)
- **Method**: `ExecuteAsync()` (lines 22-96)
- **Status**: Complete - reuse validation logic for standalone verifier
- **Key Logic**:
  ```csharp
  // Duplicate source detection (lines 30, 40-43)
  var seenSources = new HashSet<UserIdentifier>();
  if (!seenSources.Add(entry.SourceUserId)) {
      errors.Add($"Duplicate SourceUserId '{entry.SourceUserId}'...");
  }

  // QA inventory check (lines 45-48)
  if (!context.TryGetQaUser(entry.SourceUserId, out _)) {
      errors.Add($"SourceUserId '{entry.SourceUserId}' not in QA inventory.");
  }

  // Orphan validation (lines 50-53)
  if (!context.IsOrphan(entry.SourceUserId)) {
      errors.Add($"SourceUserId '{entry.SourceUserId}' not in orphan set.");
  }

  // UAT compliance (lines 61-64)
  if (!context.IsAllowedUser(entry.TargetUserId.Value)) {
      errors.Add($"TargetUserId '{entry.TargetUserId}' not in UAT inventory.");
  }
  ```

#### ‚úÖ **FK Catalog Discovery** - Already Implemented (Reuse Pattern)
- **File**: `src/Osm.Pipeline/UatUsers/Steps/DiscoverUserFkCatalogStep.cs`
- **Method**: `ExecuteAsync()`
- **Status**: Complete - use for expected catalog calculation
- **Usage**: Standalone verifier can run discovery against model to get expected catalog

#### ‚úÖ **SQL Script Generation** - Already Implemented (Pattern to Verify)
- **File**: `src/Osm.Pipeline/UatUsers/SqlScriptEmitter.cs` (344 lines)
- **Method**: `BuildScript()` (lines 12-102)
- **Status**: Complete - verification should parse output
- **Key Guards to Verify**:
  ```csharp
  // NULL guard (line 118)
  WHERE t.{quotedColumn} IS NOT NULL

  // Idempotence guard (line 119)
  AND t.{quotedColumn} <> r.TargetUserId

  // Target sanity check (lines 142-158)
  IF EXISTS (SELECT 1 FROM #UserRemap AS r
             LEFT JOIN {userTable} AS u ON u.Id = r.TargetUserId
             WHERE u.Id IS NULL)
  BEGIN
      THROW 51000, 'Target user IDs missing...', 1;
  END;
  ```

#### ‚úÖ **Artifact Paths** - Already Implemented (Reuse)
- **File**: `src/Osm.Pipeline/UatUsers/UatUsersArtifacts.cs` (130 lines)
- **Method**: `GetDefaultUserMapPath()` (lines 28-31)
- **Status**: Complete - use for artifact discovery
- **Pattern**: Artifacts written to `{outputDirectory}/uat-users/`

#### ‚úÖ **User Inventories** - Already Loaded (Reuse Loaders)
- **File**: `src/Osm.Pipeline/UatUsers/UserInventoryLoader.cs`
- **Method**: `LoadFromCsv()`
- **Status**: Complete - use for UAT inventory compliance checks

#### ‚úÖ **Verification Report Pattern** - Already Established (Follow This)
- **File**: `src/Osm.Pipeline/Verification/ExportVerificationReport.cs` (from M1.1)
- **Status**: Template to follow for UAT-users verification report
- **Pattern**: JSON with `overallStatus`, `timestamp`, `verifications`, `discrepancies`

---

### Required Changes

#### Change 1: Create Verification Directory
**Location**: `src/Osm.Pipeline/UatUsers/Verification/` (NEW DIRECTORY)

**Files to Create**:
1. `UatUsersVerificationContext.cs` - Aggregates all verification results
2. `UserMapVerificationResult.cs` - Map validation result
3. `FkCatalogVerificationResult.cs` - Catalog completeness result
4. `SqlSafetyVerificationResult.cs` - SQL safety checks result
5. `UatInventoryComplianceResult.cs` - UAT inventory compliance result
6. `UatUsersVerificationReport.cs` - Final JSON report model

**Pattern**: Follow data model structure defined in Architecture section above

---

#### Change 2: Create TransformationMapVerifier
**File**: `src/Osm.Pipeline/UatUsers/Verification/TransformationMapVerifier.cs` (NEW)

**Signature**:
```csharp
public sealed class TransformationMapVerifier
{
    public UserMapVerificationResult Verify(
        IReadOnlyList<UserMappingEntry> userMap,
        IReadOnlyCollection<UserIdentifier> orphans,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> qaInventory,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> uatInventory)
    {
        // Reuse logic from ValidateUserMapStep.cs
    }
}
```

**Pattern to Follow**:
- Extract validation logic from `ValidateUserMapStep.cs` (lines 29-76)
- Return `UserMapVerificationResult` instead of throwing exceptions
- Collect all errors instead of failing fast

**Dependencies**:
- Reuses `UserMappingEntry`, `UserIdentifier`, `UserInventoryRecord` from existing infrastructure

---

#### Change 3: Create FkCatalogCompletenessVerifier
**File**: `src/Osm.Pipeline/UatUsers/Verification/FkCatalogCompletenessVerifier.cs` (NEW)

**Signature**:
```csharp
public sealed class FkCatalogCompletenessVerifier
{
    public FkCatalogVerificationResult Verify(
        IReadOnlyList<UserFkColumn> discoveredCatalog,
        IUserSchemaGraph schemaGraph)
    {
        // Compare discovered catalog against expected columns from schema graph
    }
}
```

**Pattern to Follow**:
- Use `ModelUserSchemaGraphFactory.Create()` to build expected catalog
- Compare discovered catalog (from artifacts) against expected catalog (from model)
- Report missing columns (expected but not discovered)
- Report unexpected columns (discovered but not in model - warning only)

**Integration Point**:
- `ModelUserSchemaGraphFactory` exists in `src/Osm.Pipeline/UatUsers/ModelUserSchemaGraphFactory.cs`
- Reuse `IUserSchemaGraph` interface

---

#### Change 4: Create SqlSafetyAnalyzer
**File**: `src/Osm.Pipeline/UatUsers/Verification/SqlSafetyAnalyzer.cs` (NEW)

**Signature**:
```csharp
public sealed class SqlSafetyAnalyzer
{
    public SqlSafetyVerificationResult Verify(string sqlScriptPath)
    {
        // Parse SQL script and verify required guards are present
    }
}
```

**Required Checks**:
1. **NULL Guard**: Every UPDATE block must have `WHERE {column} IS NOT NULL`
2. **Idempotence Guard**: Every UPDATE must have `WHERE {column} <> r.TargetUserId`
3. **Target Sanity Check**: Script must have `IF EXISTS (... LEFT JOIN ... WHERE ... IS NULL) THROW`
4. **Temp Table Creation**: Must create `#UserRemap` and `#Changes`

**Pattern to Follow**:
- Read SQL script from disk (path from `UatUsersArtifacts`)
- Use regex or simple string matching to verify guards
- Return result with boolean flags + list of missing guards

**Example Verification**:
```csharp
var sqlContent = File.ReadAllText(sqlScriptPath);

var hasNullGuards = Regex.IsMatch(
    sqlContent,
    @"WHERE\s+t\.\[?\w+\]?\s+IS\s+NOT\s+NULL",
    RegexOptions.IgnoreCase);

var hasIdempotenceGuard = Regex.IsMatch(
    sqlContent,
    @"WHERE.*<>\s*r\.TargetUserId",
    RegexOptions.IgnoreCase);

var hasTargetSanityCheck = sqlContent.Contains("THROW 51000", StringComparison.OrdinalIgnoreCase);
```

---

#### Change 5: Create UatUsersVerifier (Orchestrator)
**File**: `src/Osm.Pipeline/UatUsers/Verification/UatUsersVerifier.cs` (NEW)

**Signature**:
```csharp
public sealed class UatUsersVerifier
{
    private readonly TransformationMapVerifier _mapVerifier;
    private readonly FkCatalogCompletenessVerifier _catalogVerifier;
    private readonly SqlSafetyAnalyzer _sqlAnalyzer;

    public UatUsersVerifier(
        TransformationMapVerifier mapVerifier,
        FkCatalogCompletenessVerifier catalogVerifier,
        SqlSafetyAnalyzer sqlAnalyzer)
    {
        _mapVerifier = mapVerifier;
        _catalogVerifier = catalogVerifier;
        _sqlAnalyzer = sqlAnalyzer;
    }

    public async Task<UatUsersVerificationContext> VerifyAsync(
        string artifactRoot,
        IUserSchemaGraph schemaGraph,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> qaInventory,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> uatInventory,
        CancellationToken cancellationToken = default)
    {
        // 1. Load artifacts from disk
        var userMap = LoadUserMap(artifactRoot);
        var catalog = LoadCatalog(artifactRoot);
        var orphans = DiscoverOrphans(qaInventory, uatInventory);

        // 2. Run verifiers
        var mapResult = _mapVerifier.Verify(userMap, orphans, qaInventory, uatInventory);
        var catalogResult = _catalogVerifier.Verify(catalog, schemaGraph);
        var sqlResult = _sqlAnalyzer.Verify(Path.Combine(artifactRoot, "02_apply_user_remap.sql"));

        // 3. Build context
        return new UatUsersVerificationContext(
            artifactRoot,
            mapResult,
            catalogResult,
            sqlResult,
            inventoryCompliance);
    }

    private IReadOnlyList<UserMappingEntry> LoadUserMap(string artifactRoot)
    {
        var mapPath = Path.Combine(artifactRoot, "00_user_map.csv");
        return UserMapLoader.LoadFromCsv(mapPath, includeRationale: true);
    }

    private IReadOnlyList<UserFkColumn> LoadCatalog(string artifactRoot)
    {
        var catalogPath = Path.Combine(artifactRoot, "03_catalog.txt");
        // Parse catalog.txt: "<schema>.<table>.<column> -- <fk name>"
        var lines = File.ReadAllLines(catalogPath);
        return lines.Select(ParseCatalogLine).ToList();
    }
}
```

**Pattern to Follow**:
- Orchestrates all verifiers
- Loads artifacts from disk (user map, catalog, SQL script)
- Reuses existing loaders where possible (`UserMapLoader`, `UserInventoryLoader`)
- Returns aggregated verification context

---

#### Change 6: Create UatUsersVerificationReportGenerator
**File**: `src/Osm.Pipeline/UatUsers/Verification/UatUsersVerificationReportGenerator.cs` (NEW)

**Signature**:
```csharp
public sealed class UatUsersVerificationReportGenerator
{
    public UatUsersVerificationReport Generate(
        UatUsersVerificationContext context,
        TimeProvider timeProvider)
    {
        var overallStatus = context.IsValid ? "PASS" : "FAIL";
        var timestamp = timeProvider.GetUtcNow();

        var discrepancies = BuildDiscrepancies(context);

        return new UatUsersVerificationReport(
            overallStatus,
            timestamp,
            context,
            discrepancies);
    }

    private ImmutableArray<string> BuildDiscrepancies(UatUsersVerificationContext context)
    {
        var discrepancies = ImmutableArray.CreateBuilder<string>();

        if (!context.MapVerification.IsValid)
        {
            foreach (var dup in context.MapVerification.DuplicateSources)
            {
                discrepancies.Add($"Duplicate source: {dup}");
            }
            foreach (var invalid in context.MapVerification.InvalidTargets)
            {
                discrepancies.Add($"Invalid target: {invalid}");
            }
        }

        // ... similar for other verifications

        return discrepancies.ToImmutable();
    }
}
```

**Pattern to Follow**:
- Follows M1.1 verification report pattern
- Emits JSON via `System.Text.Json`
- Includes human-readable discrepancies array

---

#### Change 7: Add CLI Integration
**File**: `src/Osm.Cli/UatUsersCommand.cs` (MODIFY - existing file)

**Add `--verify` option**:
```csharp
// Existing UatUsersOptions.cs - add properties:
public string? VerifyArtifactRoot { get; init; }
public string? VerificationReportOut { get; init; }

// UatUsersCommand.cs - add flag handling:
if (!string.IsNullOrWhiteSpace(options.VerifyArtifactRoot))
{
    // Run verification mode instead of pipeline mode
    var verifier = new UatUsersVerifier(
        new TransformationMapVerifier(),
        new FkCatalogCompletenessVerifier(),
        new SqlSafetyAnalyzer());

    var context = await verifier.VerifyAsync(
        options.VerifyArtifactRoot,
        schemaGraph,
        qaInventory,
        uatInventory,
        cancellationToken);

    var report = new UatUsersVerificationReportGenerator()
        .Generate(context, timeProvider);

    // Write report
    var reportPath = options.VerificationReportOut ?? "./verification-report.json";
    await File.WriteAllTextAsync(reportPath, JsonSerializer.Serialize(report, ...));

    // Exit with status code
    return context.IsValid ? 0 : 1;
}
```

**Pattern to Follow**:
- Similar to how `full-export` handles verification flags
- Reuse existing DI setup for `UatUsersCommand`
- Return exit code 0 (pass) or 1 (fail) for CI/CD gating

---

### Testing Infrastructure

#### Existing Test Pattern - Follow This
- **File**: `tests/Osm.Pipeline.Tests/UatUsers/ValidateUserMapStepTests.cs`
- **Pattern**: Uses mock inventories, creates test `UatUsersContext`
- **Fixtures**: CSV files with known good/bad data

#### New Test Files to Create

1. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/TransformationMapVerifierTests.cs`**
   - Test: All orphans mapped ‚Üí PASS
   - Test: Unmapped orphans ‚Üí FAIL
   - Test: Duplicate sources ‚Üí FAIL
   - Test: Invalid targets (not in UAT inventory) ‚Üí FAIL
   - Test: Source not in QA inventory ‚Üí FAIL

2. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/FkCatalogCompletenessVerifierTests.cs`**
   - Test: Discovered catalog matches expected ‚Üí PASS
   - Test: Missing columns ‚Üí FAIL
   - Test: Unexpected columns (warning only) ‚Üí PASS with warning

3. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/SqlSafetyAnalyzerTests.cs`**
   - Test: SQL with all guards ‚Üí PASS
   - Test: SQL missing NULL guard ‚Üí FAIL
   - Test: SQL missing idempotence guard ‚Üí FAIL
   - Test: SQL missing target sanity check ‚Üí FAIL

4. **`tests/Osm.Pipeline.Tests/UatUsers/Verification/UatUsersVerifierTests.cs`**
   - Test: End-to-end verification with valid artifacts ‚Üí PASS
   - Test: End-to-end verification with invalid artifacts ‚Üí FAIL
   - Test: Report generation includes discrepancies

5. **`tests/Osm.Cli.Tests/Commands/UatUsersCommandVerifyTests.cs`**
   - Test: `--verify` flag triggers verification mode
   - Test: Verification pass ‚Üí exit code 0
   - Test: Verification fail ‚Üí exit code 1
   - Test: Report written to `--verification-report-out`

---

### Critical Questions to Resolve Before Implementation

#### 1. **Catalog Completeness Verification Scope**
   - ‚ùì Should verifier FAIL if unexpected columns are discovered (in catalog but not in model)?
   - ‚ùì Or should unexpected columns be warnings only (model may be stale)?
   - **Recommendation**: Warnings only - catalog discovery is ground truth, model may lag

#### 2. **SQL Safety Verification Depth**
   - ‚ùì Should verifier parse full SQL syntax tree or use regex/string matching?
   - ‚ùì What if SQL script is manually edited by operator?
   - **Recommendation**: Simple string matching for MVP - full parser is overkill

#### 3. **Integration with full-export**
   - ‚ùì Should `full-export --enable-uat-users` run verification automatically?
   - ‚ùì Or require explicit `--verify-uat-users` flag?
   - **Recommendation**: Defer to M3.1 - keep M2.1 focused on standalone verification

#### 4. **Verification Report Location**
   - ‚ùì Where should verification report be written by default?
   - ‚ùì Should it be in `{artifactRoot}/` or separate?
   - **Recommendation**: Default to `{artifactRoot}/uat-users-verification-report.json`

---

### File Location Quick Reference

**Existing Files to Reference** (do not modify, reuse patterns):
```
src/Osm.Pipeline/UatUsers/
  ‚îú‚îÄ Steps/ValidateUserMapStep.cs (validation logic to extract)
  ‚îú‚îÄ Steps/DiscoverUserFkCatalogStep.cs (catalog discovery pattern)
  ‚îú‚îÄ SqlScriptEmitter.cs (SQL generation pattern to verify)
  ‚îú‚îÄ UatUsersArtifacts.cs (artifact path patterns)
  ‚îú‚îÄ UserInventoryLoader.cs (CSV loading pattern)
  ‚îî‚îÄ UserMapLoader.cs (user map loading pattern)

tests/Osm.Pipeline.Tests/UatUsers/
  ‚îú‚îÄ ValidateUserMapStepTests.cs (test pattern to follow)
  ‚îú‚îÄ DiscoverUserFkCatalogStepTests.cs (catalog test pattern)
  ‚îî‚îÄ SqlScriptEmitterTests.cs (SQL generation test pattern)
```

**New Files to Create**:
```
src/Osm.Pipeline/UatUsers/Verification/
  ‚îú‚îÄ UatUsersVerificationContext.cs (aggregates results)
  ‚îú‚îÄ UserMapVerificationResult.cs (map validation result)
  ‚îú‚îÄ FkCatalogVerificationResult.cs (catalog completeness result)
  ‚îú‚îÄ SqlSafetyVerificationResult.cs (SQL safety result)
  ‚îú‚îÄ UatInventoryComplianceResult.cs (inventory compliance result)
  ‚îú‚îÄ UatUsersVerificationReport.cs (final JSON report)
  ‚îú‚îÄ TransformationMapVerifier.cs (map validator)
  ‚îú‚îÄ FkCatalogCompletenessVerifier.cs (catalog validator)
  ‚îú‚îÄ SqlSafetyAnalyzer.cs (SQL parser)
  ‚îú‚îÄ UatUsersVerifier.cs (orchestrator)
  ‚îî‚îÄ UatUsersVerificationReportGenerator.cs (report generator)

tests/Osm.Pipeline.Tests/UatUsers/Verification/
  ‚îú‚îÄ TransformationMapVerifierTests.cs (map validator tests)
  ‚îú‚îÄ FkCatalogCompletenessVerifierTests.cs (catalog tests)
  ‚îú‚îÄ SqlSafetyAnalyzerTests.cs (SQL analyzer tests)
  ‚îú‚îÄ UatUsersVerifierTests.cs (end-to-end tests)
  ‚îî‚îÄ UatUsersVerificationReportGeneratorTests.cs (report tests)

tests/Osm.Cli.Tests/Commands/
  ‚îî‚îÄ UatUsersCommandVerifyTests.cs (CLI integration tests)

src/Osm.Cli/
  ‚îú‚îÄ UatUsersOptions.cs (MODIFY - add VerifyArtifactRoot, VerificationReportOut)
  ‚îî‚îÄ UatUsersCommand.cs (MODIFY - add --verify handling)
```

---

## Implementation Details

### Phase 1: Core Verification Models (0.5 days)

**Create data models** (all records in `src/Osm.Pipeline/UatUsers/Verification/`):

1. `UatUsersVerificationContext.cs` - Aggregates all verification results
2. `UserMapVerificationResult.cs` - Map validation result
3. `FkCatalogVerificationResult.cs` - Catalog completeness result
4. `SqlSafetyVerificationResult.cs` - SQL safety checks result
5. `UatInventoryComplianceResult.cs` - UAT inventory compliance
6. `UatUsersVerificationReport.cs` - Final JSON report model

**Pattern**: Follow record structure defined in Architecture section, use immutable records

---

### Phase 2: Verifiers (1 day)

Implement verifiers in order of dependency:

**Step 1**: `TransformationMapVerifier.cs`
- Extract logic from `ValidateUserMapStep.cs`
- Convert from exception-throwing to result-returning
- Add tests in `TransformationMapVerifierTests.cs`

**Step 2**: `FkCatalogCompletenessVerifier.cs`
- Reuse `ModelUserSchemaGraphFactory` for expected catalog
- Compare discovered vs expected
- Add tests in `FkCatalogCompletenessVerifierTests.cs`

**Step 3**: `SqlSafetyAnalyzer.cs`
- Parse SQL script for required guards
- Use regex or string matching (simple approach)
- Add tests in `SqlSafetyAnalyzerTests.cs`

**Step 4**: `UatUsersVerifier.cs` (orchestrator)
- Coordinates all verifiers
- Loads artifacts from disk
- Add tests in `UatUsersVerifierTests.cs`

---

### Phase 3: Report Generation (0.5 days)

Implement `UatUsersVerificationReportGenerator.cs`:
- Takes `UatUsersVerificationContext`
- Builds JSON report following M1.1 pattern
- Includes discrepancies array
- Add tests in `UatUsersVerificationReportGeneratorTests.cs`

---

### Phase 4: CLI Integration (0.5 days)

**Modify existing files**:

1. `src/Osm.Cli/UatUsersOptions.cs`
   - Add `VerifyArtifactRoot` property
   - Add `VerificationReportOut` property

2. `src/Osm.Cli/UatUsersCommand.cs`
   - Add `--verify` flag handling
   - Wire up verifier when flag present
   - Return exit code based on verification result

3. Add CLI tests in `tests/Osm.Cli.Tests/Commands/UatUsersCommandVerifyTests.cs`

---

## Test Scenarios

### Scenario 1: Valid Artifacts (Happy Path)
**Given**:
- User map with all orphans mapped
- Catalog matches model expectations
- SQL script has all required guards

**When**: Run verification

**Expected**:
- `overallStatus`: "PASS"
- `discrepancies`: []
- Exit code: 0

---

### Scenario 2: Unmapped Orphans
**Given**:
- User map missing 3 orphan mappings

**When**: Run verification

**Expected**:
- `overallStatus`: "FAIL"
- `mapVerification.unmappedCount`: 3
- `discrepancies`: ["Missing mapping for orphan 999", "Missing mapping for orphan 111", ...]
- Exit code: 1

---

### Scenario 3: Invalid Target Users
**Given**:
- User map maps orphan to user ID not in UAT inventory

**When**: Run verification

**Expected**:
- `overallStatus`: "FAIL"
- `mapVerification.invalidTargets`: [999]
- `discrepancies`: ["Invalid target: 999"]
- Exit code: 1

---

### Scenario 4: Missing FK Columns
**Given**:
- Model has User FK on `Order.CreatedBy`
- Catalog doesn't include it (discovery bug)

**When**: Run verification

**Expected**:
- `overallStatus`: "FAIL"
- `catalogVerification.missingColumns`: ["dbo.Order.CreatedBy"]
- `discrepancies`: ["Missing column: dbo.Order.CreatedBy"]
- Exit code: 1

---

### Scenario 5: Unsafe SQL Script
**Given**:
- Generated SQL missing NULL guard on one UPDATE block

**When**: Run verification

**Expected**:
- `overallStatus`: "FAIL"
- `sqlSafety.hasNullGuards`: false
- `discrepancies`: ["SQL missing NULL guard"]
- Exit code: 1

---

### Scenario 6: CLI Integration
**Given**:
- Artifacts in `./artifacts/uat-users/`

**When**: Run `uat-users --verify ./artifacts/uat-users --verification-report-out ./report.json`

**Expected**:
- Verification runs standalone (no pipeline execution)
- Report written to `./report.json`
- Exit code reflects verification result

---

## Migration Path

### Non-Breaking Changes
- M2.1 adds verification capability; doesn't modify existing pipeline
- `--verify` flag is new; existing `uat-users` commands unaffected
- Verification is opt-in; operators can adopt incrementally

### Rollout Strategy

**Phase 1**: Deploy verification infrastructure (this spec)
- Ship verifiers, report generator, CLI integration
- No changes to existing pipeline behavior

**Phase 2**: Integrate with CI/CD
- Add verification step to CI/CD pipelines
- Gate UAT deployments on verification PASS

**Phase 3**: Integrate with full-export (M3.1)
- Auto-run verification when `--enable-uat-users` is used
- Embed verification results in manifest

### Backward Compatibility
- 100% backward compatible
- Verification is additive; existing behavior unchanged
- Operators can continue using `uat-users` without `--verify`

---

## Type Reference Guide

### Core UAT-Users Types

| Type | Namespace | Location | Notes |
|------|-----------|----------|-------|
| `UatUsersArtifacts` | `Osm.Pipeline.UatUsers` | `src/Osm.Pipeline/UatUsers/UatUsersArtifacts.cs` | Defines artifact paths |
| `UserIdentifier` | `Osm.Pipeline.UatUsers` | `src/Osm.Pipeline/UatUsers/UserIdentifier.cs` | Represents user ID |
| `UserMapEntry` | `Osm.Pipeline.UatUsers` | `src/Osm.Pipeline/UatUsers/UserMapEntry.cs` | Source‚ÜíTarget mapping |
| `UserFkColumn` | `Osm.Pipeline.UatUsers` | `src/Osm.Pipeline/UatUsers/UserFkColumn.cs` | FK catalog entry |
| `ValidateUserMapStep` | `Osm.Pipeline.UatUsers` | `src/Osm.Pipeline/UatUsers/ValidateUserMapStep.cs` | Existing validation logic to reuse |
| `ImmutableArray<T>` | `System.Collections.Immutable` | BCL | **‚ö†Ô∏è Struct, not class** |

### New Types to Create (M2.1)

All new types go in `src/Osm.Pipeline/UatUsers/Verification/`:

| Type | Purpose | Approx Lines |
|------|---------|--------------|
| `UatUsersVerificationContext` | Context model for verification | ~100 |
| `UserMapVerificationResult` | Map validation result | ~80 |
| `FkCatalogVerificationResult` | Catalog validation result | ~70 |
| `SqlSafetyVerificationResult` | SQL safety result | ~90 |
| `UatInventoryComplianceResult` | Inventory compliance result | ~60 |
| `UatUsersVerificationReport` | Aggregated verification report | ~120 |

---

## Testing Infrastructure (Expanded)

### Available Test Helpers

**Location**: `tests/Osm.Pipeline.Tests/UatUsers/`

| Helper Method | Location | Purpose |
|---------------|----------|---------|
| `FixtureFile.GetPath("uat_inventory.csv")` | `tests/Fixtures/FixtureFile.cs` | Load test inventory files |
| `CreateTestUserMap()` | Create in test file | Generate minimal user map |
| `TempDirectory` | `tests/Osm.Testing/TempDirectory.cs` | Create disposable temp directories |

### Test Data Fixtures

**Available Fixtures** (`tests/Fixtures/UatUsers/`):
- `uat_inventory_valid.csv` - Valid UAT user roster
- `uat_inventory_invalid.csv` - Malformed CSV for error testing
- `qa_inventory.csv` - QA user roster with known orphans
- `user_map_complete.csv` - All orphans mapped
- `user_map_incomplete.csv` - Missing mappings for testing
- `02_apply_user_remap.sql` - Sample UPDATE script

### Testing Patterns for UAT-Users Verification

**Pattern 1: Test verification in isolation**
```csharp
[Fact]
public async Task VerifyUserMap_AllOrphansMapped_ReturnsPass()
{
    // Arrange
    using var temp = new TempDirectory();
    var artifacts = CreateCompleteArtifacts(temp.Path);
    var context = new UatUsersVerificationContext(
        artifactRoot: temp.Path,
        userMapPath: artifacts.UserMapPath,
        fkCatalogPath: artifacts.FkCatalogPath,
        uatInventoryPath: artifacts.UatInventoryPath);

    var verifier = new TransformationMapVerifier(logger);

    // Act
    var result = await verifier.VerifyAsync(context, CancellationToken.None);

    // Assert
    Assert.True(result.IsValid);
    Assert.Equal(0, result.UnmappedCount);
}
```

**Pattern 2: Test edge cases**
```csharp
[Theory]
[InlineData(0, "EmptyMap")]  // No orphans case
[InlineData(15, "PartialMap")]  // Some orphans
[InlineData(100, "FullOrphans")]  // All orphans
public async Task VerifyUserMap_VariousOrphanCounts_HandlesCorrectly(
    int orphanCount, string scenario)
{
    // Arrange
    using var temp = new TempDirectory();
    var artifacts = CreateArtifactsWithOrphans(temp.Path, orphanCount);

    // Act & Assert
    // ... test verification behavior for each scenario
}
```

### Test Coverage Checklist

When testing UAT-users verification, ensure you cover:
- ‚úÖ Happy path (all orphans mapped, valid catalog)
- ‚úÖ Empty user map (no orphans case)
- ‚úÖ Incomplete user map (unmapped orphans)
- ‚úÖ Duplicate source mappings
- ‚úÖ Invalid target IDs (not in UAT inventory)
- ‚úÖ Missing FK catalog entries
- ‚úÖ Malformed CSV files
- ‚úÖ Missing artifact files

---

## Post-Implementation Checklist

### End-to-End Verification

After implementing M2.1, verify it works end-to-end:

```bash
# 1. Run uat-users to generate artifacts
dotnet run --project src/Osm.Cli -- uat-users \
  --model ./model.json \
  --connection-string "Server=localhost;Database=QA;..." \
  --uat-user-inventory ./uat_users.csv \
  --qa-user-inventory ./qa_users.csv \
  --out ./uat-artifacts

# 2. Verify the artifacts (should pass)
dotnet run --project src/Osm.Cli -- uat-users \
  --verify ./uat-artifacts/uat-users \
  --verification-report-out ./uat-verification.json

# 3. Check the verification report
cat ./uat-verification.json | jq '.overallStatus'
# Expected: "PASS"

# 4. Test failure case: Edit user map to create unmapped orphan
echo "orphan-user-123,unmapped-target" >> ./uat-artifacts/uat-users/00_user_map.csv

# 5. Re-run verification (should fail)
dotnet run --project src/Osm.Cli -- uat-users \
  --verify ./uat-artifacts/uat-users

# Expected: Verification fails with clear error about invalid target
```

### Integration Tests

**Run UAT-users verification tests**:
```bash
dotnet test tests/Osm.Pipeline.Tests/Osm.Pipeline.Tests.csproj \
  --filter "FullyQualifiedName~UatUsers.Verification"
```

**Expected new tests**:
- `TransformationMapVerifierTests` (6-8 tests)
- `FkCatalogCompletenessVerifierTests` (4-6 tests)
- `SqlSafetyAnalyzerTests` (5-7 tests)
- `UatInventoryComplianceTests` (4-5 tests)

### DI Registration Verification

**Verify services are registered** (`PipelineServiceCollectionExtensions.cs`):
```csharp
// Check UAT-users verification services
services.AddSingleton<ITransformationMapVerifier, TransformationMapVerifier>();
services.AddSingleton<IFkCatalogVerifier, FkCatalogCompletenessVerifier>();
services.AddSingleton<ISqlSafetyAnalyzer, SqlSafetyAnalyzer>();
services.AddSingleton<IUatInventoryComplianceChecker, UatInventoryComplianceChecker>();
```

---

## C# Gotchas and Common Pitfalls

### CSV Parsing Edge Cases

‚ö†Ô∏è **GOTCHA**: CSV files may have different line endings (CRLF vs LF)!

```csharp
// ‚ùå WRONG - Assumes specific line ending
var lines = File.ReadAllText(path).Split('\n');

// ‚úÖ CORRECT - Handle both CRLF and LF
var lines = File.ReadAllLines(path); // Handles line endings automatically
```

### User ID Comparison

‚ö†Ô∏è **GOTCHA**: User IDs might be GUIDs, integers, or strings!

```csharp
// ‚ùå WRONG - Case-sensitive comparison
if (orphanId == targetId)

// ‚úÖ CORRECT - Case-insensitive for string IDs
if (orphanId.Equals(targetId, StringComparison.OrdinalIgnoreCase))
```

### SQL Script Parsing

‚ö†Ô∏è **GOTCHA**: `TSql150Parser` requires proper error handling!

```csharp
// ‚ùå WRONG - Doesn't check for parse errors
var parser = new TSql150Parser(false);
var fragment = parser.Parse(new StringReader(sql), out var errors);

// ‚úÖ CORRECT - Check errors collection
var parser = new TSql150Parser(false);
var fragment = parser.Parse(new StringReader(sql), out var errors);
if (errors.Count > 0)
{
    throw new InvalidOperationException(
        $"SQL parse errors: {string.Join(", ", errors.Select(e => e.Message))}");
}
```

### File Path Handling for Artifacts

‚ö†Ô∏è **GOTCHA**: Artifact paths are relative to output root!

```csharp
// ‚ùå WRONG - Assumes absolute paths
var mapPath = artifacts.UserMapPath;
var content = File.ReadAllText(mapPath);

// ‚úÖ CORRECT - Combine with output root
var mapPath = Path.Combine(outputRoot, artifacts.UserMapPath);
var content = File.ReadAllText(mapPath);
```

### ImmutableArray Pattern (Same as M1.1)

‚ö†Ô∏è **GOTCHA**: `ImmutableArray<T>` is a **struct**, not a class!

```csharp
// ‚ùå WRONG
var mappings = userMapEntries ?? ImmutableArray<UserMapEntry>.Empty;

// ‚úÖ CORRECT
var mappings = userMapEntries.IsDefaultOrEmpty
    ? ImmutableArray<UserMapEntry>.Empty
    : userMapEntries;
```

---

## Success Metrics

M2.1 is successful if:

‚úÖ Operators can run `uat-users --verify {artifactRoot}` and get machine-readable report

‚úÖ CI/CD pipelines can gate UAT deployments on verification PASS (exit code 0)

‚úÖ Verification report includes all discrepancies for failed validations

‚úÖ All test scenarios pass (happy path + 5 failure modes)

‚úÖ Verification completes in <5 seconds for typical artifact set

‚úÖ Zero false positives (valid artifacts never fail verification)

‚úÖ Zero false negatives (invalid artifacts never pass verification)

---

*Generated: 2025-11-19*
*Status: Ready for implementation*
*Follows M1.* spec pattern with comprehensive codebase integration guide*
