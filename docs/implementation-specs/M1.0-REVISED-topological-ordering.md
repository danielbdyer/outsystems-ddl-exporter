# M1.0: Global Topological Ordering (REVISED)

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION
**Supersedes**: M1.0-global-topological-ordering.md (original spec was 80% redundant)

## Executive Summary

This specification addresses FK constraint violations during data loading by ensuring:
1. **Dynamic data contains ALL entities** (static + regular) in topologically sorted order
2. **Static entities use MERGE** in dynamic data for idempotency
3. **SMO enrichment** captures manually-added FKs not in OutSystems model
4. **Global topological sort** is applied to the complete entity set

**Key Finding**: The codebase already has sophisticated FK-aware topological sorting (`EntityDependencySorter`). M1.0 is about **applying it correctly to the combined static + regular entity set**, not building new infrastructure.

## Problem Statement

### Current Behavior

**Static Entities**:
- Extracted as separate dataset
- Topologically sorted (✅ already works!)
- Emitted as `StaticEntities.seed.sql`

**Regular Entities**:
- Extracted as separate dataset
- Topologically sorted (✅ already works!)
- Emitted as `DynamicData/*.dynamic.sql`

**LoadHarness Execution**:
1. Apply static seeds
2. Apply dynamic data

**Issue**: Cross-boundary FK dependencies between static and regular entities cause violations:
- Static entity `User` depends on regular entity `Department` → `User` inserted before `Department` → ❌ FK violation
- Regular entity `AuditLog` depends on static entity `AuditCategory` → Works today (static first)

### Desired Behavior (Latest Understanding)

**Dynamic Data** = **ALL entities** (static + regular):
- Build ONE global dependency graph for complete entity set
- Topologically sort (using existing `EntityDependencySorter`)
- Emit in FK-safe order
- Static entities use **MERGE** for idempotency (can be applied multiple times safely)

**Static Seeds** = Static entities only (unchanged):
- Source of truth for ongoing development
- Version controlled, developer-edited
- Applied via stub loader or directly

**First Deployment Workflow**:
1. Apply tables (DDL)
2. Apply dynamic data (ALL entities, topologically sorted) ← Self-contained, complete dataset
3. Optionally apply static seeds (idempotent, no-op if dynamic data already loaded them)

**Ongoing Development Workflow**:
1. Apply tables (DDL)
2. Apply static seeds (baseline data, edited by developers)
3. Apply dynamic data (regular entities only, or ALL entities with MERGE)

## Codebase Reality Check

### ✅ What Already Exists

| Component | File | Status |
|-----------|------|--------|
| FK-aware topological sorting | `EntityDependencySorter.cs` | ✅ Implemented (967 lines) |
| Kahn's algorithm | `EntityDependencySorter.TopologicalSort()` | ✅ Implemented |
| Cycle detection + fallback | `EntityDependencySorter.SortByForeignKeys()` | ✅ Implemented |
| Junction table deferral | `JunctionTableClassifier` | ✅ Implemented |
| Self-referencing FK ordering | `DynamicEntityInsertGenerator.OrderRows()` | ✅ Implemented |
| FK preflight validation | `StaticSeedForeignKeyPreflight.cs` | ✅ Implemented |
| LoadHarness trusts manifest order | `LoadHarnessRunner.cs` | ✅ Verified |
| Ordering telemetry | `BuildSsdtStaticSeedStep.cs` | ✅ Implemented |

### ❌ What Is Missing

| Gap | Current Impact | M1.0 Scope |
|-----|----------------|------------|
| **Dynamic data excludes static entities** | Static/dynamic sorted separately, cross-boundary FKs can fail | ✅ Must fix |
| **No MERGE for static entities in dynamic data** | Cannot safely apply both static seeds + dynamic data | ✅ Must fix |
| **No SMO enrichment** | Manual FKs (added via SSDT) invisible to sort | ✅ Must fix |
| **Module partitioning breaks global order** | When `GroupByModule=true`, files ordered alphabetically | ⚠️ Detect + warn |

## Implementation Scope

### Core Changes (Must Have)

#### 1. Dynamic Data Population - Include Static Entities

**Current Code**: `BuildSsdtDynamicInsertStep.cs` (line 38)
```csharp
var dataset = state.Request.DynamicDataset ?? DynamicEntityDataset.Empty;
```

**Investigation Required**: Where is `DynamicDataset` populated? Does it include static entities?

**Expected Change**: Ensure `DynamicDataset` contains **ALL entities** (static + regular), not just regular entities.

**Files to Check**:
- `src/Osm.Pipeline/Application/FullExportApplicationService.cs` - Where is DynamicDataset created?
- `src/Osm.Pipeline/DynamicData/SqlDynamicEntityDataProvider.cs` - Does it filter out static entities?

**Decision Point**:
- Option A: Modify provider to include static entities (filter `IsStatic = false` → remove filter)
- Option B: Add new provider mode `IncludeStaticEntities` (safer, backward compatible)

#### 2. MERGE Emission for Static Entities in Dynamic Data

**Current Code**: `DynamicEntityInsertGenerator.BuildScript()` (lines 712-784)
- Always emits standard INSERT
- Uses `SET IDENTITY_INSERT` for identity columns

**Required Change**: Detect static entities and emit MERGE instead of INSERT

**Pseudocode**:
```csharp
private string BuildScript(
    StaticEntitySeedTableDefinition definition,
    ImmutableArray<StaticEntityRow> rows,
    int batchSize,
    bool isStaticEntity)  // ← NEW parameter
{
    if (isStaticEntity)
    {
        return BuildMergeScript(definition, rows, batchSize);
    }
    else
    {
        return BuildInsertScript(definition, rows, batchSize);
    }
}
```

**MERGE Script Template**:
```sql
MERGE INTO [schema].[table] AS Target
USING (VALUES
    (val1, val2, val3),
    (val4, val5, val6)
) AS Source ([col1], [col2], [col3])
ON Target.[PrimaryKey] = Source.[PrimaryKey]
WHEN NOT MATCHED THEN
    INSERT ([col1], [col2], [col3])
    VALUES (Source.[col1], Source.[col2], Source.[col3]);
```

**Edge Cases**:
- Composite primary keys: `ON Target.PK1 = Source.PK1 AND Target.PK2 = Source.PK2`
- Identity columns: No `SET IDENTITY_INSERT` needed with MERGE (handles automatically)
- No primary key: **Abort with error** - MERGE requires PK for matching

**Files to Modify**:
- `src/Osm.Emission/DynamicEntityInsertGenerator.cs` - Add `BuildMergeScript()` method
- `src/Osm.Emission/DynamicEntityInsertGenerator.cs` - Modify `GenerateScripts()` to pass `isStaticEntity` flag

#### 3. SMO Enrichment - Capture Manual FKs

**Current Code**: `EntityDependencySorter.BuildDependencyGraph()` (lines 159-262)
- Extracts FKs from `entity.Relationships` and `relationship.ActualConstraints` (model-based)
- No SMO queries

**Required Change**: Add SMO enrichment step after model-based extraction

**New Method**:
```csharp
private static async Task<int> EnrichWithSmoMetadataAsync(
    SqlConnection connection,
    IDictionary<TableKey, HashSet<TableKey>> edges,
    IDictionary<TableKey, int> indegree,
    TableKeyComparer comparer,
    CancellationToken cancellationToken,
    TimeSpan timeout = default)
{
    timeout = timeout == default ? TimeSpan.FromSeconds(30) : timeout;

    var query = @"
SELECT
    OBJECT_SCHEMA_NAME(fk.parent_object_id) AS ChildSchema,
    OBJECT_NAME(fk.parent_object_id) AS ChildTable,
    OBJECT_SCHEMA_NAME(fk.referenced_object_id) AS ParentSchema,
    OBJECT_NAME(fk.referenced_object_id) AS ParentTable,
    fk.name AS ConstraintName
FROM sys.foreign_keys fk
WHERE fk.is_disabled = 0
  AND fk.is_not_trusted = 0";

    var addedEdgeCount = 0;

    // Execute query, parse results, add missing edges to graph
    // Return count of newly-added edges (for telemetry)

    return addedEdgeCount;
}
```

**Integration Point**:
- Make `EntityDependencySorter.SortByForeignKeys()` **async** (breaking change!)
- Add optional `SqlConnection` parameter for SMO enrichment
- If connection provided → run SMO enrichment, else → model-only (backward compatible)

**Telemetry**:
```csharp
.WithCount("ordering.smoEnrichmentEdges", smoAddedEdges)
.WithValue("ordering.smoEnrichmentEnabled", connection != null ? "true" : "false")
```

**Error Handling**:
- SMO query timeout (30s) → Log warning, proceed without enrichment
- SMO query failure (permissions) → Log warning, proceed without enrichment
- SMO query returns 0 rows → Log info (no manual FKs found)

**Files to Modify**:
- `src/Osm.Emission/Seeds/EntityDependencySorter.cs` - Add `EnrichWithSmoMetadataAsync()`
- `src/Osm.Emission/Seeds/EntityDependencySorter.cs` - Make `SortByForeignKeys()` async
- `src/Osm.Pipeline/Orchestration/BuildSsdtStaticSeedStep.cs` - Pass connection to sorter
- `src/Osm.Pipeline/Orchestration/BuildSsdtDynamicInsertStep.cs` - Pass connection to sorter

### Secondary Changes (Should Have)

#### 4. Module Ordering Validation

**Current Code**: `BuildSsdtStaticSeedStep.cs` (lines 102-137)
- Groups static seeds by module
- Orders modules **alphabetically** (line 107)
- May break global topological order

**Required Change**: Detect cross-module FK dependencies and warn if alphabetical module order violates topological order

**New Method**:
```csharp
private static ImmutableArray<ModuleDependencyIssue> ValidateModuleOrdering(
    IReadOnlyList<StaticEntityTableData> orderedTables,
    string[] alphabeticalModules,
    OsmModel model)
{
    // Build module dependency graph
    // Compare alphabetical order to topological order
    // Return list of violations
}
```

**Warning Message**:
```
WARNING: Module partitioning breaks FK ordering!
  - Module 'ModuleA' emits before 'ModuleB' (alphabetical)
  - But table 'ModuleA.User' depends on 'ModuleB.Role' (FK constraint)
  - Recommendation: Disable GroupByModule or rename modules to respect FK order
  - Cross-module FK count: 5
```

**Files to Modify**:
- `src/Osm.Pipeline/Orchestration/BuildSsdtStaticSeedStep.cs` - Add validation
- Tests: Add module ordering violation test case

## Data Models

### EntityStaticFlag Propagation

**Issue**: `DynamicEntityInsertGenerator.GenerateScripts()` needs to know which entities are static to emit MERGE.

**Solution**: Add `IsStatic` flag to `StaticEntitySeedTableDefinition`:

```csharp
public sealed record StaticEntitySeedTableDefinition(
    string Module,
    string LogicalName,
    string Schema,
    string PhysicalName,
    string EffectiveName,
    ImmutableArray<StaticEntitySeedColumn> Columns,
    bool IsStatic)  // ← NEW field
{
    // ...
}
```

**Propagation Chain**:
1. `EntityModel.IsStatic` (source of truth)
2. `StaticEntitySeedDefinitionBuilder.Build()` - Capture `IsStatic` from `EntityModel`
3. `StaticEntitySeedTableDefinition` - Store `IsStatic` flag
4. `StaticEntityTableData` - Inherit from definition
5. `DynamicEntityInsertGenerator.GenerateScripts()` - Read `IsStatic` to choose INSERT vs MERGE

## Integration Points

### Existing Code Flow

```
FullExportApplicationService
  ↓
BuildSsdtPipeline
  ↓
┌─────────────────────────────────────────────────────────────┐
│ BuildSsdtStaticSeedStep                                     │
│  1. Get static entity definitions                           │
│  2. Fetch data from StaticDataProvider                      │
│  3. EntityDependencySorter.SortByForeignKeys(staticOnly)    │
│  4. Emit StaticEntities.seed.sql                            │
└─────────────────────────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────────────────────────┐
│ BuildSsdtDynamicInsertStep                                  │
│  1. Get DynamicDataset (currently regularOnly?)             │
│  2. DynamicEntityInsertGenerator.GenerateScripts()          │
│      └─ EntityDependencySorter.SortByForeignKeys(regularOnly) │
│  3. Emit DynamicData/*.dynamic.sql                          │
└─────────────────────────────────────────────────────────────┘
```

### Modified Code Flow

```
FullExportApplicationService
  ↓ (populate DynamicDataset with ALL entities)
BuildSsdtPipeline
  ↓
┌─────────────────────────────────────────────────────────────┐
│ BuildSsdtStaticSeedStep (unchanged behavior)                │
│  1. Get static entity definitions                           │
│  2. Fetch data from StaticDataProvider                      │
│  3. EntityDependencySorter.SortByForeignKeys(staticOnly)    │
│      └─ SMO enrichment (if connection provided) ← NEW!      │
│  4. Emit StaticEntities.seed.sql                            │
└─────────────────────────────────────────────────────────────┘
  ↓
┌─────────────────────────────────────────────────────────────┐
│ BuildSsdtDynamicInsertStep (modified behavior)              │
│  1. Get DynamicDataset (now includes ALL entities) ← NEW!   │
│  2. DynamicEntityInsertGenerator.GenerateScripts()          │
│      └─ EntityDependencySorter.SortByForeignKeys(allEntities) │
│          └─ SMO enrichment (if connection provided) ← NEW!  │
│      └─ Emit INSERT for regular entities                    │
│      └─ Emit MERGE for static entities ← NEW!               │
│  3. Emit DynamicData/*.dynamic.sql                          │
└─────────────────────────────────────────────────────────────┘
```

## Test Scenarios

### Unit Tests

#### Test 1: MERGE Script Generation
```csharp
[Fact]
public void BuildMergeScript_WithSimplePrimaryKey_EmitsMergeStatement()
{
    // Arrange
    var definition = new StaticEntitySeedTableDefinition(
        Module: "Core",
        LogicalName: "Role",
        Schema: "dbo",
        PhysicalName: "OSSYS_ROLE",
        EffectiveName: "OSSYS_ROLE",
        Columns: ImmutableArray.Create(
            new StaticEntitySeedColumn("Id", "Id", "Id", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("Name", "Name", "Name", "nvarchar", 50, null, null, IsPrimaryKey: false, IsIdentity: false, IsNullable: false)
        ),
        IsStatic: true);

    var rows = ImmutableArray.Create(
        StaticEntityRow.Create(new object[] { Guid.Parse("00000000-0000-0000-0000-000000000001"), "Admin" }));

    // Act
    var script = generator.BuildScript(definition, rows, batchSize: 1000, isStaticEntity: true);

    // Assert
    Assert.Contains("MERGE INTO [dbo].[OSSYS_ROLE]", script);
    Assert.Contains("ON Target.[Id] = Source.[Id]", script);
    Assert.Contains("WHEN NOT MATCHED THEN", script);
    Assert.DoesNotContain("SET IDENTITY_INSERT", script);
}
```

#### Test 2: Global Ordering Across Static + Regular
```csharp
[Fact]
public void SortByForeignKeys_WithCrossBoundaryFK_OrdersGlobally()
{
    // Arrange
    var staticRole = CreateStaticEntityTable("Role", isStatic: true);
    var regularUser = CreateRegularEntityTable("User", isStatic: false, fkTo: "Role");
    var allEntities = ImmutableArray.Create(regularUser, staticRole);  // Intentionally wrong order

    // Act
    var result = EntityDependencySorter.SortByForeignKeys(allEntities, model);

    // Assert
    Assert.Equal("Role", result.Tables[0].Definition.LogicalName);  // Parent first
    Assert.Equal("User", result.Tables[1].Definition.LogicalName);  // Child second
    Assert.True(result.TopologicalOrderingApplied);
}
```

#### Test 3: SMO Enrichment
```csharp
[Fact]
public async Task EnrichWithSmoMetadata_WithManualFK_AddsEdgeToGraph()
{
    // Arrange
    var connection = CreateTestConnection();
    await CreateManualFKAsync(connection, "User", "Department");  // Not in model!

    var edges = new Dictionary<TableKey, HashSet<TableKey>>();
    var indegree = new Dictionary<TableKey, int>();

    // Act
    var addedCount = await EntityDependencySorter.EnrichWithSmoMetadataAsync(
        connection, edges, indegree, new TableKeyComparer(), CancellationToken.None);

    // Assert
    Assert.Equal(1, addedCount);
    Assert.True(edges[new TableKey("dbo", "Department")].Contains(new TableKey("dbo", "User")));
}
```

### Integration Tests

#### Test 4: End-to-End Dynamic Data Emission
```csharp
[Fact]
public async Task FullExport_WithStaticAndRegularEntities_EmitsDynamicDataWithMerge()
{
    // Arrange
    var model = LoadTestModel("StaticAndRegular.oml");
    var options = new FullExportOptions
    {
        IncludeStaticInDynamicData = true
    };

    // Act
    var result = await fullExportService.ExecuteAsync(model, options);

    // Assert
    var dynamicScript = File.ReadAllText(result.DynamicDataPaths[0]);
    Assert.Contains("MERGE INTO [dbo].[OSSYS_ROLE]", dynamicScript);  // Static entity
    Assert.Contains("INSERT INTO [dbo].[OSSYS_USER]", dynamicScript);  // Regular entity

    // Verify order: Role (static, no FKs) before User (regular, FK to Role)
    var roleIndex = dynamicScript.IndexOf("MERGE INTO [dbo].[OSSYS_ROLE]");
    var userIndex = dynamicScript.IndexOf("INSERT INTO [dbo].[OSSYS_USER]");
    Assert.True(roleIndex < userIndex);
}
```

#### Test 5: LoadHarness Execution
```csharp
[Fact]
public async Task LoadHarness_WithDynamicDataContainingStatic_LoadsWithoutFKViolations()
{
    // Arrange
    var db = CreateEmptyDatabase();
    await ApplyDDL(db, "tables.sql");

    var options = new LoadHarnessOptions
    {
        ConnectionString = db.ConnectionString,
        DynamicInsertScriptPaths = ImmutableArray.Create("DynamicData.all.dynamic.sql")
    };

    // Act
    var result = await loadHarnessRunner.RunAsync(options);

    // Assert
    Assert.Empty(result.Errors);
    Assert.True(result.AllScriptsSucceeded);

    // Verify data loaded
    var roleCount = await db.QueryScalarAsync<int>("SELECT COUNT(*) FROM OSSYS_ROLE");
    var userCount = await db.QueryScalarAsync<int>("SELECT COUNT(*) FROM OSSYS_USER");
    Assert.True(roleCount > 0);
    Assert.True(userCount > 0);
}
```

## Migration Path

### Phase 1: Add Infrastructure (Non-Breaking)
- Add `IsStatic` field to `StaticEntitySeedTableDefinition`
- Add `BuildMergeScript()` method to `DynamicEntityInsertGenerator`
- Add SMO enrichment method (not yet invoked)
- **No behavior changes yet**

### Phase 2: Feature Flag Rollout
- Add configuration option `IncludeStaticInDynamicData` (default: `false`)
- When `true`:
  - Populate `DynamicDataset` with ALL entities
  - Enable MERGE emission for static entities
  - Enable SMO enrichment
- **Allows gradual rollout and A/B testing**

### Phase 3: Validation
- Run full exports with feature flag enabled
- Compare dynamic data scripts (with/without feature)
- Execute LoadHarness tests
- Monitor for FK violations

### Phase 4: Default Flip
- Change default to `IncludeStaticInDynamicData = true`
- Update documentation
- Deprecate old behavior (emit warning if disabled)

### Phase 5: Cleanup
- Remove feature flag
- Make new behavior mandatory
- Remove legacy code paths

## Backward Compatibility

### Breaking Changes

| Change | Impact | Mitigation |
|--------|--------|------------|
| `EntityDependencySorter.SortByForeignKeys()` becomes async | Callers must await | Gradual migration, deprecate sync version |
| `StaticEntitySeedTableDefinition` adds `IsStatic` field | Record type change | Add optional parameter with default `false` for compat |
| Dynamic data scripts now include static entities | Larger files, different content | Feature flag for gradual rollout |

### Non-Breaking Changes

| Change | Impact |
|--------|--------|
| MERGE instead of INSERT for static entities | Idempotent, safer |
| SMO enrichment | More accurate ordering, no schema changes |
| Module ordering validation | New warnings, no errors |

## Performance Considerations

### SMO Query Performance

**Query**:
```sql
SELECT
    OBJECT_SCHEMA_NAME(parent_object_id) AS ChildSchema,
    OBJECT_NAME(parent_object_id) AS ChildTable,
    OBJECT_SCHEMA_NAME(referenced_object_id) AS ParentSchema,
    OBJECT_NAME(referenced_object_id) AS ParentTable
FROM sys.foreign_keys
WHERE is_disabled = 0
```

**Expected Performance**:
- Small schemas (< 100 tables): < 100ms
- Medium schemas (100-1000 tables): < 500ms
- Large schemas (> 1000 tables): < 2s

**Timeout**: 30 seconds (configurable)

### MERGE vs INSERT Performance

**MERGE Overhead**:
- Additional `SELECT` to check for existing rows
- Typically 10-20% slower than raw INSERT
- But provides idempotency guarantee

**Mitigation**:
- Only static entities use MERGE (typically < 10% of total rows)
- Regular entities still use fast INSERT
- Net impact on total load time: < 5%

### Large Dynamic Data Files

**Current**: Separate files per entity (when `PerEntity` mode)
**New**: May include static entities (more files, or larger consolidated file)

**Impact**:
- File size increase: ~10-20% (static entities typically small)
- Parse time increase: Negligible
- Git diff noise: Higher (consolidated file harder to review)

**Recommendation**: Use `PerEntity` mode for large exports to maintain file granularity

## Open Questions

1. **Where is `DynamicDataset` populated?**
   - Need to find the code that creates `DynamicDataset` and check if it filters out static entities
   - Likely in `FullExportApplicationService` or `SqlDynamicEntityDataProvider`

2. **Should SMO enrichment be always-on or opt-in?**
   - Pro always-on: Better accuracy, catches all FKs
   - Pro opt-in: Faster exports when manual FKs are rare, requires permissions
   - **Recommendation**: Always-on with graceful fallback (warn if query fails, proceed without enrichment)

3. **Should static seeds still be emitted separately?**
   - Per user's latest understanding: Yes, they're the "source of truth" for ongoing development
   - Dynamic data is for first deployment, static seeds are for subsequent edits
   - **Recommendation**: Keep both emission paths

4. **What if a static entity has no primary key?**
   - MERGE requires PK for matching
   - **Recommendation**: Abort with error - static entities without PK cannot use MERGE
   - Alternative: Emit warning and fall back to INSERT (risk of duplicates)

## Success Criteria

1. ✅ Dynamic data includes ALL entities (static + regular)
2. ✅ Static entities in dynamic data use MERGE (idempotent)
3. ✅ SMO enrichment captures manual FKs
4. ✅ No FK violations during LoadHarness execution
5. ✅ Existing static seed emission unchanged
6. ✅ Topological ordering telemetry includes SMO edge count
7. ✅ Module ordering warnings emitted when partitioning breaks order
8. ✅ All existing tests pass
9. ✅ New integration tests cover cross-boundary FK scenarios

## Implementation Checklist

- [ ] **Phase 1**: Investigation
  - [ ] Find where `DynamicDataset` is populated
  - [ ] Verify if static entities are currently filtered out
  - [ ] Identify all callers of `EntityDependencySorter.SortByForeignKeys()`

- [ ] **Phase 2**: Data Model Changes
  - [ ] Add `IsStatic` field to `StaticEntitySeedTableDefinition`
  - [ ] Update `StaticEntitySeedDefinitionBuilder.Build()` to capture `IsStatic`
  - [ ] Update all instantiation sites

- [ ] **Phase 3**: MERGE Emission
  - [ ] Add `BuildMergeScript()` to `DynamicEntityInsertGenerator`
  - [ ] Modify `GenerateScripts()` to choose INSERT vs MERGE based on `IsStatic`
  - [ ] Add unit tests for MERGE script generation

- [ ] **Phase 4**: SMO Enrichment
  - [ ] Add `EnrichWithSmoMetadataAsync()` to `EntityDependencySorter`
  - [ ] Make `SortByForeignKeys()` async (or add async overload)
  - [ ] Add timeout and error handling
  - [ ] Update callers to pass `SqlConnection`
  - [ ] Add unit tests for SMO enrichment

- [ ] **Phase 5**: Dynamic Dataset Population
  - [ ] Modify dataset population to include static entities
  - [ ] Add feature flag `IncludeStaticInDynamicData`
  - [ ] Update configuration options

- [ ] **Phase 6**: Module Ordering Validation
  - [ ] Add `ValidateModuleOrdering()` to `BuildSsdtStaticSeedStep`
  - [ ] Emit warnings for cross-module FK violations

- [ ] **Phase 7**: Integration Testing
  - [ ] Add end-to-end test: static + regular entities, cross-boundary FKs
  - [ ] Add LoadHarness test: verify no FK violations
  - [ ] Add SMO enrichment test: manual FK captured

- [ ] **Phase 8**: Documentation
  - [ ] Update user documentation for new dynamic data behavior
  - [ ] Document MERGE vs INSERT trade-offs
  - [ ] Update migration guide

---

**Next Step**: Investigate where `DynamicDataset` is populated to determine if static entities are currently included or filtered out.
