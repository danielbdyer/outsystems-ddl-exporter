# M2.2: INSERT Transformation Implementation

**Status**: CRITICAL PATH IMPLEMENTATION (Milestone Deadline)
**Dependencies**: M2.1 (UAT-Users Verification Framework)
**Priority**: ğŸ”´ Critical Path (required for milestone - full-export + uat-users integration)
**Note**: This implements the aspirational Mode 1 from `docs/design-uat-users-transformation.md`
**Pattern**: Like M1.0 (critical path implementation) - M2.3 verification can be deferred

---

## Executive Summary

### The Specific Problem

The current UAT-users pipeline generates **UPDATE scripts** that transform user foreign keys after data is loaded to the UAT database. This creates operational complexity:

- **Two-Stage Deployment**: Must load QA data first, then run UPDATE scripts to transform user FKs
- **Slower Performance**: Row-by-row UPDATEs are slower than bulk INSERTs
- **Lock Contention**: UPDATE acquires row/page locks, can block concurrent operations
- **Non-Atomic**: If UPDATE fails mid-execution, database is in inconsistent state
- **Complex Rollback**: Reverting transformations requires inverse UPDATE scripts (error-prone)

**Example**: UAT refresh takes 10 minutes (5 min load + 5 min UPDATE). During UPDATE execution, application is unavailable due to locking.

### Recommended Solution

**Pre-Transformed INSERT Generation**

Refactor pipeline to apply user FK transformations **during INSERT generation** instead of post-load:

1. **Reorder Pipeline**: Run UAT-users discovery before build (discovery â†’ build â†’ deploy)
2. **Transformation Context**: Pass orphanâ†’target mapping to `DynamicEntityInsertGenerator`
3. **In-Memory Transformation**: Apply transformations during row emission (before SQL generation)
4. **UAT-Ready INSERTs**: Generated INSERT scripts contain UAT user IDs directly

This produces INSERT scripts that can be loaded directly to UAT database without post-processing.

### How It Fixes the Problem

1. **Single-Stage Deployment**: Load pre-transformed INSERTs directly, no separate UPDATE step
2. **Faster Performance**: Bulk INSERT with `TABLOCK` faster than row-by-row UPDATE
3. **Reduced Locking**: Table-level locks (INSERT) vs row/page locks (UPDATE)
4. **Atomic**: Single operation, no mid-execution inconsistency
5. **Simple Rollback**: Drop/reload anytime, no inverse scripts needed
6. **Audit-Friendly**: INSERT scripts are immutable source of truth

### Alternative Approaches Considered

**Alternative 1: Keep UPDATE-Based Approach**
- Continue generating UPDATE scripts for post-load transformation
- **Rejected**: Slower, more complex deployment, lock contention, not addressing user's pain point

**Alternative 2: In-Database Views**
- Create views that remap user FKs dynamically at query time
- **Rejected**: Application must query views not tables, breaks existing code, performance overhead

**Alternative 3: Database Triggers**
- Use triggers to transform user FKs on INSERT
- **Rejected**: Complex, hard to debug, performance overhead, trigger maintenance burden

**Alternative 4: Application-Layer Transformation**
- Let application handle user FK transformation at runtime
- **Rejected**: Breaks existing application code, requires app changes, not a data migration solution

**Alternative 5: Dual-Mode Support (INSERT + UPDATE)**
- Support both pre-transformed INSERTs and post-load UPDATEs
- **Accepted as Enhancement**: M2.2 implements INSERT transformation, UPDATE scripts remain available via standalone `uat-users` verb for legacy scenarios

**Why INSERT Transformation Wins**: Faster, simpler deployment, atomic, proven pattern (same as M1.0 bootstrap), backward compatible (UPDATE still available).

### Scope (M2.2)

**Implementation Required** (Critical Path):
- âœ… Refactor `FullExportCoordinator` to run UAT-users before build
- âœ… Create `TransformationContext` to pass orphan mappings to INSERT generator
- âœ… Modify `DynamicEntityInsertGenerator` to accept transformation context
- âœ… Apply transformations in-memory during value emission
- âœ… Update `BuildSsdtDynamicInsertStep` to wire transformation context

**Out of Scope** (Defer to M2.3 Verification):
- Automated verification that transformations were applied correctly (M2.3 Part B)
- Cross-mode validation between INSERT and UPDATE (M2.3 Cross-Validation)
- UPDATE script generation remains supported via standalone `uat-users` verb

**Verification Strategy**:
- Manual inspection of generated INSERTs (proves transformations applied)
- M2.3 Part B provides automated verification (can be deferred after milestone)

### Key Findings

**Current Pipeline Flow** (from `FullExportCoordinator.cs`):
```csharp
// Line 87: Build runs FIRST
var buildResult = await request.BuildAsync(extraction, profile, cancellationToken);

// Line 118: UAT-users runs AFTER
if (request.RunUatUsersAsync is { } uatUsersAsync) {
    var uatUsersResult = await uatUsersAsync(extraction, build, schemaGraph, cancellationToken);
}
```

**Required Changes**:
- Reverse order: UAT-users discovery â†’ Build (with transformation context)
- Pass `TransformationContext` through build pipeline to INSERT generator

**Architectural Challenge**:
- UAT-users needs model (from extraction) to discover FK catalog
- Build needs UAT-users results (transformation map) to generate INSERTs
- Solution: Split UAT-users into "discovery" (before build) and "artifact emission" (after build)

---

## Critical Path Analysis

### Why This Matters

**Benefits of INSERT Transformation**:
- **Performance**: Bulk INSERT with `TABLOCK` faster than row-by-row UPDATE
- **Simplicity**: Load scripts directly, no separate transformation step
- **Atomicity**: Single deployment operation (not load-then-update)
- **Rollback**: Drop and reload (vs complex inverse UPDATE)

**Risks of Deferring**:
- Operators continue using slower UPDATE approach
- More complex deployment process (load QA data, then transform)
- UPDATE scripts must be maintained alongside INSERT capability

### Dependencies and Parallelization

**Depends On**:
- M2.1 (UAT-users verification framework - artifact validation, map validation)

**Enables** (Can Be Deferred):
- M2.3 Part B (INSERT verification - automated proof that transformations applied)
- M2.3 Cross-Validation (INSERT vs UPDATE equivalence proof)

---

## Architecture

### Current vs Desired Pipeline Flow

**Current (UPDATE-Only)**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Extract Model    (get schema + entity metadata)  â”‚
â”‚ 2. Profile          (capture runtime data)          â”‚
â”‚ 3. Build            (generate INSERTs with QA data) â”‚ â† No transformation
â”‚ 4. Apply            (deploy schema)                 â”‚
â”‚ 5. UAT-Users        (generate UPDATE scripts)       â”‚ â† Transformation here
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Desired (INSERT Transformation)**:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Extract Model    (get schema + entity metadata)  â”‚
â”‚ 2. Profile          (capture runtime data)          â”‚
â”‚ 3. UAT-Users Disco  (discover orphans, load map)    â”‚ â† NEW: Split UAT-users
â”‚ 4. Build            (generate INSERTs with UAT data)â”‚ â† Transformation here
â”‚ 5. Apply            (deploy schema)                 â”‚
â”‚ 6. UAT-Users Emit   (emit verification artifacts)   â”‚ â† NEW: Artifact emission only
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Component Changes

#### Change 1: Split UAT-Users Pipeline

**Before** (single monolithic pipeline):
- Discover FK catalog â†’ Load inventories â†’ Validate map â†’ Emit UPDATE scripts

**After** (split into discovery + emission):
- **Discovery Phase**: Discover FK catalog â†’ Load inventories â†’ Validate map â†’ Return `TransformationContext`
- **Emission Phase**: Emit verification artifacts (map template, catalog, preview CSV)

**New Classes**:
```csharp
// Discovery result (returned before build)
public sealed record UatUsersDiscoveryResult(
    IReadOnlyList<UserFkColumn> Catalog,
    IReadOnlyDictionary<UserIdentifier, UserIdentifier> TransformationMap,
    IReadOnlyCollection<UserIdentifier> Orphans,
    IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> QaInventory,
    IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> UatInventory);

// Transformation context (passed to INSERT generator)
public sealed class TransformationContext
{
    public IReadOnlyDictionary<UserIdentifier, UserIdentifier> TransformationMap { get; }
    public IReadOnlySet<string> UserFkColumns { get; }

    public object? TransformValue(string columnName, object? value)
    {
        if (!UserFkColumns.Contains(columnName) || value == null)
            return value;

        var userId = new UserIdentifier(value);
        return TransformationMap.TryGetValue(userId, out var target)
            ? target.Value
            : value;
    }
}
```

#### Change 2: Modify DynamicEntityInsertGenerator

**File**: `src/Osm.Emission/DynamicEntityInsertGenerator.cs` (current: 810 lines, ZERO transformation logic)

**Add Transformation Support**:
```csharp
public sealed class DynamicEntityInsertGenerator
{
    private readonly TransformationContext? _transformationContext;

    public DynamicEntityInsertGenerator(
        // ... existing parameters
        TransformationContext? transformationContext = null)
    {
        // ... existing initialization
        _transformationContext = transformationContext;
    }

    private object? ApplyTransformations(string columnName, object? value)
    {
        return _transformationContext?.TransformValue(columnName, value) ?? value;
    }

    private void EmitValueLiteral(object? value, string columnName)
    {
        // Apply transformation before emitting
        var transformedValue = ApplyTransformations(columnName, value);

        // ... existing literal emission logic
    }
}
```

**Integration Point**: Line ~400-500 where VALUES are emitted

#### Change 3: Update BuildSsdtDynamicInsertStep

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtDynamicInsertStep.cs`

**Pass Transformation Context**:
```csharp
public sealed class BuildSsdtDynamicInsertStep : IBuildSsdtStep<...>
{
    private readonly TransformationContext? _transformationContext;

    public BuildSsdtDynamicInsertStep(
        // ... existing parameters
        TransformationContext? transformationContext = null)
    {
        _transformationContext = transformationContext;
    }

    public async Task<Result<DynamicInsertGenerated>> ExecuteAsync(...)
    {
        // ... existing logic

        var generator = new DynamicEntityInsertGenerator(
            // ... existing parameters
            transformationContext: _transformationContext);

        // ... continue with generation
    }
}
```

#### Change 4: Refactor FullExportCoordinator

**File**: `src/Osm.Pipeline/Orchestration/FullExportCoordinator.cs`

**New Execution Order**:
```csharp
// After profile completes:
UatUsersDiscoveryResult? discoveryResult = null;
if (request.DiscoverUatUsersAsync is { } discoverAsync)
{
    var discovery = await discoverAsync(extraction, profile, cancellationToken);
    discoveryResult = discovery.Value;
}

// Build with transformation context:
var buildResult = await request.BuildAsync(
    extraction,
    profile,
    discoveryResult?.ToTransformationContext(),
    cancellationToken);

// After build, emit UAT-users artifacts:
if (discoveryResult != null && request.EmitUatUsersArtifactsAsync is { } emitAsync)
{
    await emitAsync(build, discoveryResult, cancellationToken);
}
```

---

## Codebase Integration Guide â­

### Existing Infrastructure (Leverage These)

#### âœ… **UAT-Users Pipeline** - Already Implemented (Split This)
- **File**: `src/Osm.Pipeline/UatUsers/UatUsersPipeline.cs` (75 lines)
- **Current**: Monolithic pipeline (discovery + validation + emission)
- **Required**: Split into `UatUsersDiscoveryPipeline` + `UatUsersEmissionPipeline`
- **Reuse**: All existing steps (DiscoverUserFkCatalogStep, LoadUatUserInventoryStep, etc.)

#### âœ… **INSERT Generator** - Exists, Needs Modification
- **File**: `src/Osm.Emission/DynamicEntityInsertGenerator.cs` (810 lines)
- **Current**: No transformation awareness
- **Required**: Add `TransformationContext` parameter, apply transformations during value emission
- **Integration Point**: ~Line 400-500 where VALUES literals are emitted

#### âœ… **Transformation Map** - Already Loaded
- **File**: `src/Osm.Pipeline/UatUsers/UserMapLoader.cs`
- **Method**: `LoadFromCsv()`
- **Status**: Complete - reuse for transformation context

### Required Changes

#### Change 1: Create UatUsersDiscoveryPipeline
**File**: `src/Osm.Pipeline/UatUsers/UatUsersDiscoveryPipeline.cs` (NEW)

**Signature**:
```csharp
public sealed class UatUsersDiscoveryPipeline : IPipeline<UatUsersDiscoveryContext>
{
    public async Task<Result<UatUsersDiscoveryResult>> ExecuteAsync(
        UatUsersDiscoveryContext context,
        CancellationToken cancellationToken)
    {
        // Run discovery steps only:
        // 1. DiscoverUserFkCatalogStep
        // 2. LoadUatUserInventoryStep
        // 3. LoadQaUserInventoryStep
        // 4. AnalyzeForeignKeyValuesStep
        // 5. ApplyMatchingStrategyStep
        // 6. PrepareUserMapStep
        // 7. ValidateUserMapStep

        // Return discovery result (NO artifact emission)
        return new UatUsersDiscoveryResult(
            catalog,
            transformationMap,
            orphans,
            qaInventory,
            uatInventory);
    }
}
```

**Pattern**: Reuse existing pipeline steps, just return data instead of emitting artifacts

---

#### Change 2: Create TransformationContext
**File**: `src/Osm.Pipeline/UatUsers/TransformationContext.cs` (NEW)

**Implementation**:
```csharp
public sealed class TransformationContext
{
    private readonly IReadOnlyDictionary<UserIdentifier, UserIdentifier> _transformationMap;
    private readonly IReadOnlySet<string> _userFkColumns;

    public TransformationContext(
        IReadOnlyDictionary<UserIdentifier, UserIdentifier> transformationMap,
        IReadOnlyList<UserFkColumn> catalog)
    {
        _transformationMap = transformationMap;

        // Build column name lookup set (schema.table.column)
        _userFkColumns = catalog
            .Select(c => $"{c.SchemaName}.{c.TableName}.{c.ColumnName}")
            .ToHashSet(StringComparer.OrdinalIgnoreCase);
    }

    public object? TransformValue(string tableName, string columnName, object? value)
    {
        if (value == null)
            return null;

        var fqColumnName = $"dbo.{tableName}.{columnName}";
        if (!_userFkColumns.Contains(fqColumnName))
            return value; // Not a user FK column

        var userId = new UserIdentifier(value);
        if (_transformationMap.TryGetValue(userId, out var target))
            return target.Value; // Transform orphan â†’ target

        return value; // Not an orphan, preserve original
    }
}
```

---

#### Change 3: Modify DynamicEntityInsertGenerator
**File**: `src/Osm.Emission/DynamicEntityInsertGenerator.cs` (MODIFY)

**Changes**:
1. Add `TransformationContext? transformationContext` constructor parameter
2. Store as private field
3. Modify value emission logic (around line 400-500):

**Before** (current):
```csharp
private void EmitValue(object? value, string columnName)
{
    if (value == null)
    {
        _writer.Write("NULL");
        return;
    }

    // ... emit literal based on type
}
```

**After** (with transformation):
```csharp
private void EmitValue(object? value, string columnName, string tableName)
{
    // Apply transformation if context available
    var transformedValue = _transformationContext?.TransformValue(tableName, columnName, value) ?? value;

    if (transformedValue == null)
    {
        _writer.Write("NULL");
        return;
    }

    // ... emit literal based on type (use transformedValue)
}
```

**Challenge**: Need table name in emission context (may require refactoring)

---

#### Change 4: Update BuildSsdtDynamicInsertStep
**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtDynamicInsertStep.cs` (MODIFY)

**Changes**:
1. Accept `TransformationContext?` in constructor
2. Pass to `DynamicEntityInsertGenerator`

**Pattern**: Similar to how existing dependencies are injected

---

#### Change 5: Refactor FullExportCoordinator
**File**: `src/Osm.Pipeline/Orchestration/FullExportCoordinator.cs` (MODIFY)

**Changes**:
1. Add `DiscoverUatUsersAsync` delegate (runs after profile, before build)
2. Modify `BuildAsync` delegate to accept `TransformationContext?`
3. Add `EmitUatUsersArtifactsAsync` delegate (runs after build)

**New Flow**:
```csharp
var profile = await ProfileAsync(...);

UatUsersDiscoveryResult? discovery = null;
if (DiscoverUatUsersAsync != null)
{
    discovery = await DiscoverUatUsersAsync(extraction, profile, cancellationToken);
}

var build = await BuildAsync(
    extraction,
    profile,
    discovery?.ToTransformationContext(),
    cancellationToken);

if (discovery != null && EmitUatUsersArtifactsAsync != null)
{
    await EmitUatUsersArtifactsAsync(build, discovery, cancellationToken);
}
```

---

### Testing Infrastructure

**New Test Files Required**:

1. **`tests/Osm.Pipeline.Tests/UatUsers/UatUsersDiscoveryPipelineTests.cs`**
   - Test: Discovery returns transformation map
   - Test: Discovery validates user map
   - Test: Discovery does NOT emit artifacts

2. **`tests/Osm.Pipeline.Tests/UatUsers/TransformationContextTests.cs`**
   - Test: Transform orphan ID â†’ target ID
   - Test: Preserve non-orphan ID
   - Test: Preserve NULL values
   - Test: Ignore non-user-FK columns

3. **`tests/Osm.Emission.Tests/DynamicEntityInsertGeneratorTransformationTests.cs`**
   - Test: INSERT contains transformed user FK values
   - Test: INSERT preserves NULLs
   - Test: INSERT without transformation context (backward compatible)

4. **`tests/Osm.Pipeline.Integration.Tests/FullExportUatUsersIntegrationTests.cs`**
   - Test: End-to-end full-export with `--enable-uat-users`
   - Test: Generated INSERTs contain UAT user IDs
   - Test: No orphan IDs in emitted INSERTs

---

### Critical Questions to Resolve Before Implementation

#### 1. **Table Name Availability in INSERT Generator**
   - â“ Does `DynamicEntityInsertGenerator` have table name in scope during value emission?
   - â“ If not, how to pass table context for FK column lookup?
   - **Action**: Investigate current code structure before implementation

#### 2. **Backward Compatibility**
   - â“ Should UPDATE script generation still be supported (standalone `uat-users` verb)?
   - â“ Or deprecate UPDATE approach entirely?
   - **Recommendation**: Keep UPDATE support for legacy UAT database migration

#### 3. **Artifact Emission Timing**
   - â“ Should UAT-users artifacts (map template, preview CSV) be emitted before or after build?
   - â“ Preview CSV shows row counts - need build to complete first?
   - **Recommendation**: Emit after build (verification artifacts reference generated INSERTs)

#### 4. **Transformation Verification**
   - â“ How to verify INSERTs contain transformed values?
   - â“ Parse generated SQL scripts? Or capture during generation?
   - **Recommendation**: M2.3 Part B will address automated INSERT verification

---

## Implementation Phases

### Phase 1: Pipeline Refactoring
1. Create `UatUsersDiscoveryPipeline` (split from existing pipeline)
2. Create `TransformationContext` class
3. Refactor `FullExportCoordinator` to run discovery before build
4. Wire up new execution flow

### Phase 2: INSERT Generator Modification
1. Add `TransformationContext` parameter to `DynamicEntityInsertGenerator`
2. Modify value emission logic to apply transformations
3. Ensure table name available for FK column lookup

### Phase 3: Build Pipeline Integration
1. Update `BuildSsdtDynamicInsertStep` to accept transformation context
2. Pass context through build pipeline to INSERT generator
3. Ensure DI wiring correct

### Phase 4: Artifact Emission
1. Create `UatUsersEmissionPipeline` (artifact emission only)
2. Wire into coordinator (runs after build)
3. Emit verification artifacts (map template, preview CSV, catalog)

### Phase 5: Testing & Verification
1. Unit tests for transformation context
2. Integration tests for end-to-end flow
3. Verify generated INSERTs contain transformed values (manually inspect)
4. M2.3 Part B will add automated INSERT verification

---

## Migration Path

### Backward Compatibility

**Standalone `uat-users` verb (UPDATE scripts)**:
- Continue to support for legacy migration scenarios
- Operators can still generate UPDATE scripts for existing UAT databases
- No breaking changes to CLI

**Full-export without `--enable-uat-users`**:
- Continues to work as-is (no transformation)
- Generates INSERTs with QA user IDs

**Full-export with `--enable-uat-users`** (NEW):
- Generates pre-transformed INSERTs (UAT-ready)
- No UPDATE scripts needed
- Preferred approach for new deployments

### Rollout Strategy

**Phase 1**: Implement INSERT transformation infrastructure
- Deploy INSERT transformation capability
- Beta test with select operators

**Phase 2**: Production adoption
- Document INSERT approach as recommended
- Migrate operators from UPDATE to INSERT workflow

**Phase 3**: Verification (M2.3 Part B)
- Add automated INSERT verification
- Prove transformations applied correctly

---

## Success Metrics

M2.2 is successful if:

âœ… `full-export --enable-uat-users` generates INSERTs with UAT user IDs (no orphans)

âœ… Backward compatible (standalone `uat-users` still works)

âœ… No breaking changes to existing workflows

âœ… Performance improvement (INSERT faster than UPDATE)

âœ… Deployment simplification (load INSERTs directly, no UPDATE step)

âœ… All tests pass (unit, integration, end-to-end)

âœ… Manual inspection confirms transformed values in generated SQL

---

*Generated: 2025-11-19*
*Status: Critical Path Implementation (Milestone Deadline)*
*Implements aspirational Mode 1 from design-uat-users-transformation.md*
