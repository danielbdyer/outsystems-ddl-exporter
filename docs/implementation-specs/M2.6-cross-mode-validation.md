# M2.6: Cross-Mode Validation (INSERT vs UPDATE Equivalence)

**Status**: READY FOR IMPLEMENTATION (after M2.4 + M2.5 ship)
**Dependencies**: M2.2 (UPDATE Script Verification), M2.4 (INSERT Transformation), M2.5 (INSERT Verification)
**Priority**: ğŸ”µ Advanced Verification (ship when both transformation modes are stable)
**Scope**: Prove that INSERT and UPDATE transformation modes produce equivalent results

---

## Executive Summary

### Problem Statement

After M2.4 (INSERT transformation) and M2.2 (UPDATE transformation) both exist, there's **no proof that both modes produce equivalent results**.

**Current Gap**:
- INSERT mode: Pre-transformed INSERTs generated during full-export
- UPDATE mode: Post-load UPDATEs generated by standalone `uat-users` verb
- Both claim to transform orphan user IDs â†’ target user IDs
- No automated proof that both approaches produce identical UAT databases

**Risk**: Subtle transformation differences where INSERT and UPDATE modes diverge, causing data inconsistencies depending on deployment approach.

### Solution Approach

Build a **cross-mode validation harness** that:
- **Loads same source data twice** (once with INSERT mode, once with UPDATE mode)
- **Compares final database state** (row-by-row, column-by-column)
- **Verifies transformation equivalence** (both produce same user FK values)
- **Detects mode-specific bugs** (e.g., NULL handling differences, type conversion issues)
- **Emits equivalence report** (JSON) proving modes are interchangeable

**This provides confidence that operators can choose either transformation mode based on performance needs without risking data correctness.**

### Scope (M2.6)

**Ship This**:
- âœ… Dual-mode test harness (load with INSERT, load with UPDATE)
- âœ… Database state comparator (compare final results)
- âœ… User FK value validator (verify transformations match)
- âœ… NULL preservation cross-check (both modes preserve NULLs identically)
- âœ… Equivalence report generator (JSON output)

**Out of Scope**:
- Performance comparison (INSERT vs UPDATE speed - separate benchmark)
- Live production validation (M3.2 load harness covers this)
- Non-user-FK data integrity (M1.8 covers general data integrity)

---

## Critical Path Analysis

### Why This Matters

**Without cross-mode validation**:
- Operators unsure which mode to use (INSERT vs UPDATE)
- Mode-specific bugs discovered only in production
- No proof that switching modes is safe
- Risk of data divergence between deployment strategies

**With cross-mode validation**:
- Prove both modes produce identical results
- Catch mode-specific bugs before production (e.g., NULL handling, type conversion)
- Operators confident in choosing mode based on performance needs
- Regression tests detect mode divergence during development

### Dependencies and Parallelization

**Depends On**:
- M2.2 (UPDATE transformation - must exist for comparison)
- M2.4 (INSERT transformation - must exist for comparison)
- M2.5 (INSERT verification - reuse verification infrastructure)

**Enables**:
- M3.2 (load harness with mode selection)
- Operator confidence in transformation modes

**Can Parallel With**:
- M2.3 (integration tests - different scope)

---

## Architecture

### Component Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Cross-Mode Test Harness                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚                   â”‚
            â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
            â”‚ INSERT Mode  â”‚    â”‚ UPDATE Mode  â”‚
            â”‚              â”‚    â”‚              â”‚
            â”‚ 1. Extract   â”‚    â”‚ 1. Extract   â”‚
            â”‚ 2. Profile   â”‚    â”‚ 2. Profile   â”‚
            â”‚ 3. UAT Disco â”‚    â”‚ 3. Build     â”‚
            â”‚ 4. Build     â”‚    â”‚ 4. Apply     â”‚
            â”‚    (transform)â”‚    â”‚ 5. UAT-Users â”‚
            â”‚ 5. Apply     â”‚    â”‚    (UPDATE)  â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                    â”‚                   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Database State    â”‚
                    â”‚ Comparator        â”‚
                    â”‚                   â”‚
                    â”‚ - Row counts      â”‚
                    â”‚ - User FK values  â”‚
                    â”‚ - NULL preservationâ”‚
                    â”‚ - Non-FK integrityâ”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚ Equivalence Reportâ”‚
                    â”‚ (JSON)            â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Models

#### CrossModeValidationReport

```csharp
public sealed record CrossModeValidationReport(
    bool Passed,
    DateTimeOffset ValidatedAtUtc,
    string SourceDatabase,
    string InsertModeDatabase,
    string UpdateModeDatabase,
    int TablesCompared,
    int UserFkColumnsCompared,
    long RowsCompared,
    ImmutableArray<TableComparisonResult> TableResults,
    ImmutableArray<CrossModeDiscrepancy> Discrepancies);

public sealed record TableComparisonResult(
    string Schema,
    string TableName,
    long InsertModeRowCount,
    long UpdateModeRowCount,
    bool RowCountsMatch,
    ImmutableArray<ColumnComparisonResult> ColumnResults);

public sealed record ColumnComparisonResult(
    string ColumnName,
    bool IsUserFkColumn,
    long ValuesCompared,
    long MatchingValues,
    long NullsInInsertMode,
    long NullsInUpdateMode,
    bool NullCountsMatch,
    bool AllValuesMatch);

public sealed record CrossModeDiscrepancy(
    string Schema,
    string TableName,
    string ColumnName,
    string DiscrepancyType, // "RowCountMismatch", "ValueMismatch", "NullCountMismatch"
    long? InsertModeValue,
    long? UpdateModeValue,
    string Message);
```

---

## Implementation Details

### 1. Create CrossModeTestHarness

**File**: `src/Osm.Pipeline/UatUsers/Verification/CrossModeTestHarness.cs`

**Purpose**: Execute full-export with both transformation modes and compare results

```csharp
using Microsoft.Data.SqlClient;
using System.Collections.Immutable;

namespace Osm.Pipeline.UatUsers.Verification;

public sealed class CrossModeTestHarness
{
    private readonly ILogger<CrossModeTestHarness> _logger;
    private readonly FullExportApplicationService _fullExportService;

    public CrossModeTestHarness(
        ILogger<CrossModeTestHarness> logger,
        FullExportApplicationService fullExportService)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _fullExportService = fullExportService ?? throw new ArgumentNullException(nameof(fullExportService));
    }

    public async Task<Result<CrossModeValidationReport>> ValidateAsync(
        CrossModeTestContext context,
        CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Starting cross-mode validation (INSERT vs UPDATE)");

        // Phase 1: Run full-export with INSERT mode
        _logger.LogInformation("Phase 1: Running full-export with INSERT transformation mode");
        var insertModeResult = await RunFullExportAsync(
            context,
            transformationMode: TransformationMode.Insert,
            targetDatabase: context.InsertModeDatabase,
            cancellationToken);

        if (!insertModeResult.IsSuccess)
            return Result<CrossModeValidationReport>.Failure(insertModeResult.Error);

        // Phase 2: Run full-export with UPDATE mode
        _logger.LogInformation("Phase 2: Running full-export with UPDATE transformation mode");
        var updateModeResult = await RunFullExportAsync(
            context,
            transformationMode: TransformationMode.Update,
            targetDatabase: context.UpdateModeDatabase,
            cancellationToken);

        if (!updateModeResult.IsSuccess)
            return Result<CrossModeValidationReport>.Failure(updateModeResult.Error);

        // Phase 3: Compare database states
        _logger.LogInformation("Phase 3: Comparing database states");
        var comparator = new DatabaseStateComparator(_logger);
        var comparisonResult = await comparator.CompareAsync(
            context.InsertModeDatabaseConnection,
            context.UpdateModeDatabaseConnection,
            context.UserFkCatalog,
            context.Model,
            cancellationToken);

        return comparisonResult;
    }

    private async Task<Result<Unit>> RunFullExportAsync(
        CrossModeTestContext context,
        TransformationMode mode,
        string targetDatabase,
        CancellationToken cancellationToken)
    {
        // 1. Drop and recreate target database (clean slate)
        await DropAndRecreateDatabase(targetDatabase, cancellationToken);

        // 2. Run full-export pipeline
        var options = new FullExportOptions
        {
            SourceConnectionString = context.SourceConnectionString,
            BuildOutputDirectory = Path.Combine(context.WorkingDirectory, mode.ToString()),
            EnableUatUsers = true,
            UatUserTransformationMode = mode,
            UatUserMapPath = context.UserMapPath,
            // ... other options
        };

        var result = await _fullExportService.ExecuteAsync(options, cancellationToken);

        if (!result.IsSuccess)
            return Result<Unit>.Failure(result.Error);

        // 3. Apply generated scripts to target database
        await ApplyScripts(
            targetDatabase,
            Path.Combine(options.BuildOutputDirectory, "DynamicData"),
            cancellationToken);

        // 4. If UPDATE mode, apply UPDATE scripts
        if (mode == TransformationMode.Update)
        {
            await ApplyUpdateScripts(
                targetDatabase,
                Path.Combine(options.BuildOutputDirectory, "uat-users"),
                cancellationToken);
        }

        return Result<Unit>.Success(Unit.Value);
    }

    private async Task ApplyUpdateScripts(
        string targetDatabase,
        string uatUsersOutputDir,
        CancellationToken cancellationToken)
    {
        var updateScriptPath = Path.Combine(uatUsersOutputDir, "02_apply_user_remap.sql");
        var scriptContent = await File.ReadAllTextAsync(updateScriptPath, cancellationToken);

        await using var connection = new SqlConnection($"Server=localhost;Database={targetDatabase};...");
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = scriptContent;
        command.CommandTimeout = 300; // 5 minutes

        await command.ExecuteNonQueryAsync(cancellationToken);
    }
}

public sealed record CrossModeTestContext(
    string SourceConnectionString,
    string InsertModeDatabaseConnection,
    string UpdateModeDatabaseConnection,
    string InsertModeDatabase,
    string UpdateModeDatabase,
    string UserMapPath,
    string WorkingDirectory,
    IReadOnlyList<UserFkColumn> UserFkCatalog,
    FilteredOsmModel Model);

public enum TransformationMode
{
    Insert,
    Update
}
```

---

### 2. Create DatabaseStateComparator

**File**: `src/Osm.Pipeline/UatUsers/Verification/DatabaseStateComparator.cs`

**Purpose**: Compare two databases row-by-row, column-by-column

```csharp
using Microsoft.Data.SqlClient;
using System.Collections.Immutable;

namespace Osm.Pipeline.UatUsers.Verification;

public sealed class DatabaseStateComparator
{
    private readonly ILogger<DatabaseStateComparator> _logger;

    public DatabaseStateComparator(ILogger<DatabaseStateComparator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<Result<CrossModeValidationReport>> CompareAsync(
        string insertModeConnection,
        string updateModeConnection,
        IReadOnlyList<UserFkColumn> userFkCatalog,
        FilteredOsmModel model,
        CancellationToken cancellationToken = default)
    {
        var userFkLookup = BuildUserFkLookup(userFkCatalog);
        var discrepancies = ImmutableArray.CreateBuilder<CrossModeDiscrepancy>();
        var tableResults = ImmutableArray.CreateBuilder<TableComparisonResult>();

        foreach (var entity in model.Entities)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var tableName = entity.LogicalTableName ?? entity.PhysicalTableName;

            // 1. Compare row counts
            var insertModeRowCount = await GetRowCountAsync(insertModeConnection, tableName, cancellationToken);
            var updateModeRowCount = await GetRowCountAsync(updateModeConnection, tableName, cancellationToken);

            var rowCountsMatch = insertModeRowCount == updateModeRowCount;

            if (!rowCountsMatch)
            {
                discrepancies.Add(new CrossModeDiscrepancy(
                    Schema: "dbo",
                    TableName: tableName,
                    ColumnName: "<row count>",
                    DiscrepancyType: "RowCountMismatch",
                    InsertModeValue: insertModeRowCount,
                    UpdateModeValue: updateModeRowCount,
                    Message: $"Row count mismatch: INSERT mode has {insertModeRowCount}, UPDATE mode has {updateModeRowCount}"));
            }

            // 2. Compare column values (especially user FK columns)
            var columnResults = await CompareColumnsAsync(
                insertModeConnection,
                updateModeConnection,
                tableName,
                entity.Attributes,
                userFkLookup,
                discrepancies,
                cancellationToken);

            tableResults.Add(new TableComparisonResult(
                Schema: "dbo",
                TableName: tableName,
                InsertModeRowCount: insertModeRowCount,
                UpdateModeRowCount: updateModeRowCount,
                RowCountsMatch: rowCountsMatch,
                ColumnResults: columnResults));
        }

        var report = new CrossModeValidationReport(
            Passed: discrepancies.Count == 0,
            ValidatedAtUtc: DateTimeOffset.UtcNow,
            SourceDatabase: "QA",
            InsertModeDatabase: "UAT_InsertMode",
            UpdateModeDatabase: "UAT_UpdateMode",
            TablesCompared: tableResults.Count,
            UserFkColumnsCompared: tableResults.SelectMany(tr => tr.ColumnResults.Where(cr => cr.IsUserFkColumn)).Count(),
            RowsCompared: tableResults.Sum(tr => tr.InsertModeRowCount),
            TableResults: tableResults.ToImmutable(),
            Discrepancies: discrepancies.ToImmutable());

        return Result<CrossModeValidationReport>.Success(report);
    }

    private async Task<ImmutableArray<ColumnComparisonResult>> CompareColumnsAsync(
        string insertModeConnection,
        string updateModeConnection,
        string tableName,
        IReadOnlyList<OsmAttribute> attributes,
        IReadOnlySet<string> userFkLookup,
        ImmutableArray<CrossModeDiscrepancy>.Builder discrepancies,
        CancellationToken cancellationToken)
    {
        var columnResults = ImmutableArray.CreateBuilder<ColumnComparisonResult>();

        foreach (var attribute in attributes)
        {
            var columnName = attribute.LogicalColumnName ?? attribute.PhysicalColumnName;
            var fqColumnName = $"dbo.{tableName}.{columnName}";
            var isUserFk = userFkLookup.Contains(fqColumnName);

            // Get NULL counts
            var insertModeNullCount = await GetNullCountAsync(insertModeConnection, tableName, columnName, cancellationToken);
            var updateModeNullCount = await GetNullCountAsync(updateModeConnection, tableName, columnName, cancellationToken);

            var nullCountsMatch = insertModeNullCount == updateModeNullCount;

            if (!nullCountsMatch)
            {
                discrepancies.Add(new CrossModeDiscrepancy(
                    Schema: "dbo",
                    TableName: tableName,
                    ColumnName: columnName,
                    DiscrepancyType: "NullCountMismatch",
                    InsertModeValue: insertModeNullCount,
                    UpdateModeValue: updateModeNullCount,
                    Message: $"NULL count mismatch on {columnName}: INSERT mode has {insertModeNullCount}, UPDATE mode has {updateModeNullCount}"));
            }

            // For user FK columns, compare actual values
            bool allValuesMatch = true;
            if (isUserFk)
            {
                allValuesMatch = await CompareColumnValuesAsync(
                    insertModeConnection,
                    updateModeConnection,
                    tableName,
                    columnName,
                    discrepancies,
                    cancellationToken);
            }

            columnResults.Add(new ColumnComparisonResult(
                ColumnName: columnName,
                IsUserFkColumn: isUserFk,
                ValuesCompared: await GetRowCountAsync(insertModeConnection, tableName, cancellationToken),
                MatchingValues: 0, // TODO: Calculate from comparison
                NullsInInsertMode: insertModeNullCount,
                NullsInUpdateMode: updateModeNullCount,
                NullCountsMatch: nullCountsMatch,
                AllValuesMatch: allValuesMatch));
        }

        return columnResults.ToImmutable();
    }

    private async Task<bool> CompareColumnValuesAsync(
        string insertModeConnection,
        string updateModeConnection,
        string tableName,
        string columnName,
        ImmutableArray<CrossModeDiscrepancy>.Builder discrepancies,
        CancellationToken cancellationToken)
    {
        // Fetch all values from both databases and compare
        var insertModeValues = await GetColumnValuesAsync(insertModeConnection, tableName, columnName, cancellationToken);
        var updateModeValues = await GetColumnValuesAsync(updateModeConnection, tableName, columnName, cancellationToken);

        // Sort both lists for comparison
        var insertModeSorted = insertModeValues.OrderBy(v => v).ToArray();
        var updateModeSorted = updateModeValues.OrderBy(v => v).ToArray();

        if (insertModeSorted.Length != updateModeSorted.Length)
            return false;

        for (int i = 0; i < insertModeSorted.Length; i++)
        {
            if (!Equals(insertModeSorted[i], updateModeSorted[i]))
            {
                discrepancies.Add(new CrossModeDiscrepancy(
                    Schema: "dbo",
                    TableName: tableName,
                    ColumnName: columnName,
                    DiscrepancyType: "ValueMismatch",
                    InsertModeValue: insertModeSorted[i] as long?,
                    UpdateModeValue: updateModeSorted[i] as long?,
                    Message: $"Value mismatch at index {i}: INSERT mode has {insertModeSorted[i]}, UPDATE mode has {updateModeSorted[i]}"));

                return false;
            }
        }

        return true;
    }

    private async Task<long> GetRowCountAsync(string connectionString, string tableName, CancellationToken cancellationToken)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = $"SELECT COUNT_BIG(*) FROM [dbo].[{tableName}]";

        var result = await command.ExecuteScalarAsync(cancellationToken);
        return result is long count ? count : 0;
    }

    private async Task<long> GetNullCountAsync(string connectionString, string tableName, string columnName, CancellationToken cancellationToken)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = $"SELECT COUNT_BIG(*) FROM [dbo].[{tableName}] WHERE [{columnName}] IS NULL";

        var result = await command.ExecuteScalarAsync(cancellationToken);
        return result is long count ? count : 0;
    }

    private async Task<ImmutableArray<object?>> GetColumnValuesAsync(
        string connectionString,
        string tableName,
        string columnName,
        CancellationToken cancellationToken)
    {
        var values = ImmutableArray.CreateBuilder<object?>();

        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = $"SELECT [{columnName}] FROM [dbo].[{tableName}] ORDER BY [{columnName}]";

        await using var reader = await command.ExecuteReaderAsync(cancellationToken);

        while (await reader.ReadAsync(cancellationToken))
        {
            values.Add(reader.IsDBNull(0) ? null : reader.GetValue(0));
        }

        return values.ToImmutable();
    }

    private IReadOnlySet<string> BuildUserFkLookup(IReadOnlyList<UserFkColumn> catalog)
    {
        return catalog
            .Select(c => $"{c.SchemaName}.{c.TableName}.{c.ColumnName}")
            .ToHashSet(StringComparer.OrdinalIgnoreCase);
    }
}
```

---

## Test Scenarios

### Test 1: Identical Results (Both Modes Equivalent)

```csharp
[Fact]
public async Task ValidateAsync_BothModes_ProducesIdenticalResults()
{
    // Arrange: Same source data, same transformation map
    var context = CreateTestContext();

    // Act: Run both modes and compare
    var result = await _harness.ValidateAsync(context);

    // Assert: No discrepancies
    Assert.True(result.Value.Passed);
    Assert.Empty(result.Value.Discrepancies);
    Assert.All(result.Value.TableResults, tr => Assert.True(tr.RowCountsMatch));
    Assert.All(result.Value.TableResults, tr =>
        Assert.All(tr.ColumnResults, cr => Assert.True(cr.AllValuesMatch)));
}
```

### Test 2: Row Count Mismatch Detection

```csharp
[Fact]
public async Task CompareAsync_RowCountMismatch_ReportsDiscrepancy()
{
    // Arrange: INSERT mode has 100 rows, UPDATE mode has 95 (bug in UPDATE mode)
    var insertDb = CreateDatabase("InsertMode", rowCount: 100);
    var updateDb = CreateDatabase("UpdateMode", rowCount: 95);

    // Act
    var result = await _comparator.CompareAsync(insertDb, updateDb, catalog, model);

    // Assert
    Assert.False(result.Value.Passed);
    Assert.Contains(result.Value.Discrepancies, d => d.DiscrepancyType == "RowCountMismatch");
}
```

### Test 3: NULL Preservation Equivalence

```csharp
[Fact]
public async Task CompareAsync_NullCountsMatch_NoDiscrepancy()
{
    // Arrange: Both modes preserve same number of NULLs
    var insertDb = CreateDatabase("InsertMode", nullCount: 10);
    var updateDb = CreateDatabase("UpdateMode", nullCount: 10);

    // Act
    var result = await _comparator.CompareAsync(insertDb, updateDb, catalog, model);

    // Assert
    Assert.True(result.Value.Passed);
    Assert.All(result.Value.TableResults, tr =>
        Assert.All(tr.ColumnResults, cr => Assert.True(cr.NullCountsMatch)));
}
```

---

## Success Criteria

M2.6 is successful if:

âœ… Cross-mode test harness runs both INSERT and UPDATE modes successfully

âœ… Database state comparator detects row count mismatches

âœ… User FK value comparison detects transformation differences

âœ… NULL preservation verified across both modes

âœ… Equivalence report emitted as JSON

âœ… CI/CD regression tests detect mode divergence

âœ… All tests pass (unit, integration, end-to-end)

---

## Operational Benefits

**For Operators**:
- Confidence to choose transformation mode based on performance needs
- Proof that both modes produce identical UAT data
- Safety net during mode migration (can switch without data risk)

**For Developers**:
- Regression tests catch mode-specific bugs early
- Clear specification of transformation equivalence requirements
- Foundation for performance benchmarking (compare INSERT vs UPDATE speed)

---

*Generated: 2025-11-19*
*Status: Ready for Implementation (after M2.4 + M2.5 ship)*
*Provides proof that INSERT and UPDATE transformation modes are equivalent*
