# M1.0: Global Topological Ordering with Bootstrap Snapshot

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION
**Estimated Effort**: 2-3 days

## Executive Summary

This specification addresses FK constraint violations during data loading by:
1. Generating a **bootstrap snapshot** containing ALL entities (static + regular) in global topological order
2. Emitting a **PostDeployment script template** that conditionally applies the bootstrap snapshot on first deployment
3. Maintaining **baseline seeds** (static entities) as idempotent, version-controlled source of truth

**Key Finding**: After comprehensive codebase analysis, **most infrastructure already exists**. This is about applying existing topological sorting to the complete entity set and orchestrating first-deployment vs. ongoing-deployment workflows.

## Problem Statement

### Current Behavior - The Real Issue

**User's Observation**: FK constraint violations occur when applying static seed files in SSDT, even after manually reordering parent/child entities.

**Root Cause**: Static seed files are partitioned by module and emitted in **alphabetical module order**, breaking cross-module FK dependencies.

**Current Static Seed Flow**:
1. All static entities are topologically sorted globally ‚úÖ
2. Entities partitioned by module (preserving order within each module) ‚úÖ
3. Module files emitted in **alphabetical order** ‚ùå
4. SSDT applies files in ItemGroup order (alphabetical) ‚ùå

**Example Failure**:
- ModuleA contains `User` (FK ‚Üí `Role`)
- ModuleB contains `Role`
- Alphabetical order: ModuleA before ModuleB
- Result: `User` MERGEs before `Role` exists ‚Üí FK violation!

**Why Manual Reordering Didn't Help**:
- Reordering entities WITHIN a module preserves FK order within that module
- But cross-MODULE dependencies still violate due to alphabetical module file ordering

### Proposed Solution - Bootstrap Snapshot

**First Deployment Strategy**:
1. **Bootstrap Snapshot** (`AllEntitiesIncludingStatic.bootstrap.sql`):
   - ALL entities (static + regular) in ONE file
   - Global topological sort (no module partitioning)
   - MERGE for all entities (idempotent)
   - Applied ONCE on first deployment via conditional PostDeployment script
   - **Not committed to source control** (ephemeral artifact)

2. **Baseline Seeds** (`StaticEntities.seed.sql` or per-module/per-entity files):
   - Static entities only
   - Version controlled, developer-maintained
   - Applied on EVERY deployment (idempotent MERGE)
   - Module ordering becomes irrelevant (data already exists from bootstrap)

**Workflow**:
```
First Deployment:
  1. SSDT creates tables + FK constraints
  2. PostDeployment guard detects "first run"
  3. Bootstrap snapshot applies (all entities, topologically sorted)
  4. Baseline seeds apply (no-op, data already exists)
  5. Guard marks bootstrap as "applied"

Ongoing Deployments:
  1. SSDT updates schema if needed
  2. PostDeployment guard detects "already bootstrapped"
  3. Bootstrap snapshot skipped
  4. Baseline seeds apply (maintain static reference data)
```

## Codebase Reality Check - What Already Exists

### ‚úÖ Infrastructure ALREADY Implemented

| Component | File | Lines | Status |
|-----------|------|-------|--------|
| **FK-aware topological sorting** | `EntityDependencySorter.cs` | 967 | ‚úÖ Complete |
| **Kahn's algorithm** | `EntityDependencySorter.TopologicalSort()` | 264-302 | ‚úÖ Implemented |
| **Cycle detection + fallback** | `EntityDependencySorter.SortByForeignKeys()` | 122-156 | ‚úÖ Implemented |
| **Junction table deferral** | `JunctionTableClassifier` | 616-782 | ‚úÖ Implemented |
| **Self-referencing FK ordering** | `DynamicEntityInsertGenerator.OrderRows()` | 152-405 | ‚úÖ Implemented |
| **FK preflight validation** | `StaticSeedForeignKeyPreflight.cs` | 217 | ‚úÖ Implemented |
| **SMO enrichment** | `RelationshipConstraintHydrator.cs` | 292 | ‚úÖ **EXISTS!** |
| **LoadHarness trust manifest** | `LoadHarnessRunner.BuildScriptQueue()` | 169-206 | ‚úÖ Verified |
| **Ordering telemetry** | `BuildSsdtStaticSeedStep.cs` | 158-172 | ‚úÖ Implemented |

### üîç SMO Enrichment Discovery

**File**: `src/Osm.Pipeline/ModelIngestion/RelationshipConstraintMetadataProvider.cs`

**Key Query** (lines 72-94):
```csharp
SELECT
    mc.SchemaName,
    mc.TableName,
    mc.ConstraintName,
    fkc.constraint_column_id AS Ordinal,
    parent_col.name AS ParentColumn,
    ref_col.name AS ReferencedColumn,
    ref_schema.name AS ReferencedSchema,
    ref_table.name AS ReferencedTable
FROM MissingConstraints mc
JOIN sys.schemas parent_schema ON parent_schema.name = mc.SchemaName
JOIN sys.tables parent_table ON parent_table.schema_id = parent_schema.schema_id AND parent_table.name = mc.TableName
JOIN sys.foreign_keys fk ON fk.parent_object_id = parent_table.object_id AND fk.name = mc.ConstraintName
JOIN sys.foreign_key_columns fkc ON fkc.constraint_object_id = fk.object_id
-- ... (joins to get column names)
```

**Usage**: `RelationshipConstraintHydrator.HydrateAsync()` (line 30-68)
- Finds relationships with missing constraint metadata (`NeedsHydration()`)
- Queries SQL Server via `sys.foreign_keys` to get actual FK column mappings
- Enriches the `OsmModel` with complete FK metadata

**This is EXACTLY the SMO enrichment I thought was missing - it already exists and runs during model extraction!**

### ‚ùå What Is Actually Missing

| Gap | Current Impact | M1.0 Scope |
|-----|----------------|------------|
| **Dynamic data excludes static entities** | Static/dynamic sorted separately, cross-boundary FKs fail | ‚úÖ Must fix |
| **No MERGE for static entities** | Cannot safely apply both static seeds + dynamic data | ‚úÖ Must fix |
| **Module partitioning breaks order** | When `GroupByModule=true`, files ordered alphabetically | ‚ö†Ô∏è Detect + warn |

## New File Emissions

### 1. Bootstrap Snapshot (Single File)

**File**: `AllEntitiesIncludingStatic.bootstrap.sql`

**Location**: `{OutputDirectory}/Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql`

**Content**:
- ALL entities (static + regular) in global topological order
- MERGE statements for all entities (idempotent)
- Header comments showing topological position and dependencies
- GO statements between entities for transaction boundaries

**Characteristics**:
- Generated once per export
- **Not version controlled** (add to .gitignore)
- Used only for first deployment
- Self-contained (no external dependencies)

**Example Structure**:
```sql
--------------------------------------------------------------------------------
-- Bootstrap Snapshot: All Entities (Static + Regular)
-- Generated: 2025-11-18
-- Total Entities: 87 (42 static, 45 regular)
-- Sorted: Global topological order
--------------------------------------------------------------------------------

-- Entity: Role (dbo.OSSYS_ROLE)
-- Topological Order: 1 of 87 (no dependencies)
-- Type: Static
MERGE INTO [dbo].[OSSYS_ROLE] AS Target
USING (VALUES ...) AS Source (...)
ON Target.[Id] = Source.[Id]
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
GO

-- Entity: User (dbo.OSSYS_USER)
-- Topological Order: 2 of 87 (depends on: Role)
-- Type: Static
MERGE INTO [dbo].[OSSYS_USER] AS Target
USING (VALUES ...) AS Source (...)
ON Target.[Id] = Source.[Id]
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
GO

-- ... continues for all 87 entities ...
```

### 2. PostDeployment Bootstrap Template (NEW!)

**File**: `PostDeployment-Bootstrap.sql`

**Location**: `{OutputDirectory}/PostDeployment-Bootstrap.sql`

**Purpose**: Ready-to-copy PostDeployment script for SSDT that conditionally applies bootstrap and baseline seeds

**Content**: Guard logic + dynamic `:r` includes

**Example (Single-File Baseline Seeds Mode)**:
```sql
--------------------------------------------------------------------------------
-- PostDeployment Bootstrap Script
-- Generated: 2025-11-18
-- Usage: Copy to SSDT project's PostDeployment folder
--------------------------------------------------------------------------------

-- Guard: Only apply bootstrap snapshot on first deployment
IF NOT EXISTS (SELECT 1 FROM [dbo].[OSSYS_ROLE])
BEGIN
    PRINT 'First deployment detected - applying bootstrap snapshot';
    PRINT 'Loading: Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql';

    :r Bootstrap\AllEntitiesIncludingStatic.bootstrap.sql

    PRINT 'Bootstrap snapshot applied successfully (87 entities)';
END
ELSE
BEGIN
    PRINT 'Existing deployment detected - skipping bootstrap snapshot';
END
GO

--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds (static entities)';

:r BaselineSeeds\StaticEntities.seed.sql

PRINT 'Baseline seeds applied successfully';
GO
```

**Example (Per-Module Baseline Seeds Mode)**:
```sql
-- ... guard logic same as above ...

--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds (static entities) from multiple modules';

-- Module: Core
:r BaselineSeeds\Core\StaticEntities.seed.sql

-- Module: Security
:r BaselineSeeds\Security\StaticEntities.seed.sql

-- Module: Workflow
:r BaselineSeeds\Workflow\StaticEntities.seed.sql

PRINT 'Baseline seeds applied successfully (3 modules)';
GO
```

**Dynamic Generation Logic**:
- Read `BuildSsdtPipelineRequest.StaticSeedOptions.GroupByModule`
- If `false`: Emit single `:r` for `StaticEntities.seed.sql`
- If `true`: Emit multiple `:r` statements for each module file (in alphabetical order for readability, but doesn't matter due to idempotency)

### 3. Baseline Seeds (Existing, No Changes)

**File(s)**: `StaticEntities.seed.sql` or per-module/per-entity files

**Location**: `{OutputDirectory}/BaselineSeeds/`

**Content**: Static entities only (no change from current behavior)

**Characteristics**:
- Version controlled
- Developer-maintained
- Applied on every deployment
- Idempotent MERGE statements

## Implementation Scope

### Change 1: Generate Bootstrap Snapshot File

**New Step**: `BuildSsdtBootstrapSnapshotStep.cs`

**Purpose**: Generate `AllEntitiesIncludingStatic.bootstrap.sql` containing all entities in global topological order

**Implementation**:
```csharp
public async Task<BuildSsdtPipelineState> ExecuteAsync(
    BuildSsdtPipelineState state,
    CancellationToken cancellationToken)
{
    // 1. Combine static + regular entity datasets
    var staticEntities = state.StaticSeedData ?? ImmutableArray<StaticEntityTableData>.Empty;
    var regularEntities = state.Request.DynamicDataset?.Tables ?? ImmutableArray<StaticEntityTableData>.Empty;
    var allEntities = staticEntities.Concat(regularEntities).ToImmutableArray();

    // 2. Global topological sort (use existing EntityDependencySorter)
    var ordering = EntityDependencySorter.SortByForeignKeys(
        allEntities,
        state.Bootstrap.FilteredModel,
        state.Request.Scope.SmoOptions.NamingOverrides,
        state.Request.Scope.StaticSeedOptions.SortOptions);

    // 3. Generate MERGE script for all entities
    var bootstrapScript = GenerateBootstrapScript(ordering.Tables, state);

    // 4. Write to Bootstrap directory
    var bootstrapDirectory = Path.Combine(state.Request.OutputDirectory, "Bootstrap");
    Directory.CreateDirectory(bootstrapDirectory);
    var bootstrapPath = Path.Combine(bootstrapDirectory, "AllEntitiesIncludingStatic.bootstrap.sql");
    await File.WriteAllTextAsync(bootstrapPath, bootstrapScript, Utf8NoBom, cancellationToken);

    // 5. Log metrics
    state.Log.Record(
        "bootstrap.snapshot.generated",
        $"Generated bootstrap snapshot with {ordering.Tables.Length} entities",
        new PipelineLogMetadataBuilder()
            .WithCount("entities.total", ordering.Tables.Length)
            .WithCount("entities.static", ordering.Tables.Count(t => IsStatic(t)))
            .WithCount("entities.regular", ordering.Tables.Count(t => !IsStatic(t)))
            .WithValue("ordering.applied", ordering.TopologicalOrderingApplied)
            .Build());

    return state with { BootstrapSnapshotPath = bootstrapPath };
}
```

**Key Points**:
- Static entities ARE already in `DynamicDataset` (verified via code analysis)
- Use existing `EntityDependencySorter` for global sort
- Generate MERGE for ALL entities (reuse `StaticSeedSqlBuilder` logic)

### Change 2: Generate PostDeployment Bootstrap Template

**New Step**: `BuildSsdtPostDeploymentTemplateStep.cs`

**Purpose**: Generate `PostDeployment-Bootstrap.sql` with guard logic and dynamic `:r` includes

**Implementation**:
```csharp
public async Task<BuildSsdtPipelineState> ExecuteAsync(
    BuildSsdtPipelineState state,
    CancellationToken cancellationToken)
{
    var builder = new StringBuilder();

    // Header
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("-- PostDeployment Bootstrap Script");
    builder.AppendLine($"-- Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
    builder.AppendLine("-- Usage: Copy to SSDT project's PostDeployment folder");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine();

    // Guard: Only apply bootstrap on first deployment
    builder.AppendLine("-- Guard: Only apply bootstrap snapshot on first deployment");

    // Pick a canonical static table for the guard check
    var canonicalTable = GetCanonicalStaticTable(state);
    builder.AppendLine($"IF NOT EXISTS (SELECT 1 FROM [{canonicalTable.Schema}].[{canonicalTable.PhysicalName}])");
    builder.AppendLine("BEGIN");
    builder.AppendLine("    PRINT 'First deployment detected - applying bootstrap snapshot';");
    builder.AppendLine("    PRINT 'Loading: Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql';");
    builder.AppendLine();
    builder.AppendLine("    :r Bootstrap\\AllEntitiesIncludingStatic.bootstrap.sql");
    builder.AppendLine();
    builder.AppendLine($"    PRINT 'Bootstrap snapshot applied successfully ({state.StaticSeedData.Length + state.Request.DynamicDataset.Tables.Length} entities)';");
    builder.AppendLine("END");
    builder.AppendLine("ELSE");
    builder.AppendLine("BEGIN");
    builder.AppendLine("    PRINT 'Existing deployment detected - skipping bootstrap snapshot';");
    builder.AppendLine("END");
    builder.AppendLine("GO");
    builder.AppendLine();

    // Baseline Seeds: Dynamic includes based on emission mode
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("-- Baseline Seeds (Static Entities) - Applied on every deployment");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("PRINT 'Applying baseline seeds (static entities)';");
    builder.AppendLine();

    var seedPaths = state.StaticSeedScriptPaths;
    if (seedPaths.IsDefaultOrEmpty || seedPaths.Length == 1)
    {
        // Single file mode
        builder.AppendLine(":r BaselineSeeds\\StaticEntities.seed.sql");
    }
    else
    {
        // Per-module mode
        builder.AppendLine("PRINT 'Applying baseline seeds from multiple modules';");
        builder.AppendLine();

        foreach (var seedPath in seedPaths.OrderBy(p => p))
        {
            var relativePath = GetRelativePathFromOutput(seedPath, state.Request.OutputDirectory);
            var moduleName = Path.GetFileName(Path.GetDirectoryName(relativePath));

            builder.AppendLine($"-- Module: {moduleName}");
            builder.AppendLine($":r {relativePath.Replace("/", "\\")}");
            builder.AppendLine();
        }
    }

    builder.AppendLine("PRINT 'Baseline seeds applied successfully';");
    builder.AppendLine("GO");

    // Write template file
    var templatePath = Path.Combine(state.Request.OutputDirectory, "PostDeployment-Bootstrap.sql");
    await File.WriteAllTextAsync(templatePath, builder.ToString(), Utf8NoBom, cancellationToken);

    state.Log.Record(
        "postDeployment.template.generated",
        "Generated PostDeployment bootstrap template",
        new PipelineLogMetadataBuilder()
            .WithPath("template", templatePath)
            .WithCount("baselineSeedFiles", seedPaths.Length)
            .Build());

    return state with { PostDeploymentTemplatePath = templatePath };
}
```

**Key Logic**:
- Guard uses first static table as "has data" indicator
- Bootstrap snapshot path is hardcoded relative path (user copies template to SSDT)
- Baseline seed includes are dynamically generated based on `GroupByModule` setting
- All paths use backslashes for Windows compatibility

### Change 3: Output Directory Restructuring

**New Structure**:
```
{OutputDirectory}/
‚îú‚îÄ‚îÄ Tables/
‚îú‚îÄ‚îÄ ForeignKeys/
‚îú‚îÄ‚îÄ Bootstrap/                              ‚Üê NEW
‚îÇ   ‚îî‚îÄ‚îÄ AllEntitiesIncludingStatic.bootstrap.sql
‚îú‚îÄ‚îÄ BaselineSeeds/                          ‚Üê RENAMED from StaticSeeds
‚îÇ   ‚îú‚îÄ‚îÄ StaticEntities.seed.sql            (single-file mode)
‚îÇ   ‚îî‚îÄ‚îÄ ModuleA/                           (per-module mode)
‚îÇ       ‚îî‚îÄ‚îÄ StaticEntities.seed.sql
‚îú‚îÄ‚îÄ DynamicData/                            ‚Üê EXISTING (unchanged)
‚îÇ   ‚îî‚îÄ‚îÄ *.dynamic.sql
‚îî‚îÄ‚îÄ PostDeployment-Bootstrap.sql            ‚Üê NEW (copy to SSDT)
```

**Changes**:
- Add `Bootstrap/` directory (gitignored)
- Rename `StaticSeeds/` ‚Üí `BaselineSeeds/` (clearer terminology)
- Add root-level `PostDeployment-Bootstrap.sql` template

### Change 4: Module Ordering (Now Lower Priority)

**Status**: Module alphabetical ordering is **no longer critical** because:

1. Bootstrap snapshot loads all data on first deployment (correct order guaranteed)
2. Baseline seeds run on subsequent deployments when data already exists (idempotent MERGE, order doesn't matter)
3. Cross-module FK violations can only occur if:
   - Bootstrap snapshot was skipped (user error)
   - Database was manually modified to remove data

**Recommendation**: Defer module topological ordering to future enhancement. Current approach solves the problem without this complexity.

**Optional Enhancement** (if desired later):
- Add warning log if cross-module FK dependencies detected
- Suggest using single-file mode instead of GroupByModule
- Or implement topological module ordering (replace line 107 alphabetical sort with topological sort of modules)

## User Workflow

### Generation (Developer runs OSM export)

```bash
osm full-export --output ./MyApp
```

**Output**:
```
MyApp/
‚îú‚îÄ‚îÄ Bootstrap/
‚îÇ   ‚îî‚îÄ‚îÄ AllEntitiesIncludingStatic.bootstrap.sql  (87 entities, topologically sorted)
‚îú‚îÄ‚îÄ BaselineSeeds/
‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql                   (42 static entities, idempotent MERGE)
‚îú‚îÄ‚îÄ DynamicData/
‚îÇ   ‚îî‚îÄ‚îÄ *.dynamic.sql                              (45 regular entities, INSERT)
‚îú‚îÄ‚îÄ PostDeployment-Bootstrap.sql                   (COPY THIS TO SSDT)
‚îî‚îÄ‚îÄ Tables/, ForeignKeys/, etc.
```

### Integration (Developer copies template to SSDT)

```bash
# Copy the generated template into SSDT project
cp MyApp/PostDeployment-Bootstrap.sql MyApp.sqlproj/PostDeployment/01-Bootstrap.sql

# Verify paths in SSDT project match expected structure
# Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql (relative to .sqlproj)
# BaselineSeeds/StaticEntities.seed.sql (relative to .sqlproj)
```

### First Deployment (SSDT to fresh database)

```
1. SSDT builds .dacpac
2. SSDT deploys:
   - Creates tables (DDL)
   - Creates FK constraints (ALTER TABLE ADD CONSTRAINT)
   - Runs PostDeployment/01-Bootstrap.sql:
     a. Guard checks: SELECT 1 FROM [OSSYS_ROLE] ‚Üí empty ‚Üí first deployment!
     b. Includes Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql
     c. All 87 entities loaded in topological order (MERGE)
     d. Includes BaselineSeeds/StaticEntities.seed.sql
     e. 42 static entities apply (no-op, already loaded via bootstrap)
```

### Ongoing Deployments (SSDT to existing database)

```
1. Developer modifies static seed data (e.g., adds new Role)
2. Updates BaselineSeeds/StaticEntities.seed.sql
3. SSDT deploys:
   - Updates schema if needed
   - Runs PostDeployment/01-Bootstrap.sql:
     a. Guard checks: SELECT 1 FROM [OSSYS_ROLE] ‚Üí has data ‚Üí skip bootstrap!
     b. Includes BaselineSeeds/StaticEntities.seed.sql
     c. 42 static entities apply (idempotent MERGE, updates new Role)
```

## Test Scenarios

### Test 1: MERGE Script Generation
```csharp
[Fact]
public void BuildMergeScript_WithCompositePrimaryKey_EmitsCorrectMerge()
{
    var definition = new StaticEntitySeedTableDefinition(
        Module: "Core",
        LogicalName: "Permission",
        Schema: "dbo",
        PhysicalName: "OSSYS_PERMISSION",
        EffectiveName: "OSSYS_PERMISSION",
        Columns: ImmutableArray.Create(
            new StaticEntitySeedColumn("RoleId", "RoleId", "RoleId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("ResourceId", "ResourceId", "ResourceId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("CanRead", "CanRead", "CanRead", "bit", null, null, null, IsPrimaryKey: false, IsIdentity: false, IsNullable: false)
        ),
        IsStatic: true);

    var rows = ImmutableArray.Create(
        StaticEntityRow.Create(new object[] {
            Guid.Parse("00000000-0000-0000-0000-000000000001"),
            Guid.Parse("00000000-0000-0000-0000-000000000002"),
            true
        }));

    var script = generator.BuildScript(definition, rows, batchSize: 1000);

    Assert.Contains("MERGE INTO [dbo].[OSSYS_PERMISSION]", script);
    Assert.Contains("ON Target.[RoleId] = Source.[RoleId] AND Target.[ResourceId] = Source.[ResourceId]", script);
    Assert.Contains("WHEN NOT MATCHED THEN", script);
    Assert.DoesNotContain("SET IDENTITY_INSERT", script);
}
```

### Test 2: Cross-Boundary FK Ordering
```csharp
[Fact]
public void SortByForeignKeys_WithStaticToRegularFK_OrdersGlobally()
{
    // Arrange: User (static) ‚Üí Department (regular)
    var model = CreateModelWithCrossBoundaryFK();
    var staticUser = CreateStaticEntityTable("User", isStatic: true, fkTo: "Department");
    var regularDept = CreateRegularEntityTable("Department", isStatic: false);
    var allEntities = ImmutableArray.Create(staticUser, regularDept);  // Wrong order

    // Act
    var result = EntityDependencySorter.SortByForeignKeys(allEntities, model);

    // Assert
    Assert.Equal("Department", result.Tables[0].Definition.LogicalName);  // Parent first
    Assert.Equal("User", result.Tables[1].Definition.LogicalName);  // Child second
    Assert.True(result.TopologicalOrderingApplied);
}
```

### Test 3: MERGE Idempotency
```csharp
[Fact]
public async Task LoadHarness_ApplyingBothStaticAndDynamic_Succeeds()
{
    // Arrange
    var db = CreateEmptyDatabase();
    await ApplyDDL(db, "tables.sql");

    var options = new LoadHarnessOptions
    {
        ConnectionString = db.ConnectionString,
        StaticSeedScriptPaths = ImmutableArray.Create("StaticEntities.seed.sql"),
        DynamicInsertScriptPaths = ImmutableArray.Create("DynamicData.all.dynamic.sql")
    };

    // Act - Apply both static seeds AND dynamic data (dynamic uses MERGE)
    var result = await loadHarnessRunner.RunAsync(options);

    // Assert - No errors, no duplicate key violations
    Assert.Empty(result.Errors);
    Assert.True(result.AllScriptsSucceeded);
}
```

## Migration Path

### Phase 1: Add `IsStatic` Field (Non-Breaking)
- Add `IsStatic` to `StaticEntitySeedTableDefinition` with default `false`
- Update `StaticEntitySeedDefinitionBuilder.Build()` to capture `IsStatic`
- Update `SqlDynamicEntityDataProvider.CreateDefinition()` to pass `IsStatic`
- **No behavior changes yet**

### Phase 2: Implement MERGE Builder
- Add `BuildMergeScript()` method
- Add unit tests for MERGE generation (simple PK, composite PK, no PK ‚Üí error)
- **Still no behavior change - MERGE not invoked yet**

### Phase 3: Feature Flag Rollout
- Add `DynamicDataIncludesStaticEntities` configuration option (default: `false`)
- When `true`:
  - `DynamicEntityInsertGenerator.BuildScript()` checks `IsStatic` ‚Üí emit MERGE
  - Verify static entities are included in dataset (or remove filter if exists)
- **Gradual rollout via feature flag**

### Phase 4: Validation & Testing
- Run exports with feature flag enabled
- Execute LoadHarness with both static + dynamic
- Monitor for FK violations, duplicate key errors
- Validate MERGE performance impact (< 10% overhead expected)

### Phase 5: Default Flip
- Change default to `DynamicDataIncludesStaticEntities = true`
- Document new behavior
- Update user guides

### Phase 6: Cleanup
- Remove feature flag (make behavior mandatory)
- Remove legacy code paths

## Success Criteria

1. ‚úÖ Dynamic data includes ALL entities (static + regular)
2. ‚úÖ Static entities in dynamic data use MERGE (idempotent)
3. ‚úÖ Global topological sort applied to complete entity set
4. ‚úÖ No FK violations during LoadHarness execution
5. ‚úÖ Existing static seed emission unchanged
6. ‚úÖ Can safely apply both static seeds + dynamic data without errors
7. ‚úÖ All existing tests pass
8. ‚úÖ New integration tests cover cross-boundary FK scenarios

## Defensive Measures for Timing/Sequencing Issues

### Issue: Potential Race Conditions Despite Correct Ordering

User observation: "Even when parent and child are in correct order, FK constraint violations occur. When checking afterward, both tables have data - it was just the FK constraint check that failed."

### Root Cause Analysis

**Verified**: Static entities ARE included in dynamic data (not filtered by `IsStatic`). The issue is that static and regular entities are **sorted separately** before being combined, breaking cross-boundary FK dependencies.

**Additional Concerns**:
1. **Junction table prioritization**: Ensure parent ‚Üí child ‚Üí junction ordering, not just alphabetical
2. **Execution boundaries**: Ensure each entity's INSERT completes before dependent entities execute
3. **FK constraint timing**: Verify FKs are created in DDL phase and remain active during data load

### Defensive Fixes

#### Fix 1: Verify Junction Table Deferral Works Across Static/Regular Boundary

**Existing code**: `JunctionTableClassifier` (line 616-782) identifies junction tables by:
- Entity has 2+ FK relationships to different tables (line 743-745)
- All non-PK columns are FKs (line 748-759)
- Junction tables get lower priority in sort (line 821: `ReadyQueueComparer`)

**Risk**: If junction classification only runs on static OR regular entities separately, cross-boundary junctions (e.g., static User + regular Department ‚Üí junction UserDepartment) may not be detected.

**Verification Required**:
- Ensure junction classification runs on **combined static + regular set**
- Test: Junction with 1 FK to static, 1 FK to regular entity

#### Fix 2: Add Explicit GO Statements Between Parent/Child Batches

**Current**: Each entity script has internal GO statements (line 773), but may need explicit boundary between entities in single-file mode.

**Proposed**: In `WriteSingleFileScriptAsync()`, add defensive GO between scripts:

```csharp
foreach (var script in scripts)
{
    cancellationToken.ThrowIfCancellationRequested();

    builder.AppendLine(script.Script.TrimEnd());
    builder.AppendLine();
    builder.AppendLine("GO");  // ‚Üê DEFENSIVE: Ensure transaction boundary
    builder.AppendLine("-- ===== Entity boundary =====");
    builder.AppendLine();
}
```

**Rationale**: Even though each script ends with GO, an explicit boundary ensures previous entity's data is fully committed before next entity begins.

#### Fix 3: Add Per-Entity Commit PRINT Statements

**Proposed**: Add diagnostic output to verify execution order and completion:

```csharp
private string BuildMergeScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] ‚úì Completed MERGE for {definition.Schema}.{definition.PhysicalName} (static entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}

private string BuildInsertScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] ‚úì Completed INSERT for {definition.Schema}.{definition.PhysicalName} (regular entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}
```

**Benefit**: LoadHarness output will show exactly which entities completed before FK violation occurs.

#### Fix 4: Validate FK Constraint State Before Data Load

**Proposed**: Add preflight check in LoadHarness to verify FK constraints exist and are enabled:

```sql
-- Query sys.foreign_keys to list all FK constraints
-- Verify is_disabled = 0 (enabled)
-- Verify is_not_trusted = 0 (trusted, checks existing data)
-- Log any disabled or untrusted FKs as warnings
```

**Benefit**: Catches scenarios where FKs are created WITH NOCHECK or disabled, which would mask ordering issues.

#### Fix 5: Add Topological Ordering Validation in Generated Scripts

**Proposed**: Emit comment header in each script showing its topological position:

```sql
--------------------------------------------------------------------------------
-- Entity: User (dbo.OSSYS_USER)
-- Topological Order: 15 of 87
-- Dependencies: Role (14), Department (12)  -- ‚Üê Shows parent positions
-- Dependents: AuditLog (23), Session (31)  -- ‚Üê Shows child positions
--------------------------------------------------------------------------------
```

**Benefit**: Easy visual verification that scripts are in correct order during debugging.

## Open Questions for User

1. **What is the exact error message you saw?**
   - `"The INSERT statement conflicted with the FOREIGN KEY constraint..."`?
   - Which table (parent or child)?
   - Which FK constraint name?

2. **What is your LoadHarness execution sequence?**
   - Safe scripts ‚Üí Remediation ‚Üí Static seeds ‚Üí Dynamic data?
   - Or different order?

3. **Which output mode are you using?**
   - `DynamicInsertOutputMode.PerEntity` (separate files)?
   - `DynamicInsertOutputMode.SingleFile` (consolidated)?

4. **How are FK constraints created?**
   - Inline in CREATE TABLE?
   - Separate ALTER TABLE ADD CONSTRAINT?
   - WITH CHECK or WITH NOCHECK?

5. **Are you seeing this with specific entity pairs?**
   - Can you provide example: `Table A (static/regular) ‚Üí FK ‚Üí Table B (static/regular)`?

## Implementation Priority

### Phase 1: Core Fix (2-3 days)
1. ‚úÖ Verify static entities are included (CONFIRMED - they are)
2. ‚úÖ Implement global topological sort (use existing `EntityDependencySorter` on combined set)
3. ‚úÖ Add MERGE emission for static entities
4. ‚úÖ Verify junction table deferral works cross-boundary

### Phase 2: Defensive Hardening (1 day)
5. ‚úÖ Add explicit GO between entities in single-file mode
6. ‚úÖ Add PRINT statements for execution tracing
7. ‚úÖ Add topological position comments in scripts
8. ‚úÖ Add FK constraint state validation

### Phase 3: Testing & Validation (2-3 days)
9. Integration tests with cross-boundary FKs
10. LoadHarness execution with diagnostic output
11. Verify junction table ordering
12. Test with both PerEntity and SingleFile modes

## Next Steps

1. **User provides**: Error message, execution sequence, specific failing tables
2. **Investigation**: Reproduce FK violation with minimal test case
3. **Implementation**: Global sort + MERGE + defensive boundaries
4. **Validation**: Verify fix resolves both ordering AND timing issues

---

## Summary

### Files Emitted by M1.0

| File | Purpose | Version Control | Used When |
|------|---------|----------------|-----------|
| `AllEntitiesIncludingStatic.bootstrap.sql` | Complete dataset (87 entities) topologically sorted | ‚ùå Gitignored | First deployment only |
| `PostDeployment-Bootstrap.sql` | SSDT PostDeployment template with guard + includes | ‚úÖ Copy to SSDT once | Every deployment (guard skips bootstrap after first) |
| `StaticEntities.seed.sql` | Baseline seeds (42 static entities) | ‚úÖ Committed | Every deployment (idempotent) |

### Why This Solves the Problem

**Original Issue**: Static seed files ordered alphabetically by module ‚Üí cross-module FK violations

**M1.0 Solution**:
1. **First deployment uses bootstrap snapshot** (global topological order, no module partitioning) ‚Üí FK dependencies satisfied
2. **Subsequent deployments use baseline seeds** (data already exists from bootstrap, MERGE is idempotent) ‚Üí order doesn't matter
3. **Module ordering becomes irrelevant** ‚Üí baseline seeds can be organized however is convenient for developers

### Implementation Effort

| Task | Effort | Files Changed |
|------|--------|---------------|
| Generate bootstrap snapshot | 1 day | NEW: `BuildSsdtBootstrapSnapshotStep.cs` |
| Generate PostDeployment template | 0.5 days | NEW: `BuildSsdtPostDeploymentTemplateStep.cs` |
| Update directory structure | 0.5 days | Rename StaticSeeds ‚Üí BaselineSeeds, add Bootstrap/ |
| Testing & documentation | 1 day | Integration tests, user docs |
| **Total** | **3 days** | |

**Conclusion**: M1.0 solves the FK constraint violation problem by:
1. **Bootstrap Snapshot**: First deployment uses global topological order (correct)
2. **Baseline Seeds**: Ongoing deployments use idempotent MERGE (order irrelevant)
3. **Clean Separation**: Administrative efficiency (bootstrap) vs. developer-maintained (baseline seeds)
