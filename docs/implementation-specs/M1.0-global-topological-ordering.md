# M1.0: Global Topological Ordering for Dynamic Data

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION
**Estimated Effort**: 2-3 days

## Executive Summary

This specification addresses FK constraint violations during data loading by ensuring dynamic data contains ALL entities (static + regular) in topologically sorted order, with static entities using MERGE for idempotency.

**Key Finding**: After comprehensive codebase analysis, **most infrastructure already exists**. This is not about building new sorting infrastructure - it's about applying existing topological sorting to the complete entity set and adding MERGE emission.

## Problem Statement

### Current Behavior

**Static Entities**:
- Extracted separately
- Topologically sorted via `EntityDependencySorter.SortByForeignKeys()` âœ…
- Emitted as `StaticEntities.seed.sql`

**Regular Entities**:
- Extracted separately
- Topologically sorted via `EntityDependencySorter.SortByForeignKeys()` âœ…
- Emitted as `DynamicData/*.dynamic.sql`

**LoadHarness Execution**:
1. Apply static seeds
2. Apply dynamic data

**Issue**: Cross-boundary FK dependencies between static and regular entities can cause violations:
- Example: Static entity `User` depends on regular entity `Department` â†’ `User` inserted before `Department` â†’ âŒ FK violation

### Desired Behavior

**Dynamic Data** = **ALL entities** (static + regular):
- Build ONE global dependency graph for complete entity set
- Topologically sort using existing `EntityDependencySorter`
- Emit in FK-safe order
- Static entities use **MERGE** for idempotency (can be safely re-applied)

**Static Seeds** = Static entities only (unchanged):
- Source of truth for ongoing development
- Version controlled, developer-edited
- Applied via stub loader

## Codebase Reality Check - What Already Exists

### âœ… Infrastructure ALREADY Implemented

| Component | File | Lines | Status |
|-----------|------|-------|--------|
| **FK-aware topological sorting** | `EntityDependencySorter.cs` | 967 | âœ… Complete |
| **Kahn's algorithm** | `EntityDependencySorter.TopologicalSort()` | 264-302 | âœ… Implemented |
| **Cycle detection + fallback** | `EntityDependencySorter.SortByForeignKeys()` | 122-156 | âœ… Implemented |
| **Junction table deferral** | `JunctionTableClassifier` | 616-782 | âœ… Implemented |
| **Self-referencing FK ordering** | `DynamicEntityInsertGenerator.OrderRows()` | 152-405 | âœ… Implemented |
| **FK preflight validation** | `StaticSeedForeignKeyPreflight.cs` | 217 | âœ… Implemented |
| **SMO enrichment** | `RelationshipConstraintHydrator.cs` | 292 | âœ… **EXISTS!** |
| **LoadHarness trust manifest** | `LoadHarnessRunner.BuildScriptQueue()` | 169-206 | âœ… Verified |
| **Ordering telemetry** | `BuildSsdtStaticSeedStep.cs` | 158-172 | âœ… Implemented |

### ğŸ” SMO Enrichment Discovery

**File**: `src/Osm.Pipeline/ModelIngestion/RelationshipConstraintMetadataProvider.cs`

**Key Query** (lines 72-94):
```csharp
SELECT
    mc.SchemaName,
    mc.TableName,
    mc.ConstraintName,
    fkc.constraint_column_id AS Ordinal,
    parent_col.name AS ParentColumn,
    ref_col.name AS ReferencedColumn,
    ref_schema.name AS ReferencedSchema,
    ref_table.name AS ReferencedTable
FROM MissingConstraints mc
JOIN sys.schemas parent_schema ON parent_schema.name = mc.SchemaName
JOIN sys.tables parent_table ON parent_table.schema_id = parent_schema.schema_id AND parent_table.name = mc.TableName
JOIN sys.foreign_keys fk ON fk.parent_object_id = parent_table.object_id AND fk.name = mc.ConstraintName
JOIN sys.foreign_key_columns fkc ON fkc.constraint_object_id = fk.object_id
-- ... (joins to get column names)
```

**Usage**: `RelationshipConstraintHydrator.HydrateAsync()` (line 30-68)
- Finds relationships with missing constraint metadata (`NeedsHydration()`)
- Queries SQL Server via `sys.foreign_keys` to get actual FK column mappings
- Enriches the `OsmModel` with complete FK metadata

**This is EXACTLY the SMO enrichment I thought was missing - it already exists and runs during model extraction!**

### âŒ What Is Actually Missing

| Gap | Current Impact | M1.0 Scope |
|-----|----------------|------------|
| **Dynamic data excludes static entities** | Static/dynamic sorted separately, cross-boundary FKs fail | âœ… Must fix |
| **No MERGE for static entities** | Cannot safely apply both static seeds + dynamic data | âœ… Must fix |
| **Module partitioning breaks order** | When `GroupByModule=true`, files ordered alphabetically | âš ï¸ Detect + warn |

## Implementation Scope

### Change 1: Include Static Entities in Dynamic Data

**Current Code**: `SqlDynamicEntityDataProvider.SeedInitialEntities()` (line 245-277)

```csharp
foreach (var entity in module.Entities)
{
    if (!ShouldIncludeEntity(entity, moduleFilter, entityFilter))
    {
        continue;
    }
    // ... queue for extraction
}
```

**`ShouldIncludeEntity()` check** (line 807-823):
```csharp
private static bool ShouldIncludeEntity(
    EntityModel entity,
    ModuleFilterOptions filter,
    ModuleEntityFilterOptions? entityFilter)
{
    if (!filter.IncludeInactiveModules && !entity.IsActive)
    {
        return false;
    }

    if (entityFilter is null)
    {
        return true;
    }

    return entityFilter.Matches(entity);
}
```

**Finding**: `IsStatic` is NOT checked here! Static entities should already be included unless filtered out by custom `entityFilter`.

**Investigation Required**:
1. Search for where `entityFilter` is configured
2. Check if there's a default filter that excludes `IsStatic` entities
3. Verify with actual export: does `DynamicDataset` currently include static entities?

**Expected Change** (if filtering exists):
- Remove or disable the filter that excludes static entities
- OR: Add configuration option `IncludeStaticInDynamicData` (default: `true`)

### Change 2: MERGE Emission for Static Entities

**Current Code**: `DynamicEntityInsertGenerator.BuildScript()` (lines 712-784)
- Always emits standard INSERT
- Uses `SET IDENTITY_INSERT` for identity columns

**Required Change**: Detect static entities and emit MERGE

**Step 1**: Add `IsStatic` to `StaticEntitySeedTableDefinition`

```csharp
public sealed record StaticEntitySeedTableDefinition(
    string Module,
    string LogicalName,
    string Schema,
    string PhysicalName,
    string EffectiveName,
    ImmutableArray<StaticEntitySeedColumn> Columns,
    bool IsStatic)  // â† NEW field
{
    // Existing Empty with IsStatic = false for backward compat
    public static StaticEntitySeedTableDefinition Empty { get; } =
        new(string.Empty, string.Empty, string.Empty, string.Empty, string.Empty,
            ImmutableArray<StaticEntitySeedColumn>.Empty, IsStatic: false);
}
```

**Propagation Path**:
1. `EntityModel.IsStatic` (source of truth)
2. `StaticEntitySeedDefinitionBuilder.Build()` - Capture `IsStatic` from `EntityModel` (line 109)
3. `SqlDynamicEntityDataProvider.CreateDefinition()` - Pass `IsStatic` to definition (line 748)
4. `StaticEntitySeedTableDefinition` - Store flag
5. `DynamicEntityInsertGenerator.GenerateScripts()` - Read flag to choose INSERT vs MERGE

**Step 2**: Add MERGE script builder

```csharp
private string BuildMergeScript(
    StaticEntitySeedTableDefinition definition,
    ImmutableArray<StaticEntityRow> rows,
    int batchSize)
{
    var builder = new StringBuilder();
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine($"-- Module: {definition.Module}");
    builder.AppendLine($"-- Entity: {definition.LogicalName} ({definition.Schema}.{definition.PhysicalName})");
    builder.AppendLine($"-- IDEMPOTENT MERGE (Static Entity)");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine();
    builder.AppendLine("SET NOCOUNT ON;");
    builder.AppendLine();

    var targetIdentifier = SqlIdentifierFormatter.Qualify(definition.Schema, definition.EffectiveName);
    var columnNames = definition.Columns
        .Select(column => SqlIdentifierFormatter.Quote(column.EffectiveColumnName))
        .ToArray();

    var primaryKeyColumns = definition.Columns
        .Where(c => c.IsPrimaryKey)
        .ToArray();

    if (primaryKeyColumns.Length == 0)
    {
        throw new InvalidOperationException(
            $"Cannot emit MERGE for static entity '{definition.Schema}.{definition.PhysicalName}' - no primary key defined. " +
            "Static entities must have a primary key for idempotent MERGE.");
    }

    var batches = PartitionRows(rows, batchSize).ToArray();
    for (var batchIndex = 0; batchIndex < batches.Length; batchIndex++)
    {
        var batchRows = batches[batchIndex];
        builder.AppendLine($"PRINT 'Applying batch {batchIndex + 1} for {targetIdentifier} ({batchRows.Length} rows)';");
        builder.AppendLine($"MERGE INTO {targetIdentifier} AS Target");
        builder.AppendLine("USING (VALUES");

        // Emit VALUES rows
        for (var rowIndex = 0; rowIndex < batchRows.Length; rowIndex++)
        {
            var row = batchRows[rowIndex];
            builder.Append("    (");
            for (var columnIndex = 0; columnIndex < definition.Columns.Length; columnIndex++)
            {
                if (columnIndex > 0) builder.Append(", ");
                builder.Append(_literalFormatter.FormatValue(row.Values[columnIndex]));
            }
            builder.Append(')');
            if (rowIndex < batchRows.Length - 1) builder.Append(',');
            builder.AppendLine();
        }

        builder.AppendLine($") AS Source ({string.Join(", ", columnNames)})");

        // ON clause - match on primary key
        var onClauses = primaryKeyColumns.Select(pk =>
            $"Target.[{pk.EffectiveColumnName}] = Source.[{pk.EffectiveColumnName}]");
        builder.AppendLine($"ON {string.Join(" AND ", onClauses)}");

        // WHEN NOT MATCHED
        builder.AppendLine("WHEN NOT MATCHED THEN");
        builder.AppendLine($"    INSERT ({string.Join(", ", columnNames)})");
        builder.AppendLine($"    VALUES ({string.Join(", ", columnNames.Select(c => "Source." + c))});");
        builder.AppendLine("GO");
        builder.AppendLine();
    }

    return builder.ToString();
}
```

**Step 3**: Modify `BuildScript()` to choose INSERT vs MERGE

```csharp
private string BuildScript(
    StaticEntitySeedTableDefinition definition,
    ImmutableArray<StaticEntityRow> rows,
    int batchSize)
{
    if (definition.IsStatic)
    {
        return BuildMergeScript(definition, rows, batchSize);
    }
    else
    {
        return BuildInsertScript(definition, rows, batchSize);  // Existing logic
    }
}
```

### Change 3: Module Ordering Validation (Secondary)

**Current Code**: `BuildSsdtStaticSeedStep.cs` (lines 102-137)
- Groups static seeds by module
- Orders modules **alphabetically** (line 107)

**Risk**: Alphabetical module order may violate FK dependencies

**Solution**: Add preflight validation

```csharp
private static void ValidateModuleOrdering(
    IReadOnlyList<StaticEntityTableData> orderedTables,
    string[] alphabeticalModules,
    PipelineExecutionLogBuilder log)
{
    // Build module dependency graph
    var moduleDeps = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);

    foreach (var table in orderedTables)
    {
        var module = table.Definition.Module;
        if (!moduleDeps.ContainsKey(module))
        {
            moduleDeps[module] = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        }

        // Check if this table has FKs to other modules
        // (requires access to model relationships - deferred for now)
    }

    // Compare alphabetical order to topological order
    // Log warnings if violations detected
}
```

**Defer**: This is lower priority - only matters if `GroupByModule=true` and cross-module FKs exist.

## Data Flow

### Current Flow (Separate Sorting)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Static Entities Only                 â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ StaticEntities.seed.sql           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Regular Entities Only                â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ DynamicData/*.dynamic.sql         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LoadHarness:
  1. Static seeds
  2. Dynamic data
```

### Proposed Flow (Global Sorting)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Static Entities Only                 â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ StaticEntities.seed.sql           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ALL Entities (Static + Regular)      â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ DynamicData/*.dynamic.sql         â”‚
â”‚     - Regular: INSERT                â”‚
â”‚     - Static: MERGE (idempotent)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LoadHarness (First Deployment):
  1. Dynamic data (complete, self-contained)

LoadHarness (Ongoing Development):
  1. Static seeds (developer-edited)
  2. Dynamic data (includes static with MERGE - idempotent)
```

## Test Scenarios

### Test 1: MERGE Script Generation
```csharp
[Fact]
public void BuildMergeScript_WithCompositePrimaryKey_EmitsCorrectMerge()
{
    var definition = new StaticEntitySeedTableDefinition(
        Module: "Core",
        LogicalName: "Permission",
        Schema: "dbo",
        PhysicalName: "OSSYS_PERMISSION",
        EffectiveName: "OSSYS_PERMISSION",
        Columns: ImmutableArray.Create(
            new StaticEntitySeedColumn("RoleId", "RoleId", "RoleId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("ResourceId", "ResourceId", "ResourceId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("CanRead", "CanRead", "CanRead", "bit", null, null, null, IsPrimaryKey: false, IsIdentity: false, IsNullable: false)
        ),
        IsStatic: true);

    var rows = ImmutableArray.Create(
        StaticEntityRow.Create(new object[] {
            Guid.Parse("00000000-0000-0000-0000-000000000001"),
            Guid.Parse("00000000-0000-0000-0000-000000000002"),
            true
        }));

    var script = generator.BuildScript(definition, rows, batchSize: 1000);

    Assert.Contains("MERGE INTO [dbo].[OSSYS_PERMISSION]", script);
    Assert.Contains("ON Target.[RoleId] = Source.[RoleId] AND Target.[ResourceId] = Source.[ResourceId]", script);
    Assert.Contains("WHEN NOT MATCHED THEN", script);
    Assert.DoesNotContain("SET IDENTITY_INSERT", script);
}
```

### Test 2: Cross-Boundary FK Ordering
```csharp
[Fact]
public void SortByForeignKeys_WithStaticToRegularFK_OrdersGlobally()
{
    // Arrange: User (static) â†’ Department (regular)
    var model = CreateModelWithCrossBoundaryFK();
    var staticUser = CreateStaticEntityTable("User", isStatic: true, fkTo: "Department");
    var regularDept = CreateRegularEntityTable("Department", isStatic: false);
    var allEntities = ImmutableArray.Create(staticUser, regularDept);  // Wrong order

    // Act
    var result = EntityDependencySorter.SortByForeignKeys(allEntities, model);

    // Assert
    Assert.Equal("Department", result.Tables[0].Definition.LogicalName);  // Parent first
    Assert.Equal("User", result.Tables[1].Definition.LogicalName);  // Child second
    Assert.True(result.TopologicalOrderingApplied);
}
```

### Test 3: MERGE Idempotency
```csharp
[Fact]
public async Task LoadHarness_ApplyingBothStaticAndDynamic_Succeeds()
{
    // Arrange
    var db = CreateEmptyDatabase();
    await ApplyDDL(db, "tables.sql");

    var options = new LoadHarnessOptions
    {
        ConnectionString = db.ConnectionString,
        StaticSeedScriptPaths = ImmutableArray.Create("StaticEntities.seed.sql"),
        DynamicInsertScriptPaths = ImmutableArray.Create("DynamicData.all.dynamic.sql")
    };

    // Act - Apply both static seeds AND dynamic data (dynamic uses MERGE)
    var result = await loadHarnessRunner.RunAsync(options);

    // Assert - No errors, no duplicate key violations
    Assert.Empty(result.Errors);
    Assert.True(result.AllScriptsSucceeded);
}
```

## Migration Path

### Phase 1: Add `IsStatic` Field (Non-Breaking)
- Add `IsStatic` to `StaticEntitySeedTableDefinition` with default `false`
- Update `StaticEntitySeedDefinitionBuilder.Build()` to capture `IsStatic`
- Update `SqlDynamicEntityDataProvider.CreateDefinition()` to pass `IsStatic`
- **No behavior changes yet**

### Phase 2: Implement MERGE Builder
- Add `BuildMergeScript()` method
- Add unit tests for MERGE generation (simple PK, composite PK, no PK â†’ error)
- **Still no behavior change - MERGE not invoked yet**

### Phase 3: Feature Flag Rollout
- Add `DynamicDataIncludesStaticEntities` configuration option (default: `false`)
- When `true`:
  - `DynamicEntityInsertGenerator.BuildScript()` checks `IsStatic` â†’ emit MERGE
  - Verify static entities are included in dataset (or remove filter if exists)
- **Gradual rollout via feature flag**

### Phase 4: Validation & Testing
- Run exports with feature flag enabled
- Execute LoadHarness with both static + dynamic
- Monitor for FK violations, duplicate key errors
- Validate MERGE performance impact (< 10% overhead expected)

### Phase 5: Default Flip
- Change default to `DynamicDataIncludesStaticEntities = true`
- Document new behavior
- Update user guides

### Phase 6: Cleanup
- Remove feature flag (make behavior mandatory)
- Remove legacy code paths

## Success Criteria

1. âœ… Dynamic data includes ALL entities (static + regular)
2. âœ… Static entities in dynamic data use MERGE (idempotent)
3. âœ… Global topological sort applied to complete entity set
4. âœ… No FK violations during LoadHarness execution
5. âœ… Existing static seed emission unchanged
6. âœ… Can safely apply both static seeds + dynamic data without errors
7. âœ… All existing tests pass
8. âœ… New integration tests cover cross-boundary FK scenarios

## Open Questions

1. **Are static entities currently excluded from dynamic data extraction?**
   - `ShouldIncludeEntity()` doesn't check `IsStatic`
   - Need to verify with actual export or find hidden filter

2. **What is the actual FK violation you observed?**
   - Specific tables?
   - Error message?
   - Static â†’ regular FK or regular â†’ static FK?

3. **Is `GroupByModule` enabled for static seeds?**
   - If yes, module ordering validation needed
   - If no, can defer validation

## Next Steps

1. **Investigate**: Run actual export, check if static entities are in `DynamicDataset`
2. **If excluded**: Find filter location, add configuration option to include them
3. **Implement**: `IsStatic` propagation and MERGE builder
4. **Test**: Cross-boundary FK scenarios with LoadHarness
5. **Deploy**: Phased rollout with feature flag

---

**Conclusion**: M1.0 is NOT about building new infrastructure - it's about connecting existing pieces. The heavy lifting (topological sorting, SMO enrichment, cycle detection) is already done. We just need to:
1. Ensure dynamic data includes all entities
2. Add MERGE for static entity idempotency
3. Test thoroughly before flipping default
