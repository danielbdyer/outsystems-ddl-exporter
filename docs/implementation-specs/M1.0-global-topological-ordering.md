# M1.0: Global Topological Ordering for Dynamic Data

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION
**Estimated Effort**: 2-3 days

## Executive Summary

This specification addresses FK constraint violations during data loading by ensuring dynamic data contains ALL entities (static + regular) in topologically sorted order, with static entities using MERGE for idempotency.

**Key Finding**: After comprehensive codebase analysis, **most infrastructure already exists**. This is not about building new sorting infrastructure - it's about applying existing topological sorting to the complete entity set and adding MERGE emission.

## Problem Statement

### Current Behavior

**Static Entities**:
- Extracted separately
- Topologically sorted via `EntityDependencySorter.SortByForeignKeys()` âœ…
- Emitted as `StaticEntities.seed.sql`

**Regular Entities**:
- Extracted separately
- Topologically sorted via `EntityDependencySorter.SortByForeignKeys()` âœ…
- Emitted as `DynamicData/*.dynamic.sql`

**LoadHarness Execution**:
1. Apply static seeds
2. Apply dynamic data

**Issue**: Cross-boundary FK dependencies between static and regular entities can cause violations:
- Example: Static entity `User` depends on regular entity `Department` â†’ `User` inserted before `Department` â†’ âŒ FK violation

### Desired Behavior

**Dynamic Data** = **ALL entities** (static + regular):
- Build ONE global dependency graph for complete entity set
- Topologically sort using existing `EntityDependencySorter`
- Emit in FK-safe order
- Static entities use **MERGE** for idempotency (can be safely re-applied)

**Static Seeds** = Static entities only (unchanged):
- Source of truth for ongoing development
- Version controlled, developer-edited
- Applied via stub loader

## Codebase Reality Check - What Already Exists

### âœ… Infrastructure ALREADY Implemented

| Component | File | Lines | Status |
|-----------|------|-------|--------|
| **FK-aware topological sorting** | `EntityDependencySorter.cs` | 967 | âœ… Complete |
| **Kahn's algorithm** | `EntityDependencySorter.TopologicalSort()` | 264-302 | âœ… Implemented |
| **Cycle detection + fallback** | `EntityDependencySorter.SortByForeignKeys()` | 122-156 | âœ… Implemented |
| **Junction table deferral** | `JunctionTableClassifier` | 616-782 | âœ… Implemented |
| **Self-referencing FK ordering** | `DynamicEntityInsertGenerator.OrderRows()` | 152-405 | âœ… Implemented |
| **FK preflight validation** | `StaticSeedForeignKeyPreflight.cs` | 217 | âœ… Implemented |
| **SMO enrichment** | `RelationshipConstraintHydrator.cs` | 292 | âœ… **EXISTS!** |
| **LoadHarness trust manifest** | `LoadHarnessRunner.BuildScriptQueue()` | 169-206 | âœ… Verified |
| **Ordering telemetry** | `BuildSsdtStaticSeedStep.cs` | 158-172 | âœ… Implemented |

### ğŸ” SMO Enrichment Discovery

**File**: `src/Osm.Pipeline/ModelIngestion/RelationshipConstraintMetadataProvider.cs`

**Key Query** (lines 72-94):
```csharp
SELECT
    mc.SchemaName,
    mc.TableName,
    mc.ConstraintName,
    fkc.constraint_column_id AS Ordinal,
    parent_col.name AS ParentColumn,
    ref_col.name AS ReferencedColumn,
    ref_schema.name AS ReferencedSchema,
    ref_table.name AS ReferencedTable
FROM MissingConstraints mc
JOIN sys.schemas parent_schema ON parent_schema.name = mc.SchemaName
JOIN sys.tables parent_table ON parent_table.schema_id = parent_schema.schema_id AND parent_table.name = mc.TableName
JOIN sys.foreign_keys fk ON fk.parent_object_id = parent_table.object_id AND fk.name = mc.ConstraintName
JOIN sys.foreign_key_columns fkc ON fkc.constraint_object_id = fk.object_id
-- ... (joins to get column names)
```

**Usage**: `RelationshipConstraintHydrator.HydrateAsync()` (line 30-68)
- Finds relationships with missing constraint metadata (`NeedsHydration()`)
- Queries SQL Server via `sys.foreign_keys` to get actual FK column mappings
- Enriches the `OsmModel` with complete FK metadata

**This is EXACTLY the SMO enrichment I thought was missing - it already exists and runs during model extraction!**

### âŒ What Is Actually Missing

| Gap | Current Impact | M1.0 Scope |
|-----|----------------|------------|
| **Dynamic data excludes static entities** | Static/dynamic sorted separately, cross-boundary FKs fail | âœ… Must fix |
| **No MERGE for static entities** | Cannot safely apply both static seeds + dynamic data | âœ… Must fix |
| **Module partitioning breaks order** | When `GroupByModule=true`, files ordered alphabetically | âš ï¸ Detect + warn |

## Implementation Scope

### Change 1: Include Static Entities in Dynamic Data

**Current Code**: `SqlDynamicEntityDataProvider.SeedInitialEntities()` (line 245-277)

```csharp
foreach (var entity in module.Entities)
{
    if (!ShouldIncludeEntity(entity, moduleFilter, entityFilter))
    {
        continue;
    }
    // ... queue for extraction
}
```

**`ShouldIncludeEntity()` check** (line 807-823):
```csharp
private static bool ShouldIncludeEntity(
    EntityModel entity,
    ModuleFilterOptions filter,
    ModuleEntityFilterOptions? entityFilter)
{
    if (!filter.IncludeInactiveModules && !entity.IsActive)
    {
        return false;
    }

    if (entityFilter is null)
    {
        return true;
    }

    return entityFilter.Matches(entity);
}
```

**Finding**: `IsStatic` is NOT checked here! Static entities should already be included unless filtered out by custom `entityFilter`.

**Investigation Required**:
1. Search for where `entityFilter` is configured
2. Check if there's a default filter that excludes `IsStatic` entities
3. Verify with actual export: does `DynamicDataset` currently include static entities?

**Expected Change** (if filtering exists):
- Remove or disable the filter that excludes static entities
- OR: Add configuration option `IncludeStaticInDynamicData` (default: `true`)

### Change 2: MERGE Emission for Static Entities

**Current Code**: `DynamicEntityInsertGenerator.BuildScript()` (lines 712-784)
- Always emits standard INSERT
- Uses `SET IDENTITY_INSERT` for identity columns

**Required Change**: Detect static entities and emit MERGE

**Step 1**: Add `IsStatic` to `StaticEntitySeedTableDefinition`

```csharp
public sealed record StaticEntitySeedTableDefinition(
    string Module,
    string LogicalName,
    string Schema,
    string PhysicalName,
    string EffectiveName,
    ImmutableArray<StaticEntitySeedColumn> Columns,
    bool IsStatic)  // â† NEW field
{
    // Existing Empty with IsStatic = false for backward compat
    public static StaticEntitySeedTableDefinition Empty { get; } =
        new(string.Empty, string.Empty, string.Empty, string.Empty, string.Empty,
            ImmutableArray<StaticEntitySeedColumn>.Empty, IsStatic: false);
}
```

**Propagation Path**:
1. `EntityModel.IsStatic` (source of truth)
2. `StaticEntitySeedDefinitionBuilder.Build()` - Capture `IsStatic` from `EntityModel` (line 109)
3. `SqlDynamicEntityDataProvider.CreateDefinition()` - Pass `IsStatic` to definition (line 748)
4. `StaticEntitySeedTableDefinition` - Store flag
5. `DynamicEntityInsertGenerator.GenerateScripts()` - Read flag to choose INSERT vs MERGE

**Step 2**: Add MERGE script builder

```csharp
private string BuildMergeScript(
    StaticEntitySeedTableDefinition definition,
    ImmutableArray<StaticEntityRow> rows,
    int batchSize)
{
    var builder = new StringBuilder();
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine($"-- Module: {definition.Module}");
    builder.AppendLine($"-- Entity: {definition.LogicalName} ({definition.Schema}.{definition.PhysicalName})");
    builder.AppendLine($"-- IDEMPOTENT MERGE (Static Entity)");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine();
    builder.AppendLine("SET NOCOUNT ON;");
    builder.AppendLine();

    var targetIdentifier = SqlIdentifierFormatter.Qualify(definition.Schema, definition.EffectiveName);
    var columnNames = definition.Columns
        .Select(column => SqlIdentifierFormatter.Quote(column.EffectiveColumnName))
        .ToArray();

    var primaryKeyColumns = definition.Columns
        .Where(c => c.IsPrimaryKey)
        .ToArray();

    if (primaryKeyColumns.Length == 0)
    {
        throw new InvalidOperationException(
            $"Cannot emit MERGE for static entity '{definition.Schema}.{definition.PhysicalName}' - no primary key defined. " +
            "Static entities must have a primary key for idempotent MERGE.");
    }

    var batches = PartitionRows(rows, batchSize).ToArray();
    for (var batchIndex = 0; batchIndex < batches.Length; batchIndex++)
    {
        var batchRows = batches[batchIndex];
        builder.AppendLine($"PRINT 'Applying batch {batchIndex + 1} for {targetIdentifier} ({batchRows.Length} rows)';");
        builder.AppendLine($"MERGE INTO {targetIdentifier} AS Target");
        builder.AppendLine("USING (VALUES");

        // Emit VALUES rows
        for (var rowIndex = 0; rowIndex < batchRows.Length; rowIndex++)
        {
            var row = batchRows[rowIndex];
            builder.Append("    (");
            for (var columnIndex = 0; columnIndex < definition.Columns.Length; columnIndex++)
            {
                if (columnIndex > 0) builder.Append(", ");
                builder.Append(_literalFormatter.FormatValue(row.Values[columnIndex]));
            }
            builder.Append(')');
            if (rowIndex < batchRows.Length - 1) builder.Append(',');
            builder.AppendLine();
        }

        builder.AppendLine($") AS Source ({string.Join(", ", columnNames)})");

        // ON clause - match on primary key
        var onClauses = primaryKeyColumns.Select(pk =>
            $"Target.[{pk.EffectiveColumnName}] = Source.[{pk.EffectiveColumnName}]");
        builder.AppendLine($"ON {string.Join(" AND ", onClauses)}");

        // WHEN NOT MATCHED
        builder.AppendLine("WHEN NOT MATCHED THEN");
        builder.AppendLine($"    INSERT ({string.Join(", ", columnNames)})");
        builder.AppendLine($"    VALUES ({string.Join(", ", columnNames.Select(c => "Source." + c))});");
        builder.AppendLine("GO");
        builder.AppendLine();
    }

    return builder.ToString();
}
```

**Step 3**: Modify `BuildScript()` to choose INSERT vs MERGE

```csharp
private string BuildScript(
    StaticEntitySeedTableDefinition definition,
    ImmutableArray<StaticEntityRow> rows,
    int batchSize)
{
    if (definition.IsStatic)
    {
        return BuildMergeScript(definition, rows, batchSize);
    }
    else
    {
        return BuildInsertScript(definition, rows, batchSize);  // Existing logic
    }
}
```

### Change 3: Module Ordering Validation (Secondary)

**Current Code**: `BuildSsdtStaticSeedStep.cs` (lines 102-137)
- Groups static seeds by module
- Orders modules **alphabetically** (line 107)

**Risk**: Alphabetical module order may violate FK dependencies

**Solution**: Add preflight validation

```csharp
private static void ValidateModuleOrdering(
    IReadOnlyList<StaticEntityTableData> orderedTables,
    string[] alphabeticalModules,
    PipelineExecutionLogBuilder log)
{
    // Build module dependency graph
    var moduleDeps = new Dictionary<string, HashSet<string>>(StringComparer.OrdinalIgnoreCase);

    foreach (var table in orderedTables)
    {
        var module = table.Definition.Module;
        if (!moduleDeps.ContainsKey(module))
        {
            moduleDeps[module] = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
        }

        // Check if this table has FKs to other modules
        // (requires access to model relationships - deferred for now)
    }

    // Compare alphabetical order to topological order
    // Log warnings if violations detected
}
```

**Defer**: This is lower priority - only matters if `GroupByModule=true` and cross-module FKs exist.

## Data Flow

### Current Flow (Separate Sorting)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Static Entities Only                 â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ StaticEntities.seed.sql           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Regular Entities Only                â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ DynamicData/*.dynamic.sql         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LoadHarness:
  1. Static seeds
  2. Dynamic data
```

### Proposed Flow (Global Sorting)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Static Entities Only                 â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ StaticEntities.seed.sql           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ALL Entities (Static + Regular)      â”‚
â”‚  â†’ EntityDependencySorter            â”‚
â”‚  â†’ DynamicData/*.dynamic.sql         â”‚
â”‚     - Regular: INSERT                â”‚
â”‚     - Static: MERGE (idempotent)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LoadHarness (First Deployment):
  1. Dynamic data (complete, self-contained)

LoadHarness (Ongoing Development):
  1. Static seeds (developer-edited)
  2. Dynamic data (includes static with MERGE - idempotent)
```

## Test Scenarios

### Test 1: MERGE Script Generation
```csharp
[Fact]
public void BuildMergeScript_WithCompositePrimaryKey_EmitsCorrectMerge()
{
    var definition = new StaticEntitySeedTableDefinition(
        Module: "Core",
        LogicalName: "Permission",
        Schema: "dbo",
        PhysicalName: "OSSYS_PERMISSION",
        EffectiveName: "OSSYS_PERMISSION",
        Columns: ImmutableArray.Create(
            new StaticEntitySeedColumn("RoleId", "RoleId", "RoleId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("ResourceId", "ResourceId", "ResourceId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("CanRead", "CanRead", "CanRead", "bit", null, null, null, IsPrimaryKey: false, IsIdentity: false, IsNullable: false)
        ),
        IsStatic: true);

    var rows = ImmutableArray.Create(
        StaticEntityRow.Create(new object[] {
            Guid.Parse("00000000-0000-0000-0000-000000000001"),
            Guid.Parse("00000000-0000-0000-0000-000000000002"),
            true
        }));

    var script = generator.BuildScript(definition, rows, batchSize: 1000);

    Assert.Contains("MERGE INTO [dbo].[OSSYS_PERMISSION]", script);
    Assert.Contains("ON Target.[RoleId] = Source.[RoleId] AND Target.[ResourceId] = Source.[ResourceId]", script);
    Assert.Contains("WHEN NOT MATCHED THEN", script);
    Assert.DoesNotContain("SET IDENTITY_INSERT", script);
}
```

### Test 2: Cross-Boundary FK Ordering
```csharp
[Fact]
public void SortByForeignKeys_WithStaticToRegularFK_OrdersGlobally()
{
    // Arrange: User (static) â†’ Department (regular)
    var model = CreateModelWithCrossBoundaryFK();
    var staticUser = CreateStaticEntityTable("User", isStatic: true, fkTo: "Department");
    var regularDept = CreateRegularEntityTable("Department", isStatic: false);
    var allEntities = ImmutableArray.Create(staticUser, regularDept);  // Wrong order

    // Act
    var result = EntityDependencySorter.SortByForeignKeys(allEntities, model);

    // Assert
    Assert.Equal("Department", result.Tables[0].Definition.LogicalName);  // Parent first
    Assert.Equal("User", result.Tables[1].Definition.LogicalName);  // Child second
    Assert.True(result.TopologicalOrderingApplied);
}
```

### Test 3: MERGE Idempotency
```csharp
[Fact]
public async Task LoadHarness_ApplyingBothStaticAndDynamic_Succeeds()
{
    // Arrange
    var db = CreateEmptyDatabase();
    await ApplyDDL(db, "tables.sql");

    var options = new LoadHarnessOptions
    {
        ConnectionString = db.ConnectionString,
        StaticSeedScriptPaths = ImmutableArray.Create("StaticEntities.seed.sql"),
        DynamicInsertScriptPaths = ImmutableArray.Create("DynamicData.all.dynamic.sql")
    };

    // Act - Apply both static seeds AND dynamic data (dynamic uses MERGE)
    var result = await loadHarnessRunner.RunAsync(options);

    // Assert - No errors, no duplicate key violations
    Assert.Empty(result.Errors);
    Assert.True(result.AllScriptsSucceeded);
}
```

## Migration Path

### Phase 1: Add `IsStatic` Field (Non-Breaking)
- Add `IsStatic` to `StaticEntitySeedTableDefinition` with default `false`
- Update `StaticEntitySeedDefinitionBuilder.Build()` to capture `IsStatic`
- Update `SqlDynamicEntityDataProvider.CreateDefinition()` to pass `IsStatic`
- **No behavior changes yet**

### Phase 2: Implement MERGE Builder
- Add `BuildMergeScript()` method
- Add unit tests for MERGE generation (simple PK, composite PK, no PK â†’ error)
- **Still no behavior change - MERGE not invoked yet**

### Phase 3: Feature Flag Rollout
- Add `DynamicDataIncludesStaticEntities` configuration option (default: `false`)
- When `true`:
  - `DynamicEntityInsertGenerator.BuildScript()` checks `IsStatic` â†’ emit MERGE
  - Verify static entities are included in dataset (or remove filter if exists)
- **Gradual rollout via feature flag**

### Phase 4: Validation & Testing
- Run exports with feature flag enabled
- Execute LoadHarness with both static + dynamic
- Monitor for FK violations, duplicate key errors
- Validate MERGE performance impact (< 10% overhead expected)

### Phase 5: Default Flip
- Change default to `DynamicDataIncludesStaticEntities = true`
- Document new behavior
- Update user guides

### Phase 6: Cleanup
- Remove feature flag (make behavior mandatory)
- Remove legacy code paths

## Success Criteria

1. âœ… Dynamic data includes ALL entities (static + regular)
2. âœ… Static entities in dynamic data use MERGE (idempotent)
3. âœ… Global topological sort applied to complete entity set
4. âœ… No FK violations during LoadHarness execution
5. âœ… Existing static seed emission unchanged
6. âœ… Can safely apply both static seeds + dynamic data without errors
7. âœ… All existing tests pass
8. âœ… New integration tests cover cross-boundary FK scenarios

## Defensive Measures for Timing/Sequencing Issues

### Issue: Potential Race Conditions Despite Correct Ordering

User observation: "Even when parent and child are in correct order, FK constraint violations occur. When checking afterward, both tables have data - it was just the FK constraint check that failed."

### Root Cause Analysis

**Verified**: Static entities ARE included in dynamic data (not filtered by `IsStatic`). The issue is that static and regular entities are **sorted separately** before being combined, breaking cross-boundary FK dependencies.

**Additional Concerns**:
1. **Junction table prioritization**: Ensure parent â†’ child â†’ junction ordering, not just alphabetical
2. **Execution boundaries**: Ensure each entity's INSERT completes before dependent entities execute
3. **FK constraint timing**: Verify FKs are created in DDL phase and remain active during data load

### Defensive Fixes

#### Fix 1: Verify Junction Table Deferral Works Across Static/Regular Boundary

**Existing code**: `JunctionTableClassifier` (line 616-782) identifies junction tables by:
- Entity has 2+ FK relationships to different tables (line 743-745)
- All non-PK columns are FKs (line 748-759)
- Junction tables get lower priority in sort (line 821: `ReadyQueueComparer`)

**Risk**: If junction classification only runs on static OR regular entities separately, cross-boundary junctions (e.g., static User + regular Department â†’ junction UserDepartment) may not be detected.

**Verification Required**:
- Ensure junction classification runs on **combined static + regular set**
- Test: Junction with 1 FK to static, 1 FK to regular entity

#### Fix 2: Add Explicit GO Statements Between Parent/Child Batches

**Current**: Each entity script has internal GO statements (line 773), but may need explicit boundary between entities in single-file mode.

**Proposed**: In `WriteSingleFileScriptAsync()`, add defensive GO between scripts:

```csharp
foreach (var script in scripts)
{
    cancellationToken.ThrowIfCancellationRequested();

    builder.AppendLine(script.Script.TrimEnd());
    builder.AppendLine();
    builder.AppendLine("GO");  // â† DEFENSIVE: Ensure transaction boundary
    builder.AppendLine("-- ===== Entity boundary =====");
    builder.AppendLine();
}
```

**Rationale**: Even though each script ends with GO, an explicit boundary ensures previous entity's data is fully committed before next entity begins.

#### Fix 3: Add Per-Entity Commit PRINT Statements

**Proposed**: Add diagnostic output to verify execution order and completion:

```csharp
private string BuildMergeScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] âœ“ Completed MERGE for {definition.Schema}.{definition.PhysicalName} (static entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}

private string BuildInsertScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] âœ“ Completed INSERT for {definition.Schema}.{definition.PhysicalName} (regular entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}
```

**Benefit**: LoadHarness output will show exactly which entities completed before FK violation occurs.

#### Fix 4: Validate FK Constraint State Before Data Load

**Proposed**: Add preflight check in LoadHarness to verify FK constraints exist and are enabled:

```sql
-- Query sys.foreign_keys to list all FK constraints
-- Verify is_disabled = 0 (enabled)
-- Verify is_not_trusted = 0 (trusted, checks existing data)
-- Log any disabled or untrusted FKs as warnings
```

**Benefit**: Catches scenarios where FKs are created WITH NOCHECK or disabled, which would mask ordering issues.

#### Fix 5: Add Topological Ordering Validation in Generated Scripts

**Proposed**: Emit comment header in each script showing its topological position:

```sql
--------------------------------------------------------------------------------
-- Entity: User (dbo.OSSYS_USER)
-- Topological Order: 15 of 87
-- Dependencies: Role (14), Department (12)  -- â† Shows parent positions
-- Dependents: AuditLog (23), Session (31)  -- â† Shows child positions
--------------------------------------------------------------------------------
```

**Benefit**: Easy visual verification that scripts are in correct order during debugging.

## Open Questions for User

1. **What is the exact error message you saw?**
   - `"The INSERT statement conflicted with the FOREIGN KEY constraint..."`?
   - Which table (parent or child)?
   - Which FK constraint name?

2. **What is your LoadHarness execution sequence?**
   - Safe scripts â†’ Remediation â†’ Static seeds â†’ Dynamic data?
   - Or different order?

3. **Which output mode are you using?**
   - `DynamicInsertOutputMode.PerEntity` (separate files)?
   - `DynamicInsertOutputMode.SingleFile` (consolidated)?

4. **How are FK constraints created?**
   - Inline in CREATE TABLE?
   - Separate ALTER TABLE ADD CONSTRAINT?
   - WITH CHECK or WITH NOCHECK?

5. **Are you seeing this with specific entity pairs?**
   - Can you provide example: `Table A (static/regular) â†’ FK â†’ Table B (static/regular)`?

## Implementation Priority

### Phase 1: Core Fix (2-3 days)
1. âœ… Verify static entities are included (CONFIRMED - they are)
2. âœ… Implement global topological sort (use existing `EntityDependencySorter` on combined set)
3. âœ… Add MERGE emission for static entities
4. âœ… Verify junction table deferral works cross-boundary

### Phase 2: Defensive Hardening (1 day)
5. âœ… Add explicit GO between entities in single-file mode
6. âœ… Add PRINT statements for execution tracing
7. âœ… Add topological position comments in scripts
8. âœ… Add FK constraint state validation

### Phase 3: Testing & Validation (2-3 days)
9. Integration tests with cross-boundary FKs
10. LoadHarness execution with diagnostic output
11. Verify junction table ordering
12. Test with both PerEntity and SingleFile modes

## Next Steps

1. **User provides**: Error message, execution sequence, specific failing tables
2. **Investigation**: Reproduce FK violation with minimal test case
3. **Implementation**: Global sort + MERGE + defensive boundaries
4. **Validation**: Verify fix resolves both ordering AND timing issues

---

**Conclusion**: M1.0 addresses BOTH problems:
1. **Ordering**: Global topological sort across static + regular entities
2. **Timing**: Defensive transaction boundaries and execution tracing to prevent race conditions
