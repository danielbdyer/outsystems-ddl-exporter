# M1.0: Global Topological Ordering with Bootstrap Snapshot

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION - MVP PRIORITY
**Priority**: üî¥ CRITICAL PATH - Ship this week

## Executive Summary

This specification addresses FK constraint violations during SSDT deployment by generating a bootstrap snapshot with global topological ordering.

**MVP Scope (Ship This Week)**:
1. ‚úÖ Bootstrap snapshot generation (`AllEntitiesIncludingStatic.bootstrap.sql`)
2. ‚úÖ PostDeployment template with guard logic (`PostDeployment-Bootstrap.sql`)
3. ‚úÖ Directory rename (Seeds ‚Üí BaselineSeeds)
4. ‚úÖ Observability measures: GO statements, PRINT diagnostics, topological comments

**Deferred to M1.5+ (Ship Later)**:
- Per-table emission mode (M1.5 - production enhancement)

**Key Finding**: After comprehensive codebase analysis, **most infrastructure already exists**. This is about applying existing topological sorting to the complete entity set and orchestrating first-deployment vs. ongoing-deployment workflows.

---

## üö® Critical Path Analysis

### Why This Is MVP (Ship Now)

**Problem**: FK violations in SSDT static seed deployment block user's deadline
**Root Cause**: Alphabetical module ordering breaks cross-module FK dependencies
**Solution**: Bootstrap snapshot with global topological sort (no module partitioning)

**What Ships in M1.0 MVP**:
| Component | Why Critical |
|-----------|--------------|
| Bootstrap snapshot | Fixes FK violations |
| PostDeployment template | Enables first-deployment guard logic |
| Directory rename | Clearer terminology for baseline vs. bootstrap |
| Observability measures | Crucial for debuggability (GO statements, PRINT, comments) |

**What's Deferred (Not Blocking)**:
- **M1.5**: Per-table emission (production enhancement, not MVP blocker)
- **M1.7**: Topological proof (verification artifact, not functional requirement)
- **M1.8**: Data integrity (DMM replacement, separate from FK ordering)

**Architectural Soundness**: M1.0 MVP does NOT block future work:
- ‚úÖ PostDeployment template already designed to handle per-table mode (M1.5 ready)
- ‚úÖ Observability included in M1.0 provides debuggability from day one
- ‚úÖ Proof generation consumes existing data structures (no M1.0 changes needed)
- ‚úÖ Data integrity is independent orchestration step (verifies M1.0's output)

## Problem Statement

### Current Behavior - The Real Issue

**User's Observation**: FK constraint violations occur when applying static seed files in SSDT, even after manually reordering parent/child entities.

**Root Cause**: Static seed files are partitioned by module and emitted in **alphabetical module order**, breaking cross-module FK dependencies.

**Current Static Seed Flow**:
1. All static entities are topologically sorted globally ‚úÖ
2. Entities partitioned by module (preserving order within each module) ‚úÖ
3. Module files emitted in **alphabetical order** ‚ùå
4. SSDT applies files in ItemGroup order (alphabetical) ‚ùå

**Example Failure**:
- ModuleA contains `User` (FK ‚Üí `Role`)
- ModuleB contains `Role`
- Alphabetical order: ModuleA before ModuleB
- Result: `User` MERGEs before `Role` exists ‚Üí FK violation!

**Why Manual Reordering Didn't Help**:
- Reordering entities WITHIN a module preserves FK order within that module
- But cross-MODULE dependencies still violate due to alphabetical module file ordering

### Proposed Solution - Bootstrap Snapshot

**First Deployment Strategy**:
1. **Bootstrap Snapshot** (`AllEntitiesIncludingStatic.bootstrap.sql`):
   - ALL entities (static + regular) in ONE file
   - Global topological sort (no module partitioning)
   - MERGE for all entities (idempotent)
   - Applied ONCE on first deployment via conditional PostDeployment script
   - **Not committed to source control** (ephemeral artifact)

2. **Baseline Seeds** (`StaticEntities.seed.sql` or per-module/per-entity files):
   - Static entities only
   - Version controlled, developer-maintained
   - Applied on EVERY deployment (idempotent MERGE)
   - Module ordering becomes irrelevant (data already exists from bootstrap)

**Workflow**:
```
First Deployment:
  1. SSDT creates tables + FK constraints
  2. PostDeployment guard detects "first run"
  3. Bootstrap snapshot applies (all entities, topologically sorted)
  4. Baseline seeds apply (no-op, data already exists)
  5. Guard marks bootstrap as "applied"

Ongoing Deployments:
  1. SSDT updates schema if needed
  2. PostDeployment guard detects "already bootstrapped"
  3. Bootstrap snapshot skipped
  4. Baseline seeds apply (maintain static reference data)
```

## Codebase Reality Check - What Already Exists

### ‚úÖ Infrastructure ALREADY Implemented

| Component | File | Lines | Status |
|-----------|------|-------|--------|
| **FK-aware topological sorting** | `EntityDependencySorter.cs` | 967 | ‚úÖ Complete |
| **Kahn's algorithm** | `EntityDependencySorter.TopologicalSort()` | 264-302 | ‚úÖ Implemented |
| **Cycle detection + fallback** | `EntityDependencySorter.SortByForeignKeys()` | 122-156 | ‚úÖ Implemented |
| **Junction table deferral** | `JunctionTableClassifier` | 616-782 | ‚úÖ Implemented |
| **Self-referencing FK ordering** | `DynamicEntityInsertGenerator.OrderRows()` | 152-405 | ‚úÖ Implemented |
| **FK preflight validation** | `StaticSeedForeignKeyPreflight.cs` | 217 | ‚úÖ Implemented |
| **SMO enrichment** | `RelationshipConstraintHydrator.cs` | 292 | ‚úÖ **EXISTS!** |
| **LoadHarness trust manifest** | `LoadHarnessRunner.BuildScriptQueue()` | 169-206 | ‚úÖ Verified |
| **Ordering telemetry** | `BuildSsdtStaticSeedStep.cs` | 158-172 | ‚úÖ Implemented |

### üîç SMO Enrichment Discovery

**File**: `src/Osm.Pipeline/ModelIngestion/RelationshipConstraintMetadataProvider.cs`

**Key Query** (lines 72-94):
```csharp
SELECT
    mc.SchemaName,
    mc.TableName,
    mc.ConstraintName,
    fkc.constraint_column_id AS Ordinal,
    parent_col.name AS ParentColumn,
    ref_col.name AS ReferencedColumn,
    ref_schema.name AS ReferencedSchema,
    ref_table.name AS ReferencedTable
FROM MissingConstraints mc
JOIN sys.schemas parent_schema ON parent_schema.name = mc.SchemaName
JOIN sys.tables parent_table ON parent_table.schema_id = parent_schema.schema_id AND parent_table.name = mc.TableName
JOIN sys.foreign_keys fk ON fk.parent_object_id = parent_table.object_id AND fk.name = mc.ConstraintName
JOIN sys.foreign_key_columns fkc ON fkc.constraint_object_id = fk.object_id
-- ... (joins to get column names)
```

**Usage**: `RelationshipConstraintHydrator.HydrateAsync()` (line 30-68)
- Finds relationships with missing constraint metadata (`NeedsHydration()`)
- Queries SQL Server via `sys.foreign_keys` to get actual FK column mappings
- Enriches the `OsmModel` with complete FK metadata

**This is EXACTLY the SMO enrichment I thought was missing - it already exists and runs during model extraction!**

### ‚ùå What M1.0 Must Address

| Issue | Current Impact | M1.0 Solution |
|-------|----------------|---------------|
| **Module partitioning breaks order** | When `GroupByModule=true`, static seed files ordered alphabetically by module ‚Üí cross-module FK violations in SSDT | ‚úÖ Bootstrap snapshot with global topological sort (no module partitioning) |
| **No bootstrap snapshot** | First SSDT deployment must apply static seeds in correct order, but module alphabetization breaks this | ‚úÖ Generate `AllEntitiesIncludingStatic.bootstrap.sql` for first deployment |
| **No PostDeployment template** | Users must manually create PostDeployment scripts with guard logic | ‚úÖ Generate `PostDeployment-Bootstrap.sql` template |

**Note**: Static entities ARE already included in dynamic data export (`DynamicDataset`) - verified in code. The issue is NOT missing data, but incorrect FILE ORDERING during SSDT deployment of static seed files.

## New File Emissions

### 1. Bootstrap Snapshot (Single File)

**File**: `AllEntitiesIncludingStatic.bootstrap.sql`

**Location**: `{OutputDirectory}/Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql`

**Content**:
- ALL entities (static + regular) in global topological order
- MERGE statements for all entities (idempotent)
- Header comments showing topological position and dependencies
- GO statements between entities for transaction boundaries

**Characteristics**:
- Generated once per export
- **Not version controlled** (add to .gitignore)
- Used only for first deployment
- Self-contained (no external dependencies)

**Example Structure**:
```sql
--------------------------------------------------------------------------------
-- Bootstrap Snapshot: All Entities (Static + Regular)
-- Generated: 2025-11-18
-- Total Entities: 87 (42 static, 45 regular)
-- Sorted: Global topological order
--------------------------------------------------------------------------------

-- Entity: Role (dbo.OSSYS_ROLE)
-- Topological Order: 1 of 87 (no dependencies)
-- Type: Static
MERGE INTO [dbo].[OSSYS_ROLE] AS Target
USING (VALUES ...) AS Source (...)
ON Target.[Id] = Source.[Id]
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
GO

-- Entity: User (dbo.OSSYS_USER)
-- Topological Order: 2 of 87 (depends on: Role)
-- Type: Static
MERGE INTO [dbo].[OSSYS_USER] AS Target
USING (VALUES ...) AS Source (...)
ON Target.[Id] = Source.[Id]
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
GO

-- ... continues for all 87 entities ...
```

### 2. PostDeployment Bootstrap Template (NEW!)

**File**: `PostDeployment-Bootstrap.sql`

**Location**: `{OutputDirectory}/PostDeployment-Bootstrap.sql`

**Purpose**: Ready-to-copy PostDeployment script for SSDT that conditionally applies bootstrap and baseline seeds

**Content**: Guard logic + dynamic `:r` includes

**Example (Single-File Baseline Seeds Mode)**:
```sql
--------------------------------------------------------------------------------
-- PostDeployment Bootstrap Script
-- Generated: 2025-11-18
-- Usage: Copy to SSDT project's PostDeployment folder
--------------------------------------------------------------------------------

-- Guard: Only apply bootstrap snapshot on first deployment
IF NOT EXISTS (SELECT 1 FROM [dbo].[OSSYS_ROLE])
BEGIN
    PRINT 'First deployment detected - applying bootstrap snapshot';
    PRINT 'Loading: Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql';

    :r Bootstrap\AllEntitiesIncludingStatic.bootstrap.sql

    PRINT 'Bootstrap snapshot applied successfully (87 entities)';
END
ELSE
BEGIN
    PRINT 'Existing deployment detected - skipping bootstrap snapshot';
END
GO

--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds (static entities)';

:r BaselineSeeds\StaticEntities.seed.sql

PRINT 'Baseline seeds applied successfully';
GO
```

**Example (Per-Module Baseline Seeds Mode)**:
```sql
-- ... guard logic same as above ...

--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds (static entities) from multiple modules';

-- Module: Core
:r BaselineSeeds\Core\StaticEntities.seed.sql

-- Module: Security
:r BaselineSeeds\Security\StaticEntities.seed.sql

-- Module: Workflow
:r BaselineSeeds\Workflow\StaticEntities.seed.sql

PRINT 'Baseline seeds applied successfully (3 modules)';
GO
```

**Dynamic Generation Logic**:
- Read `BuildSsdtPipelineRequest.StaticSeedOptions.GroupByModule`
- If `false`: Emit single `:r` for `StaticEntities.seed.sql`
- If `true`: Emit multiple `:r` statements for each module file (in alphabetical order for readability, but doesn't matter due to idempotency)

### 3. Baseline Seeds (Existing, No Changes)

**File(s)**: `StaticEntities.seed.sql` or per-module/per-entity files

**Location**: `{OutputDirectory}/BaselineSeeds/`

**Content**: Static entities only (no change from current behavior)

**Characteristics**:
- Version controlled
- Developer-maintained
- Applied on every deployment
- Idempotent MERGE statements

## Implementation Scope

### Change 1: Generate Bootstrap Snapshot File

**New Step**: `BuildSsdtBootstrapSnapshotStep.cs`

**Purpose**: Generate `AllEntitiesIncludingStatic.bootstrap.sql` containing all entities in global topological order

**Implementation**:
```csharp
public async Task<BuildSsdtPipelineState> ExecuteAsync(
    BuildSsdtPipelineState state,
    CancellationToken cancellationToken)
{
    // 1. Combine static + regular entity datasets
    var staticEntities = state.StaticSeedData ?? ImmutableArray<StaticEntityTableData>.Empty;
    var regularEntities = state.Request.DynamicDataset?.Tables ?? ImmutableArray<StaticEntityTableData>.Empty;
    var allEntities = staticEntities.Concat(regularEntities).ToImmutableArray();

    // 2. Global topological sort (use existing EntityDependencySorter)
    var ordering = EntityDependencySorter.SortByForeignKeys(
        allEntities,
        state.Bootstrap.FilteredModel,
        state.Request.Scope.SmoOptions.NamingOverrides,
        state.Request.Scope.StaticSeedOptions.SortOptions);

    // 3. Generate MERGE script for all entities
    var bootstrapScript = GenerateBootstrapScript(ordering.Tables, state);

    // 4. Write to Bootstrap directory
    var bootstrapDirectory = Path.Combine(state.Request.OutputDirectory, "Bootstrap");
    Directory.CreateDirectory(bootstrapDirectory);
    var bootstrapPath = Path.Combine(bootstrapDirectory, "AllEntitiesIncludingStatic.bootstrap.sql");
    await File.WriteAllTextAsync(bootstrapPath, bootstrapScript, Utf8NoBom, cancellationToken);

    // 5. Log metrics
    state.Log.Record(
        "bootstrap.snapshot.generated",
        $"Generated bootstrap snapshot with {ordering.Tables.Length} entities",
        new PipelineLogMetadataBuilder()
            .WithCount("entities.total", ordering.Tables.Length)
            .WithCount("entities.static", ordering.Tables.Count(t => IsStatic(t)))
            .WithCount("entities.regular", ordering.Tables.Count(t => !IsStatic(t)))
            .WithValue("ordering.applied", ordering.TopologicalOrderingApplied)
            .Build());

    return state with { BootstrapSnapshotPath = bootstrapPath };
}
```

**Key Points**:
- Static entities ARE already in `DynamicDataset` (verified via code analysis)
- Use existing `EntityDependencySorter` for global sort
- Generate MERGE for ALL entities (reuse `StaticSeedSqlBuilder` logic)

### Change 2: Generate PostDeployment Bootstrap Template

**New Step**: `BuildSsdtPostDeploymentTemplateStep.cs`

**Purpose**: Generate `PostDeployment-Bootstrap.sql` with guard logic and dynamic `:r` includes

**Implementation**:
```csharp
public async Task<BuildSsdtPipelineState> ExecuteAsync(
    BuildSsdtPipelineState state,
    CancellationToken cancellationToken)
{
    var builder = new StringBuilder();

    // Header
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("-- PostDeployment Bootstrap Script");
    builder.AppendLine($"-- Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
    builder.AppendLine("-- Usage: Copy to SSDT project's PostDeployment folder");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine();

    // Guard: Only apply bootstrap on first deployment
    builder.AppendLine("-- Guard: Only apply bootstrap snapshot on first deployment");

    // Pick a canonical static table for the guard check
    var canonicalTable = GetCanonicalStaticTable(state);
    builder.AppendLine($"IF NOT EXISTS (SELECT 1 FROM [{canonicalTable.Schema}].[{canonicalTable.PhysicalName}])");
    builder.AppendLine("BEGIN");
    builder.AppendLine("    PRINT 'First deployment detected - applying bootstrap snapshot';");
    builder.AppendLine("    PRINT 'Loading: Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql';");
    builder.AppendLine();
    builder.AppendLine("    :r Bootstrap\\AllEntitiesIncludingStatic.bootstrap.sql");
    builder.AppendLine();
    builder.AppendLine($"    PRINT 'Bootstrap snapshot applied successfully ({state.StaticSeedData.Length + state.Request.DynamicDataset.Tables.Length} entities)';");
    builder.AppendLine("END");
    builder.AppendLine("ELSE");
    builder.AppendLine("BEGIN");
    builder.AppendLine("    PRINT 'Existing deployment detected - skipping bootstrap snapshot';");
    builder.AppendLine("END");
    builder.AppendLine("GO");
    builder.AppendLine();

    // Baseline Seeds: Dynamic includes based on emission mode
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("-- Baseline Seeds (Static Entities) - Applied on every deployment");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("PRINT 'Applying baseline seeds (static entities)';");
    builder.AppendLine();

    var seedPaths = state.StaticSeedScriptPaths;
    if (seedPaths.IsDefaultOrEmpty || seedPaths.Length == 1)
    {
        // Single file mode
        builder.AppendLine(":r BaselineSeeds\\StaticEntities.seed.sql");
    }
    else
    {
        // Per-module mode
        builder.AppendLine("PRINT 'Applying baseline seeds from multiple modules';");
        builder.AppendLine();

        foreach (var seedPath in seedPaths.OrderBy(p => p))
        {
            var relativePath = GetRelativePathFromOutput(seedPath, state.Request.OutputDirectory);
            var moduleName = Path.GetFileName(Path.GetDirectoryName(relativePath));

            builder.AppendLine($"-- Module: {moduleName}");
            builder.AppendLine($":r {relativePath.Replace("/", "\\")}");
            builder.AppendLine();
        }
    }

    builder.AppendLine("PRINT 'Baseline seeds applied successfully';");
    builder.AppendLine("GO");

    // Write template file
    var templatePath = Path.Combine(state.Request.OutputDirectory, "PostDeployment-Bootstrap.sql");
    await File.WriteAllTextAsync(templatePath, builder.ToString(), Utf8NoBom, cancellationToken);

    state.Log.Record(
        "postDeployment.template.generated",
        "Generated PostDeployment bootstrap template",
        new PipelineLogMetadataBuilder()
            .WithPath("template", templatePath)
            .WithCount("baselineSeedFiles", seedPaths.Length)
            .Build());

    return state with { PostDeploymentTemplatePath = templatePath };
}
```

**Key Logic**:
- Guard uses first static table as "has data" indicator
- Bootstrap snapshot path is hardcoded relative path (user copies template to SSDT)
- Baseline seed includes are dynamically generated based on `GroupByModule` setting
- All paths use backslashes for Windows compatibility

### Change 3: Output Directory Restructuring

**Current Structure** (verified from codebase):
```
{OutputDirectory}/
‚îú‚îÄ‚îÄ Modules/              ‚Üê Tables emitted here (SsdtEmitter.cs:82)
‚îÇ   ‚îî‚îÄ‚îÄ [TableFiles]
‚îú‚îÄ‚îÄ Seeds/                ‚Üê Static seeds currently emitted here (BuildSsdtStaticSeedStep.cs:96)
‚îÇ   ‚îú‚îÄ‚îÄ [Module1]/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql
‚îÇ   ‚îú‚îÄ‚îÄ [Module2]/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql
‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql (master file if EmitMasterFile=true)
‚îú‚îÄ‚îÄ DynamicData/          ‚Üê Dynamic data emitted here (BuildSsdtDynamicInsertStep.cs:134)
‚îÇ   ‚îú‚îÄ‚îÄ [Module1]/        (PerEntity mode)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [TableName].dynamic.sql
‚îÇ   ‚îú‚îÄ‚îÄ [Module2]/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [TableName].dynamic.sql
‚îÇ   ‚îî‚îÄ‚îÄ DynamicData.all.dynamic.sql (SingleFile mode)
‚îî‚îÄ‚îÄ manifest.json
```

**New Structure** (after M1.0):
```
{OutputDirectory}/
‚îú‚îÄ‚îÄ Modules/              ‚Üê UNCHANGED (tables go here, ForeignKeys are part of table definitions)
‚îÇ   ‚îî‚îÄ‚îÄ [TableFiles]
‚îú‚îÄ‚îÄ Bootstrap/            ‚Üê NEW
‚îÇ   ‚îî‚îÄ‚îÄ AllEntitiesIncludingStatic.bootstrap.sql
‚îú‚îÄ‚îÄ BaselineSeeds/        ‚Üê RENAMED from Seeds/
‚îÇ   ‚îú‚îÄ‚îÄ StaticEntities.seed.sql            (single-file mode - default)
‚îÇ   ‚îú‚îÄ‚îÄ [Module1]/                         (per-module mode)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql
‚îÇ   ‚îî‚îÄ‚îÄ [Module1]/                         (per-table mode - NEW FEATURE)
‚îÇ       ‚îú‚îÄ‚îÄ [Table1].seed.sql
‚îÇ       ‚îî‚îÄ‚îÄ [Table2].seed.sql
‚îî‚îÄ‚îÄ PostDeployment-Bootstrap.sql   ‚Üê NEW (copy to SSDT)
```

**Key Changes**:
- Add `Bootstrap/` directory (gitignored) for bootstrap snapshot
- Rename `Seeds/` ‚Üí `BaselineSeeds/` (clearer terminology)
- Add root-level `PostDeployment-Bootstrap.sql` template
- **NEW**: Support per-table emission mode (see Change 4 below)
- **NOTE**: DynamicData/ folder removed from typical SSDT workflow (bootstrap snapshot replaces it for deployment)

### Change 4: Per-Table Baseline Seed Emission (üü° DEFERRED TO M1.5)

**Status**: Production enhancement - NOT in M1.0 MVP
**Priority**: Ship in M1.5 after MVP proven (0.5 days effort)
**Reason for Deferral**: Nice-to-have for fine-grain version control, not required to fix FK violations

**Current Emission Modes** (BuildSsdtStaticSeedStep.cs:102-155):
1. **Single-file mode** (`GroupByModule = false`):
   - Output: `BaselineSeeds/StaticEntities.seed.sql`
   - All static entities in one file
   - Default, administrative convenience

2. **Per-module mode** (`GroupByModule = true`):
   - Output: `BaselineSeeds/{Module}/StaticEntities.seed.sql`
   - One file per module
   - Better organization for large apps

**NEW Mode - Per-Table Emission**:
3. **Per-table mode** (`EmitPerTableSeeds = true`):
   - Output: `BaselineSeeds/{Module}/{TableName}.seed.sql`
   - One file per static entity table
   - Finest-grain organization for version control
   - Useful in production with many static entities

**Implementation**:

```csharp
// In BuildSsdtStaticSeedStep.cs, add after line 102:
if (seedOptions.EmitPerTableSeeds)
{
    // Per-table emission mode
    var modules = orderedData
        .GroupBy(table => table.Definition.Module, StringComparer.OrdinalIgnoreCase)
        .OrderBy(group => group.Key, StringComparer.OrdinalIgnoreCase);

    foreach (var moduleGroup in modules)
    {
        var moduleName = moduleGroup.Key;
        var sanitizedModule = state.Request.Scope.SmoOptions.SanitizeModuleNames
            ? ModuleNameSanitizer.Sanitize(moduleName)
            : moduleName;

        var moduleDirectoryName = ResolveModuleDirectoryName(
            moduleName,
            sanitizedModule,
            usedModuleNames,
            state.Log,
            "staticData.seed.moduleNameRemapped");

        var moduleDirectory = Path.Combine(seedsRoot!, moduleDirectoryName);
        Directory.CreateDirectory(moduleDirectory);

        // Emit one file per table
        foreach (var table in moduleGroup)
        {
            var tableName = table.Definition.PhysicalName;
            var tablePath = Path.Combine(moduleDirectory, $"{tableName}.seed.sql");

            await _seedGenerator
                .WriteAsync(tablePath, ImmutableArray.Create(table), seedOptions.SynchronizationMode, model, cancellationToken)
                .ConfigureAwait(false);

            seedPathBuilder.Add(tablePath);
        }
    }
}
else if (seedOptions.GroupByModule)
{
    // Existing per-module mode...
}
```

**PostDeployment Template Update**:

The `BuildSsdtPostDeploymentTemplateStep` must dynamically detect emission mode and inline all files:

```csharp
// In BuildSsdtPostDeploymentTemplateStep.cs:
var seedPaths = state.StaticSeedScriptPaths;

if (seedPaths.IsDefaultOrEmpty || seedPaths.Length == 0)
{
    // No seeds
    builder.AppendLine("-- No baseline seeds emitted");
}
else if (seedPaths.Length == 1)
{
    // Single file mode
    var relativePath = GetRelativePathFromOutput(seedPaths[0], state.Request.OutputDirectory);
    builder.AppendLine($":r {relativePath.Replace("/", "\\")}");
}
else
{
    // Multiple files (per-module OR per-table mode)
    builder.AppendLine($"-- Applying baseline seeds from {seedPaths.Length} files");
    builder.AppendLine();

    foreach (var seedPath in seedPaths.OrderBy(p => p))
    {
        var relativePath = GetRelativePathFromOutput(seedPath, state.Request.OutputDirectory);
        var fileName = Path.GetFileName(relativePath);
        var moduleName = Path.GetFileName(Path.GetDirectoryName(relativePath));

        builder.AppendLine($"-- {moduleName}/{fileName}");
        builder.AppendLine($":r {relativePath.Replace("/", "\\")}");
        builder.AppendLine();
    }
}
```

**Example PostDeployment-Bootstrap.sql (Per-Table Mode)**:
```sql
--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds from 42 files';

-- Core/OSSYS_ROLE.seed.sql
:r BaselineSeeds\Core\OSSYS_ROLE.seed.sql

-- Core/OSSYS_USER.seed.sql
:r BaselineSeeds\Core\OSSYS_USER.seed.sql

-- Security/OSSYS_PERMISSION.seed.sql
:r BaselineSeeds\Security\OSSYS_PERMISSION.seed.sql

-- ... continues for all 42 static entities ...

PRINT 'Baseline seeds applied successfully';
GO
```

**Configuration Option**:
Add to `StaticSeedOptions`:
```csharp
public sealed record StaticSeedOptions(
    bool GroupByModule,
    bool EmitMasterFile,
    bool EmitPerTableSeeds,  // ‚Üê NEW
    StaticSeedSynchronizationMode SynchronizationMode);
```

**User Workflow**:
```bash
# Default: Single file (administrative convenience)
osm full-export --output ./MyApp

# Production: Per-table emission for granular version control
osm full-export --output ./MyApp --emit-per-table-seeds
```

### Change 5: Module Ordering (Now Lower Priority)

**Status**: Module alphabetical ordering is **no longer critical** because:

1. Bootstrap snapshot loads all data on first deployment (correct order guaranteed)
2. Baseline seeds run on subsequent deployments when data already exists (idempotent MERGE, order doesn't matter)
3. Cross-module FK violations can only occur if:
   - Bootstrap snapshot was skipped (user error)
   - Database was manually modified to remove data

**Recommendation**: Defer module topological ordering to future enhancement. Current approach solves the problem without this complexity.

**Optional Enhancement** (if desired later):
- Add warning log if cross-module FK dependencies detected
- Suggest using single-file mode instead of GroupByModule
- Or implement topological module ordering (replace line 107 alphabetical sort with topological sort of modules)

## User Workflow

### Generation (Developer runs OSM export)

```bash
osm full-export --output ./MyApp
```

**Output**:
```
MyApp/
‚îú‚îÄ‚îÄ Modules/                                       (Tables - unchanged)
‚îÇ   ‚îî‚îÄ‚îÄ [TableFiles]
‚îú‚îÄ‚îÄ Bootstrap/
‚îÇ   ‚îî‚îÄ‚îÄ AllEntitiesIncludingStatic.bootstrap.sql  (87 entities, topologically sorted)
‚îú‚îÄ‚îÄ BaselineSeeds/
‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql                   (42 static entities, idempotent MERGE)
‚îî‚îÄ‚îÄ PostDeployment-Bootstrap.sql                   (COPY THIS TO SSDT)
```

**Note**: DynamicData/ folder not needed for SSDT deployment (bootstrap snapshot contains all data).

### Integration (Developer copies template to SSDT)

```bash
# Copy the generated template into SSDT project
cp MyApp/PostDeployment-Bootstrap.sql MyApp.sqlproj/PostDeployment/01-Bootstrap.sql

# Verify paths in SSDT project match expected structure
# Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql (relative to .sqlproj)
# BaselineSeeds/StaticEntities.seed.sql (relative to .sqlproj)
```

### First Deployment (SSDT to fresh database)

```
1. SSDT builds .dacpac
2. SSDT deploys:
   - Creates tables (DDL)
   - Creates FK constraints (ALTER TABLE ADD CONSTRAINT)
   - Runs PostDeployment/01-Bootstrap.sql:
     a. Guard checks: SELECT 1 FROM [OSSYS_ROLE] ‚Üí empty ‚Üí first deployment!
     b. Includes Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql
     c. All 87 entities loaded in topological order (MERGE)
     d. Includes BaselineSeeds/StaticEntities.seed.sql
     e. 42 static entities apply (no-op, already loaded via bootstrap)
```

### Ongoing Deployments (SSDT to existing database)

```
1. Developer modifies static seed data (e.g., adds new Role)
2. Updates BaselineSeeds/StaticEntities.seed.sql
3. SSDT deploys:
   - Updates schema if needed
   - Runs PostDeployment/01-Bootstrap.sql:
     a. Guard checks: SELECT 1 FROM [OSSYS_ROLE] ‚Üí has data ‚Üí skip bootstrap!
     b. Includes BaselineSeeds/StaticEntities.seed.sql
     c. 42 static entities apply (idempotent MERGE, updates new Role)
```

## Test Scenarios

### Test 1: MERGE Script Generation
```csharp
[Fact]
public void BuildMergeScript_WithCompositePrimaryKey_EmitsCorrectMerge()
{
    var definition = new StaticEntitySeedTableDefinition(
        Module: "Core",
        LogicalName: "Permission",
        Schema: "dbo",
        PhysicalName: "OSSYS_PERMISSION",
        EffectiveName: "OSSYS_PERMISSION",
        Columns: ImmutableArray.Create(
            new StaticEntitySeedColumn("RoleId", "RoleId", "RoleId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("ResourceId", "ResourceId", "ResourceId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("CanRead", "CanRead", "CanRead", "bit", null, null, null, IsPrimaryKey: false, IsIdentity: false, IsNullable: false)
        ),
        IsStatic: true);

    var rows = ImmutableArray.Create(
        StaticEntityRow.Create(new object[] {
            Guid.Parse("00000000-0000-0000-0000-000000000001"),
            Guid.Parse("00000000-0000-0000-0000-000000000002"),
            true
        }));

    var script = generator.BuildScript(definition, rows, batchSize: 1000);

    Assert.Contains("MERGE INTO [dbo].[OSSYS_PERMISSION]", script);
    Assert.Contains("ON Target.[RoleId] = Source.[RoleId] AND Target.[ResourceId] = Source.[ResourceId]", script);
    Assert.Contains("WHEN NOT MATCHED THEN", script);
    Assert.DoesNotContain("SET IDENTITY_INSERT", script);
}
```

### Test 2: Cross-Boundary FK Ordering
```csharp
[Fact]
public void SortByForeignKeys_WithStaticToRegularFK_OrdersGlobally()
{
    // Arrange: User (static) ‚Üí Department (regular)
    var model = CreateModelWithCrossBoundaryFK();
    var staticUser = CreateStaticEntityTable("User", isStatic: true, fkTo: "Department");
    var regularDept = CreateRegularEntityTable("Department", isStatic: false);
    var allEntities = ImmutableArray.Create(staticUser, regularDept);  // Wrong order

    // Act
    var result = EntityDependencySorter.SortByForeignKeys(allEntities, model);

    // Assert
    Assert.Equal("Department", result.Tables[0].Definition.LogicalName);  // Parent first
    Assert.Equal("User", result.Tables[1].Definition.LogicalName);  // Child second
    Assert.True(result.TopologicalOrderingApplied);
}
```

### Test 3: MERGE Idempotency
```csharp
[Fact]
public async Task LoadHarness_ApplyingBothStaticAndDynamic_Succeeds()
{
    // Arrange
    var db = CreateEmptyDatabase();
    await ApplyDDL(db, "tables.sql");

    var options = new LoadHarnessOptions
    {
        ConnectionString = db.ConnectionString,
        StaticSeedScriptPaths = ImmutableArray.Create("StaticEntities.seed.sql"),
        DynamicInsertScriptPaths = ImmutableArray.Create("DynamicData.all.dynamic.sql")
    };

    // Act - Apply both static seeds AND dynamic data (dynamic uses MERGE)
    var result = await loadHarnessRunner.RunAsync(options);

    // Assert - No errors, no duplicate key violations
    Assert.Empty(result.Errors);
    Assert.True(result.AllScriptsSucceeded);
}
```

## Migration Path

M1.0 is **purely additive** - no breaking changes to existing behavior.

### Non-Breaking Changes
1. **Add new directory**: `Bootstrap/` (gitignored)
2. **Rename directory**: `Seeds/` ‚Üí `BaselineSeeds/` (migration happens during first export after M1.0)
3. **Add new files**:
   - `Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql` (new artifact)
   - `PostDeployment-Bootstrap.sql` (new artifact at root)
4. **Add new configuration option**: `EmitPerTableSeeds` (default: `false`)

### Existing Behavior Preserved
- ‚úÖ Static seed generation unchanged (still uses MERGE, still topologically sorted)
- ‚úÖ Dynamic data generation unchanged (no modifications)
- ‚úÖ Existing exports continue to work
- ‚úÖ Users can opt-in to bootstrap snapshot workflow when ready

### Migration for Existing Users
1. Run `osm full-export` with M1.0 ‚Üí new `Bootstrap/` and `PostDeployment-Bootstrap.sql` files appear
2. Copy `PostDeployment-Bootstrap.sql` content into SSDT project's PostDeployment folder
3. Verify paths in SSDT match expected structure
4. Deploy to test environment and verify guard logic works correctly

## Success Criteria

1. ‚úÖ Bootstrap snapshot generated with ALL entities in global topological order
2. ‚úÖ Bootstrap snapshot includes observability measures (GO statements, PRINT diagnostics, topological comments)
3. ‚úÖ PostDeployment-Bootstrap.sql template dynamically adapts to emission mode (single-file, per-module, or per-table)
4. ‚úÖ Per-table emission mode works correctly (one .seed.sql file per static entity) - DEFERRED TO M1.5
5. ‚úÖ Guard logic correctly detects first vs. subsequent deployments
6. ‚úÖ Existing static seed emission unchanged (backward compatible)
7. ‚úÖ Directory rename (Seeds ‚Üí BaselineSeeds) happens automatically
8. ‚úÖ All existing tests pass
9. ‚úÖ New integration tests verify bootstrap snapshot correctness
10. ‚úÖ Operators can verify execution order from SSDT deployment output

## Observability and Defensive Measures (üî¥ IN M1.0 MVP)

**Status**: Critical for debuggability - included in M1.0 MVP
**Rationale**: While M1.0 bootstrap will be correct (uses proven EntityDependencySorter), observability measures are crucial for operators to verify execution order, diagnose issues, and build confidence in the deployment process.

### Root Cause Confirmation (For Context)

**VERIFIED** (via code analysis and user confirmation):
1. ‚úÖ Static entities ARE included in dynamic data (`SqlDynamicEntityDataProvider` does not filter by `IsStatic`)
2. ‚úÖ Topological sorting works correctly (`EntityDependencySorter` handles FK dependencies properly)
3. ‚úÖ The REAL issue: Static seed files partitioned by module + alphabetical module ordering in SSDT = cross-module FK violations

**User's Observation**: "Even when I reordered parent and child entities WITHIN a module, FK violations still occurred. The problem was cross-MODULE dependencies - ModuleA loaded before ModuleB alphabetically."

### Bootstrap Snapshot Defensive Measures

#### Measure 1: Junction Table Deferral Across All Entities

**Existing code**: `JunctionTableClassifier` (line 616-782) identifies junction tables:
- Entity has 2+ FK relationships to different tables (line 743-745)
- All non-PK columns are FKs (line 748-759)
- Junction tables get lower priority in sort (line 821: `ReadyQueueComparer`)

**Bootstrap requirement**: Junction classification must run on the COMBINED set of all entities (static + regular), not separately, to handle cross-boundary junctions correctly.

**Verification Required**:
- Ensure junction classification runs on **combined static + regular set**
- Test: Junction with 1 FK to static, 1 FK to regular entity

#### Measure 2: Explicit GO Statements Between Entities in Bootstrap Snapshot

**Purpose**: Ensure clear transaction boundaries between entities in the bootstrap snapshot file.

**Implementation**: Add explicit GO statements between entity scripts in bootstrap generation:

```csharp
foreach (var script in scripts)
{
    cancellationToken.ThrowIfCancellationRequested();

    builder.AppendLine(script.Script.TrimEnd());
    builder.AppendLine();
    builder.AppendLine("GO");  // ‚Üê DEFENSIVE: Ensure transaction boundary
    builder.AppendLine("-- ===== Entity boundary =====");
    builder.AppendLine();
}
```

**Rationale**: Even though each script ends with GO, an explicit boundary ensures previous entity's data is fully committed before next entity begins.

#### Measure 3: Diagnostic PRINT Statements for Bootstrap Execution

**Purpose**: Enable operators to verify bootstrap snapshot execution order and completion.

```csharp
private string BuildMergeScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] ‚úì Completed MERGE for {definition.Schema}.{definition.PhysicalName} (static entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}

private string BuildInsertScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] ‚úì Completed INSERT for {definition.Schema}.{definition.PhysicalName} (regular entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}
```

**Benefit**: LoadHarness output will show exactly which entities completed before FK violation occurs.

#### Measure 4: FK Constraint State Validation (Optional Enhancement)

**Purpose**: Verify FK constraints exist and are enabled before bootstrap snapshot execution.

```sql
-- Query sys.foreign_keys to list all FK constraints
-- Verify is_disabled = 0 (enabled)
-- Verify is_not_trusted = 0 (trusted, checks existing data)
-- Log any disabled or untrusted FKs as warnings
```

**Benefit**: Catches scenarios where FKs are created WITH NOCHECK or disabled, which would mask ordering issues.

#### Measure 5: Topological Position Comments in Bootstrap Snapshot

**Purpose**: Document topological position and dependencies in bootstrap snapshot for debugging.

```sql
--------------------------------------------------------------------------------
-- Entity: User (dbo.OSSYS_USER)
-- Topological Order: 15 of 87
-- Dependencies: Role (14), Department (12)  -- ‚Üê Shows parent positions
-- Dependents: AuditLog (23), Session (31)  -- ‚Üê Shows child positions
--------------------------------------------------------------------------------
```

**Benefit**: Easy visual verification that scripts are in correct order during debugging.

---

## Implementation Priority

### üî¥ M1.0 MVP (Ship This Week)

**Tasks**:
1. Create `BuildSsdtBootstrapSnapshotStep.cs`
   - Combine static + regular entities
   - Call existing `EntityDependencySorter.SortByForeignKeys()`
   - Generate MERGE script for all entities
   - **Add GO statements between entities** (transaction boundaries)
   - **Add PRINT diagnostics** for execution progress
   - **Add topological position comments** in generated scripts
   - Write to `Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql`

2. Create `BuildSsdtPostDeploymentTemplateStep.cs`
   - Guard logic: `IF NOT EXISTS (SELECT 1 FROM [canonical_static_table])`
   - Bootstrap include: `:r Bootstrap\AllEntitiesIncludingStatic.bootstrap.sql`
   - Baseline seeds includes (single-file or per-module)
   - Write to `PostDeployment-Bootstrap.sql`

3. Update directory structure
   - Rename `Seeds/` ‚Üí `BaselineSeeds/`
   - Create `Bootstrap/` directory
   - Mark Bootstrap/ as gitignored

4. Integration tests
   - Test bootstrap generation
   - Test PostDeployment template generation
   - Test guard logic detection
   - Verify observability output (PRINT statements, comments)

**Acceptance Criteria**:
- ‚úÖ `osm full-export` generates Bootstrap/ and PostDeployment-Bootstrap.sql
- ‚úÖ User can copy PostDeployment-Bootstrap.sql into SSDT project
- ‚úÖ First deployment applies bootstrap snapshot successfully
- ‚úÖ Subsequent deployments skip bootstrap, apply baseline seeds
- ‚úÖ No FK violations during SSDT deployment
- ‚úÖ Bootstrap snapshot includes GO statements, PRINT diagnostics, topological comments
- ‚úÖ Operators can verify execution order from SSDT output

---

### üü° M1.5 (Next Sprint)
**Per-Table Emission for Production**
- Add `EmitPerTableSeeds` configuration option
- Implement per-table emission in `BuildSsdtStaticSeedStep.cs`
- Update PostDeployment template to handle per-table mode
- Tests for per-table emission

---

## Summary

### Files Emitted by M1.0

| File | Purpose | Version Control | Used When |
|------|---------|----------------|-----------|
| `AllEntitiesIncludingStatic.bootstrap.sql` | Complete dataset (87 entities) topologically sorted | ‚ùå Gitignored | First deployment only |
| `PostDeployment-Bootstrap.sql` | SSDT PostDeployment template with guard + includes | ‚úÖ Copy to SSDT once | Every deployment (guard skips bootstrap after first) |
| `StaticEntities.seed.sql` | Baseline seeds (42 static entities) | ‚úÖ Committed | Every deployment (idempotent) |

### Why This Solves the Problem

**Original Issue**: Static seed files ordered alphabetically by module ‚Üí cross-module FK violations

**M1.0 Solution**:
1. **First deployment uses bootstrap snapshot** (global topological order, no module partitioning) ‚Üí FK dependencies satisfied
2. **Subsequent deployments use baseline seeds** (data already exists from bootstrap, MERGE is idempotent) ‚Üí order doesn't matter
3. **Module ordering becomes irrelevant** ‚Üí baseline seeds can be organized however is convenient for developers

**Conclusion**: M1.0 solves the FK constraint violation problem by:
1. **Bootstrap Snapshot**: First deployment uses global topological order (correct)
2. **Baseline Seeds**: Ongoing deployments use idempotent MERGE (order irrelevant)
3. **Clean Separation**: Administrative efficiency (bootstrap) vs. developer-maintained (baseline seeds)
