# M1.0: Global Topological Ordering with Bootstrap Snapshot

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION - MVP PRIORITY
**Priority**: üî¥ CRITICAL PATH - Ship this week

## Executive Summary

### The Specific Problem

SSDT deployments fail with **foreign key constraint violations** when applying static seed data. The root cause: static seed files are **partitioned by module** and SSDT applies them in **alphabetical module order**, which breaks cross-module foreign key dependencies.

**Example**: Module "Core" contains `User` (FK ‚Üí `Role`), Module "Security" contains `Role`. Alphabetical ordering loads Core before Security, causing `User` to reference non-existent `Role` ‚Üí FK violation.

### Recommended Solution

**Bootstrap Snapshot with Global Topological Ordering**

Generate a single `AllEntitiesIncludingStatic.bootstrap.sql` file containing ALL entities (static + regular) sorted in **global topological order** (ignoring module boundaries). This file is applied **once** on first deployment via a PostDeployment guard script. Subsequent deployments apply idempotent baseline seeds where data already exists.

This approach leverages the existing `EntityDependencySorter` infrastructure (967 lines of proven FK-aware topological sorting using Kahn's algorithm) and extends it to the complete entity set.

### How It Fixes the Problem

1. **First Deployment**: Bootstrap snapshot loads all entities in correct dependency order ‚Üí no FK violations
2. **Ongoing Deployments**: Baseline seeds run when data already exists ‚Üí idempotent MERGE, order irrelevant
3. **Module Ordering Irrelevant**: Since bootstrap establishes initial state correctly, alphabetical module ordering in baseline seeds doesn't matter

### Alternative Approaches Considered

**Alternative 1: Topological Module Ordering**
- Sort module files themselves in topological order
- **Rejected**: Complex inter-module dependency analysis, doesn't handle circular module dependencies, breaks when modules reorganized

**Alternative 2: Single-File Static Seeds**
- Emit all static entities in one file (no module partitioning)
- **Rejected**: Poor developer experience, loses organizational benefits of module grouping, makes version control diffs harder to review

**Alternative 3: Disable FK Constraints During Load**
- Use `ALTER TABLE NOCHECK CONSTRAINT`, load data, re-enable constraints
- **Rejected**: Risky (constraints might fail to re-enable if data inconsistent), doesn't prove correctness, masks actual dependency issues

**Alternative 4: Manual PostDeployment Ordering**
- Require developers to manually order `:r` includes in PostDeployment scripts
- **Rejected**: Error-prone, doesn't scale, breaks when entities added/removed, requires deep FK knowledge

**Why Bootstrap Snapshot Wins**: Automated, proven infrastructure, minimal risk, backward compatible, separates concerns (bootstrap for correctness, baseline seeds for maintenance).

### MVP Scope (Ship This Week)

1. ‚úÖ Bootstrap snapshot generation (`AllEntitiesIncludingStatic.bootstrap.sql`)
2. ‚úÖ PostDeployment template with guard logic (`PostDeployment-Bootstrap.sql`)
3. ‚úÖ Directory rename (Seeds ‚Üí BaselineSeeds)
4. ‚úÖ Observability measures: GO statements, PRINT diagnostics, topological comments
5. ‚úÖ Per-table baseline seed emission (`EmitPerTableSeeds` configuration option)

**Key Finding**: After comprehensive codebase analysis, **most infrastructure already exists**. This is about applying existing topological sorting to the complete entity set and orchestrating first-deployment vs. ongoing-deployment workflows.

---

## üö® Critical Path Analysis

### Why This Is MVP (Ship Now)

**Problem**: FK violations in SSDT static seed deployment block user's deadline
**Root Cause**: Alphabetical module ordering breaks cross-module FK dependencies
**Solution**: Bootstrap snapshot with global topological sort (no module partitioning)

**Timeline Note**: M1.0 can be developed in parallel with M1.1 (Export Verification Framework):
- M1.0 = Bootstrap generation code path (modifies `BuildSsdtStaticSeedStep`, creates new steps)
- M1.1 = Verification code path (new validation system, independent of M1.0 changes)
- Both target "ship this week" but can be worked on simultaneously by different developers or in sequence

**MVP Definition**: M1.0 + M1.1 constitute the "core MVP" (üî¥ critical path). M1.2/M1.3 are "basic validation" (üü° ship after core) that add safety checks without changing core functionality.

**What Ships in M1.0 MVP**:
| Component | Why Critical |
|-----------|--------------|
| Bootstrap snapshot | Fixes FK violations |
| PostDeployment template | Enables first-deployment guard logic |
| Directory rename | Clearer terminology for baseline vs. bootstrap |
| Observability measures | Crucial for debuggability (GO statements, PRINT, comments) |
| Per-table baseline seeds | Fine-grain version control from day one |

**What's Deferred (Not Blocking)**:
- **M1.7**: Topological proof (verification artifact, not functional requirement)
- **M1.8**: Data integrity (DMM replacement, separate from FK ordering)

**Architectural Soundness**: M1.0 MVP does NOT block future work:
- ‚úÖ Per-table emission included from day one (no migration needed later)
- ‚úÖ Observability included in M1.0 provides debuggability from day one
- ‚úÖ Proof generation consumes existing data structures (no M1.0 changes needed)
- ‚úÖ Data integrity is independent orchestration step (verifies M1.0's output)

### Verification Framework Architecture (M1.1 vs M1.8)

The specs define **two intentionally separate verification systems**:

**M1.1: Export Artifact Verification** (file-level validation)
- **Purpose**: Validate export artifacts (files exist, checksums match manifest)
- **Scope**: File system operations, no database queries
- **When**: Runs during/after export generation
- **Validates**: Manifest completeness, file integrity, artifact consistency
- **Example**: "Does `StaticEntities.seed.sql` exist and match the checksum in `manifest.json`?"

**M1.8: Data Integrity Verification** (database-level validation)
- **Purpose**: Validate data correctness (source DB matches target DB after load)
- **Scope**: Database queries, hash comparison, row count checks
- **When**: Runs after LoadHarness applies scripts to target database
- **Validates**: Row counts, NULL preservation, byte-identical data (via hash)
- **Example**: "Does the target `[Order]` table have the same 1000 rows as source `[OSUSR_R2K_Order]`?"

**Why Separate?**
- M1.1 = Static analysis (no running database required)
- M1.8 = Runtime analysis (requires both source and target databases)
- M1.1 catches generation bugs (missing files, corrupt artifacts)
- M1.8 catches transformation bugs (data loss, NULL handling, type conversion)
- M1.3 (basic integrity) is a lightweight subset of M1.8 for quick sanity checks

### Observability Layering (3-Tier Approach)

The specs define **three levels of observability**, balancing shipping speed with debugging capability:

**Tier 1: M1.0 Basic Observability** (IN MVP - ships this week)
- GO statements between entities (transaction boundaries)
- PRINT diagnostics during execution (shows progress)
- Topological position comments in generated scripts
- **Rationale**: Crucial for operators to verify execution order and diagnose issues during initial rollout
- **Overhead**: Minimal (text output only, no file generation)

**Tier 2: M1.2 Runtime Validation** (Basic validation - ships after M1.0)
- Fail-fast checks during export (catches child-before-parent violations)
- Actionable error messages if ordering is incorrect
- Logged to execution log (no artifacts)
- **Rationale**: Prevents invalid exports from reaching SSDT deployment
- **Overhead**: Single validation pass, < 100ms for typical datasets

**Tier 3: M1.7 Full Proof Artifacts** (Deferred - ships when operators request)
- JSON proof with full dependency graph
- Human-readable reports with visualizations
- Audit trail for compliance/documentation
- **Rationale**: Nice-to-have for documentation, not required for functionality
- **Overhead**: Additional file generation, JSON serialization

**Why This Balance?**
- M1.0 observability provides immediate debuggability without delaying MVP
- M1.2 validation prevents bugs without expensive proof generation
- M1.7 deferred until operators need formal documentation/auditing
- Iterative approach: ship functionality first, add comprehensive observability later

---

## Problem Statement

### Current Behavior - The Real Issue

**User's Observation**: FK constraint violations occur when applying static seed files in SSDT, even after manually reordering parent/child entities.

**Root Cause**: Static seed files are partitioned by module and emitted in **alphabetical module order**, breaking cross-module FK dependencies.

**Current Static Seed Flow**:
1. All static entities are topologically sorted globally ‚úÖ
2. Entities partitioned by module (preserving order within each module) ‚úÖ
3. Module files emitted in **alphabetical order** ‚ùå
4. SSDT applies files in ItemGroup order (alphabetical) ‚ùå

**Example Failure**:
- ModuleA contains `User` (FK ‚Üí `Role`)
- ModuleB contains `Role`
- Alphabetical order: ModuleA before ModuleB
- Result: `User` MERGEs before `Role` exists ‚Üí FK violation!

**Why Manual Reordering Didn't Help**:
- Reordering entities WITHIN a module preserves FK order within that module
- But cross-MODULE dependencies still violate due to alphabetical module file ordering

### Proposed Solution - Bootstrap Snapshot

**First Deployment Strategy**:
1. **Bootstrap Snapshot** (`AllEntitiesIncludingStatic.bootstrap.sql`):
   - ALL entities (static + regular) in ONE file
   - Global topological sort (no module partitioning)
   - MERGE for all entities (idempotent)
   - Applied ONCE on first deployment via conditional PostDeployment script
   - **Not committed to source control** (ephemeral artifact)

2. **Baseline Seeds** (`StaticEntities.seed.sql` or per-module/per-entity files):
   - Static entities only
   - Version controlled, developer-maintained
   - Applied on EVERY deployment (idempotent MERGE)
   - Module ordering becomes irrelevant (data already exists from bootstrap)

**Workflow**:
```
First Deployment:
  1. SSDT creates tables + FK constraints
  2. PostDeployment guard detects "first run"
  3. Bootstrap snapshot applies (all entities, topologically sorted)
  4. Baseline seeds apply (no-op, data already exists)
  5. Guard marks bootstrap as "applied"

Ongoing Deployments:
  1. SSDT updates schema if needed
  2. PostDeployment guard detects "already bootstrapped"
  3. Bootstrap snapshot skipped
  4. Baseline seeds apply (maintain static reference data)
```

## Codebase Reality Check - What Already Exists

### ‚úÖ Infrastructure ALREADY Implemented

| Component | File | Lines | Status |
|-----------|------|-------|--------|
| **FK-aware topological sorting** | `EntityDependencySorter.cs` | 967 | ‚úÖ Complete |
| **Kahn's algorithm** | `EntityDependencySorter.TopologicalSort()` | 264-302 | ‚úÖ Implemented |
| **Cycle detection + fallback** | `EntityDependencySorter.SortByForeignKeys()` | 122-156 | ‚úÖ Implemented |
| **Junction table deferral** | `JunctionTableClassifier` | 616-782 | ‚úÖ Implemented |
| **Self-referencing FK ordering** | `DynamicEntityInsertGenerator.OrderRows()` | 152-405 | ‚úÖ Implemented |
| **FK preflight validation** | `StaticSeedForeignKeyPreflight.cs` | 217 | ‚úÖ Implemented |
| **SMO enrichment** | `RelationshipConstraintHydrator.cs` | 292 | ‚úÖ **EXISTS!** |
| **LoadHarness trust manifest** | `LoadHarnessRunner.BuildScriptQueue()` | 169-206 | ‚úÖ Verified |
| **Ordering telemetry** | `BuildSsdtStaticSeedStep.cs` | 158-172 | ‚úÖ Implemented |

### üîç SMO Enrichment Discovery

**File**: `src/Osm.Pipeline/ModelIngestion/RelationshipConstraintMetadataProvider.cs`

**Key Query** (lines 72-94):
```csharp
SELECT
    mc.SchemaName,
    mc.TableName,
    mc.ConstraintName,
    fkc.constraint_column_id AS Ordinal,
    parent_col.name AS ParentColumn,
    ref_col.name AS ReferencedColumn,
    ref_schema.name AS ReferencedSchema,
    ref_table.name AS ReferencedTable
FROM MissingConstraints mc
JOIN sys.schemas parent_schema ON parent_schema.name = mc.SchemaName
JOIN sys.tables parent_table ON parent_table.schema_id = parent_schema.schema_id AND parent_table.name = mc.TableName
JOIN sys.foreign_keys fk ON fk.parent_object_id = parent_table.object_id AND fk.name = mc.ConstraintName
JOIN sys.foreign_key_columns fkc ON fkc.constraint_object_id = fk.object_id
-- ... (joins to get column names)
```

**Usage**: `RelationshipConstraintHydrator.HydrateAsync()` (line 30-68)
- Finds relationships with missing constraint metadata (`NeedsHydration()`)
- Queries SQL Server via `sys.foreign_keys` to get actual FK column mappings
- Enriches the `OsmModel` with complete FK metadata

**Status**: This is existing infrastructure that was discovered during spec research. It already runs during model extraction in `ModelIngestionService`, enriching FK metadata from SQL Server system catalogs. This is critical for topological sorting because it captures manually-added FK constraints that aren't defined in OutSystems metamodel.

### ‚ùå What M1.0 Must Address

| Issue | Current Impact | M1.0 Solution |
|-------|----------------|---------------|
| **Module partitioning breaks order** | When `GroupByModule=true`, static seed files ordered alphabetically by module ‚Üí cross-module FK violations in SSDT | ‚úÖ Bootstrap snapshot with global topological sort (no module partitioning) |
| **No bootstrap snapshot** | First SSDT deployment must apply static seeds in correct order, but module alphabetization breaks this | ‚úÖ Generate `AllEntitiesIncludingStatic.bootstrap.sql` for first deployment |
| **No PostDeployment template** | Users must manually create PostDeployment scripts with guard logic | ‚úÖ Generate `PostDeployment-Bootstrap.sql` template |

**Note**: Static entities ARE already included in dynamic data export (`DynamicDataset`) - verified in code. The issue is NOT missing data, but incorrect FILE ORDERING during SSDT deployment of static seed files.

## New File Emissions

### 1. Bootstrap Snapshot (Single File)

**File**: `AllEntitiesIncludingStatic.bootstrap.sql`

**Location**: `{OutputDirectory}/Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql`

**Content**:
- ALL entities (static + regular) in global topological order
- MERGE statements for all entities (idempotent)
- Header comments showing topological position and dependencies
- GO statements between entities for transaction boundaries

**Characteristics**:
- Generated once per export
- **Not version controlled** (add to .gitignore)
- Used only for first deployment
- Self-contained (no external dependencies)

**Example Structure**:
```sql
--------------------------------------------------------------------------------
-- Bootstrap Snapshot: All Entities (Static + Regular)
-- Generated: 2025-11-18
-- Total Entities: 300 (100 static, 200 regular) across 19 modules
-- Sorted: Global topological order (no module partitioning)
--------------------------------------------------------------------------------

-- Entity: Role (dbo.OSSYS_ROLE)
-- Topological Order: 1 of 300 (no dependencies)
-- Type: Static
MERGE INTO [dbo].[OSSYS_ROLE] AS Target
USING (VALUES ...) AS Source (...)
ON Target.[Id] = Source.[Id]
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
GO

-- Entity: User (dbo.OSSYS_USER)
-- Topological Order: 2 of 87 (depends on: Role)
-- Type: Static
MERGE INTO [dbo].[OSSYS_USER] AS Target
USING (VALUES ...) AS Source (...)
ON Target.[Id] = Source.[Id]
WHEN MATCHED THEN UPDATE SET ...
WHEN NOT MATCHED THEN INSERT (...) VALUES (...);
GO

-- ... continues for all 300 entities ...
```

### 2. PostDeployment Bootstrap Template (NEW!)

**File**: `PostDeployment-Bootstrap.sql`

**Location**: `{OutputDirectory}/PostDeployment-Bootstrap.sql`

**Purpose**: Ready-to-copy PostDeployment script for SSDT that conditionally applies bootstrap and baseline seeds

**Content**: Guard logic + dynamic `:r` includes

**Example (Single-File Baseline Seeds Mode)**:
```sql
--------------------------------------------------------------------------------
-- PostDeployment Bootstrap Script
-- Generated: 2025-11-18
-- Usage: Copy to SSDT project's PostDeployment folder
--------------------------------------------------------------------------------

-- Guard: Only apply bootstrap snapshot on first deployment
IF NOT EXISTS (SELECT 1 FROM [dbo].[OSSYS_ROLE])
BEGIN
    PRINT 'First deployment detected - applying bootstrap snapshot';
    PRINT 'Loading: Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql';

    :r Bootstrap\AllEntitiesIncludingStatic.bootstrap.sql

    PRINT 'Bootstrap snapshot applied successfully (300 entities)';
END
ELSE
BEGIN
    PRINT 'Existing deployment detected - skipping bootstrap snapshot';
END
GO

--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds (static entities)';

:r BaselineSeeds\StaticEntities.seed.sql

PRINT 'Baseline seeds applied successfully';
GO
```

**Example (Per-Module Baseline Seeds Mode)**:
```sql
-- ... guard logic same as above ...

--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds (static entities) from multiple modules';

-- Module: Core
:r BaselineSeeds\Core\StaticEntities.seed.sql

-- Module: Security
:r BaselineSeeds\Security\StaticEntities.seed.sql

-- Module: Workflow
:r BaselineSeeds\Workflow\StaticEntities.seed.sql

PRINT 'Baseline seeds applied successfully (3 modules)';
GO
```

**Dynamic Generation Logic**:
- Read `BuildSsdtPipelineRequest.StaticSeedOptions.GroupByModule`
- If `false`: Emit single `:r` for `StaticEntities.seed.sql`
- If `true`: Emit multiple `:r` statements for each module file (in alphabetical order for readability, but doesn't matter due to idempotency)

### 3. Baseline Seeds (Existing, No Changes)

**File(s)**: `StaticEntities.seed.sql` or per-module/per-entity files

**Location**: `{OutputDirectory}/BaselineSeeds/`

**Content**: Static entities only (no change from current behavior)

**Characteristics**:
- Version controlled
- Developer-maintained
- Applied on every deployment
- Idempotent MERGE statements

## Implementation Scope

### Change 1: Generate Bootstrap Snapshot File

**New Step**: `BuildSsdtBootstrapSnapshotStep.cs`

**Purpose**: Generate `AllEntitiesIncludingStatic.bootstrap.sql` containing all entities in global topological order

**Implementation**:
```csharp
public async Task<BuildSsdtPipelineState> ExecuteAsync(
    BuildSsdtPipelineState state,
    CancellationToken cancellationToken)
{
    // 1. Combine static + regular entity datasets
    var staticEntities = state.StaticSeedData ?? ImmutableArray<StaticEntityTableData>.Empty;
    var regularEntities = state.Request.DynamicDataset?.Tables ?? ImmutableArray<StaticEntityTableData>.Empty;
    var allEntities = staticEntities.Concat(regularEntities).ToImmutableArray();

    // 2. Global topological sort (use existing EntityDependencySorter)
    var ordering = EntityDependencySorter.SortByForeignKeys(
        allEntities,
        state.Bootstrap.FilteredModel,
        state.Request.Scope.SmoOptions.NamingOverrides,
        state.Request.Scope.StaticSeedOptions.SortOptions);

    // 3. Generate MERGE script for all entities
    var bootstrapScript = GenerateBootstrapScript(ordering.Tables, state);

    // 4. Write to Bootstrap directory
    var bootstrapDirectory = Path.Combine(state.Request.OutputDirectory, "Bootstrap");
    Directory.CreateDirectory(bootstrapDirectory);
    var bootstrapPath = Path.Combine(bootstrapDirectory, "AllEntitiesIncludingStatic.bootstrap.sql");
    await File.WriteAllTextAsync(bootstrapPath, bootstrapScript, Utf8NoBom, cancellationToken);

    // 5. Log metrics
    state.Log.Record(
        "bootstrap.snapshot.generated",
        $"Generated bootstrap snapshot with {ordering.Tables.Length} entities",
        new PipelineLogMetadataBuilder()
            .WithCount("entities.total", ordering.Tables.Length)
            .WithCount("entities.static", ordering.Tables.Count(t => IsStatic(t)))
            .WithCount("entities.regular", ordering.Tables.Count(t => !IsStatic(t)))
            .WithValue("ordering.applied", ordering.TopologicalOrderingApplied)
            .Build());

    return state with { BootstrapSnapshotPath = bootstrapPath };
}
```

**Key Points**:
- Static entities ARE already in `DynamicDataset` (verified via code analysis)
- Use existing `EntityDependencySorter` for global sort
- Generate MERGE for ALL entities (reuse `StaticSeedSqlBuilder` logic)

### Change 2: Generate PostDeployment Bootstrap Template

**New Step**: `BuildSsdtPostDeploymentTemplateStep.cs`

**Purpose**: Generate `PostDeployment-Bootstrap.sql` with guard logic and dynamic `:r` includes

**Implementation**:
```csharp
public async Task<BuildSsdtPipelineState> ExecuteAsync(
    BuildSsdtPipelineState state,
    CancellationToken cancellationToken)
{
    var builder = new StringBuilder();

    // Header
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("-- PostDeployment Bootstrap Script");
    builder.AppendLine($"-- Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
    builder.AppendLine("-- Usage: Copy to SSDT project's PostDeployment folder");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine();

    // Guard: Only apply bootstrap on first deployment
    builder.AppendLine("-- Guard: Only apply bootstrap snapshot on first deployment");

    // Pick a canonical static table for the guard check
    var canonicalTable = GetCanonicalStaticTable(state);
    builder.AppendLine($"IF NOT EXISTS (SELECT 1 FROM [{canonicalTable.Schema}].[{canonicalTable.PhysicalName}])");
    builder.AppendLine("BEGIN");
    builder.AppendLine("    PRINT 'First deployment detected - applying bootstrap snapshot';");
    builder.AppendLine("    PRINT 'Loading: Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql';");
    builder.AppendLine();
    builder.AppendLine("    :r Bootstrap\\AllEntitiesIncludingStatic.bootstrap.sql");
    builder.AppendLine();
    builder.AppendLine($"    PRINT 'Bootstrap snapshot applied successfully ({state.StaticSeedData.Length + state.Request.DynamicDataset.Tables.Length} entities)';");
    builder.AppendLine("END");
    builder.AppendLine("ELSE");
    builder.AppendLine("BEGIN");
    builder.AppendLine("    PRINT 'Existing deployment detected - skipping bootstrap snapshot';");
    builder.AppendLine("END");
    builder.AppendLine("GO");
    builder.AppendLine();

    // Baseline Seeds: Dynamic includes based on emission mode
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("-- Baseline Seeds (Static Entities) - Applied on every deployment");
    builder.AppendLine("--------------------------------------------------------------------------------");
    builder.AppendLine("PRINT 'Applying baseline seeds (static entities)';");
    builder.AppendLine();

    var seedPaths = state.StaticSeedScriptPaths;
    if (seedPaths.IsDefaultOrEmpty || seedPaths.Length == 1)
    {
        // Single file mode
        builder.AppendLine(":r BaselineSeeds\\StaticEntities.seed.sql");
    }
    else
    {
        // Per-module mode
        builder.AppendLine("PRINT 'Applying baseline seeds from multiple modules';");
        builder.AppendLine();

        foreach (var seedPath in seedPaths.OrderBy(p => p))
        {
            var relativePath = GetRelativePathFromOutput(seedPath, state.Request.OutputDirectory);
            var moduleName = Path.GetFileName(Path.GetDirectoryName(relativePath));

            builder.AppendLine($"-- Module: {moduleName}");
            builder.AppendLine($":r {relativePath.Replace("/", "\\")}");
            builder.AppendLine();
        }
    }

    builder.AppendLine("PRINT 'Baseline seeds applied successfully';");
    builder.AppendLine("GO");

    // Write template file
    var templatePath = Path.Combine(state.Request.OutputDirectory, "PostDeployment-Bootstrap.sql");
    await File.WriteAllTextAsync(templatePath, builder.ToString(), Utf8NoBom, cancellationToken);

    state.Log.Record(
        "postDeployment.template.generated",
        "Generated PostDeployment bootstrap template",
        new PipelineLogMetadataBuilder()
            .WithPath("template", templatePath)
            .WithCount("baselineSeedFiles", seedPaths.Length)
            .Build());

    return state with { PostDeploymentTemplatePath = templatePath };
}
```

**Key Logic**:
- Guard uses first static table as "has data" indicator
- Bootstrap snapshot path is hardcoded relative path (user copies template to SSDT)
- Baseline seed includes are dynamically generated based on `GroupByModule` setting
- All paths use backslashes for Windows compatibility

### Change 3: Output Directory Restructuring

**Current Structure** (verified from codebase):
```
{OutputDirectory}/
‚îú‚îÄ‚îÄ Modules/              ‚Üê Tables emitted here (SsdtEmitter.cs:82)
‚îÇ   ‚îî‚îÄ‚îÄ [TableFiles]
‚îú‚îÄ‚îÄ Seeds/                ‚Üê Static seeds currently emitted here (BuildSsdtStaticSeedStep.cs:96)
‚îÇ   ‚îú‚îÄ‚îÄ [Module1]/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql
‚îÇ   ‚îú‚îÄ‚îÄ [Module2]/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql
‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql (master file if EmitMasterFile=true)
‚îú‚îÄ‚îÄ DynamicData/          ‚Üê Dynamic data emitted here (BuildSsdtDynamicInsertStep.cs:134)
‚îÇ   ‚îú‚îÄ‚îÄ [Module1]/        (PerEntity mode)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [TableName].dynamic.sql
‚îÇ   ‚îú‚îÄ‚îÄ [Module2]/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [TableName].dynamic.sql
‚îÇ   ‚îî‚îÄ‚îÄ DynamicData.all.dynamic.sql (SingleFile mode)
‚îî‚îÄ‚îÄ manifest.json
```

**New Structure** (after M1.0):
```
{OutputDirectory}/
‚îú‚îÄ‚îÄ Modules/              ‚Üê UNCHANGED (tables go here, ForeignKeys are part of table definitions)
‚îÇ   ‚îî‚îÄ‚îÄ [TableFiles]
‚îú‚îÄ‚îÄ Bootstrap/            ‚Üê NEW
‚îÇ   ‚îî‚îÄ‚îÄ AllEntitiesIncludingStatic.bootstrap.sql
‚îú‚îÄ‚îÄ BaselineSeeds/        ‚Üê RENAMED from Seeds/
‚îÇ   ‚îú‚îÄ‚îÄ StaticEntities.seed.sql            (single-file mode - default)
‚îÇ   ‚îú‚îÄ‚îÄ [Module1]/                         (per-module mode)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql
‚îÇ   ‚îî‚îÄ‚îÄ [Module1]/                         (per-table mode - NEW FEATURE)
‚îÇ       ‚îú‚îÄ‚îÄ [Table1].seed.sql
‚îÇ       ‚îî‚îÄ‚îÄ [Table2].seed.sql
‚îî‚îÄ‚îÄ PostDeployment-Bootstrap.sql   ‚Üê NEW (copy to SSDT)
```

**Key Changes**:
- Add `Bootstrap/` directory (gitignored) for bootstrap snapshot
- Rename `Seeds/` ‚Üí `BaselineSeeds/` (clearer terminology)
- Add root-level `PostDeployment-Bootstrap.sql` template
- **NEW**: Support per-table emission mode (see Change 4 below)
- **NOTE**: DynamicData/ folder removed from typical SSDT workflow (bootstrap snapshot replaces it for deployment)

### Change 4: Per-Table Baseline Seed Emission (üü° DEFERRED TO M1.5)

**Status**: Production enhancement - NOT in M1.0 MVP
**Priority**: Ship in M1.5 after MVP proven (0.5 days effort)
**Reason for Deferral**: Nice-to-have for fine-grain version control, not required to fix FK violations

**Current Emission Modes** (BuildSsdtStaticSeedStep.cs:102-155):
1. **Single-file mode** (`GroupByModule = false`):
   - Output: `BaselineSeeds/StaticEntities.seed.sql`
   - All static entities in one file
   - Default, administrative convenience

2. **Per-module mode** (`GroupByModule = true`):
   - Output: `BaselineSeeds/{Module}/StaticEntities.seed.sql`
   - One file per module
   - Better organization for large apps

**NEW Mode - Per-Table Emission**:
3. **Per-table mode** (`EmitPerTableSeeds = true`):
   - Output: `BaselineSeeds/{Module}/{TableName}.seed.sql`
   - One file per static entity table
   - Finest-grain organization for version control
   - Useful in production with many static entities

**Implementation**:

```csharp
// In BuildSsdtStaticSeedStep.cs, add after line 102:
if (seedOptions.EmitPerTableSeeds)
{
    // Per-table emission mode
    var modules = orderedData
        .GroupBy(table => table.Definition.Module, StringComparer.OrdinalIgnoreCase)
        .OrderBy(group => group.Key, StringComparer.OrdinalIgnoreCase);

    foreach (var moduleGroup in modules)
    {
        var moduleName = moduleGroup.Key;
        var sanitizedModule = state.Request.Scope.SmoOptions.SanitizeModuleNames
            ? ModuleNameSanitizer.Sanitize(moduleName)
            : moduleName;

        var moduleDirectoryName = ResolveModuleDirectoryName(
            moduleName,
            sanitizedModule,
            usedModuleNames,
            state.Log,
            "staticData.seed.moduleNameRemapped");

        var moduleDirectory = Path.Combine(seedsRoot!, moduleDirectoryName);
        Directory.CreateDirectory(moduleDirectory);

        // Emit one file per table
        foreach (var table in moduleGroup)
        {
            var tableName = table.Definition.PhysicalName;
            var tablePath = Path.Combine(moduleDirectory, $"{tableName}.seed.sql");

            await _seedGenerator
                .WriteAsync(tablePath, ImmutableArray.Create(table), seedOptions.SynchronizationMode, model, cancellationToken)
                .ConfigureAwait(false);

            seedPathBuilder.Add(tablePath);
        }
    }
}
else if (seedOptions.GroupByModule)
{
    // Existing per-module mode...
}
```

**PostDeployment Template Update**:

The `BuildSsdtPostDeploymentTemplateStep` must dynamically detect emission mode and inline all files:

```csharp
// In BuildSsdtPostDeploymentTemplateStep.cs:
var seedPaths = state.StaticSeedScriptPaths;

if (seedPaths.IsDefaultOrEmpty || seedPaths.Length == 0)
{
    // No seeds
    builder.AppendLine("-- No baseline seeds emitted");
}
else if (seedPaths.Length == 1)
{
    // Single file mode
    var relativePath = GetRelativePathFromOutput(seedPaths[0], state.Request.OutputDirectory);
    builder.AppendLine($":r {relativePath.Replace("/", "\\")}");
}
else
{
    // Multiple files (per-module OR per-table mode)
    builder.AppendLine($"-- Applying baseline seeds from {seedPaths.Length} files");
    builder.AppendLine();

    foreach (var seedPath in seedPaths.OrderBy(p => p))
    {
        var relativePath = GetRelativePathFromOutput(seedPath, state.Request.OutputDirectory);
        var fileName = Path.GetFileName(relativePath);
        var moduleName = Path.GetFileName(Path.GetDirectoryName(relativePath));

        builder.AppendLine($"-- {moduleName}/{fileName}");
        builder.AppendLine($":r {relativePath.Replace("/", "\\")}");
        builder.AppendLine();
    }
}
```

**Example PostDeployment-Bootstrap.sql (Per-Table Mode)**:
```sql
--------------------------------------------------------------------------------
-- Baseline Seeds (Static Entities) - Applied on every deployment
--------------------------------------------------------------------------------
PRINT 'Applying baseline seeds from 42 files';

-- Core/OSSYS_ROLE.seed.sql
:r BaselineSeeds\Core\OSSYS_ROLE.seed.sql

-- Core/OSSYS_USER.seed.sql
:r BaselineSeeds\Core\OSSYS_USER.seed.sql

-- Security/OSSYS_PERMISSION.seed.sql
:r BaselineSeeds\Security\OSSYS_PERMISSION.seed.sql

-- ... continues for all 100 static entities across 19 modules ...

PRINT 'Baseline seeds applied successfully (100 static entities)';
GO
```

**Configuration Option**:
Add to `StaticSeedOptions`:
```csharp
public sealed record StaticSeedOptions(
    bool GroupByModule,
    bool EmitMasterFile,
    bool EmitPerTableSeeds,  // ‚Üê NEW
    StaticSeedSynchronizationMode SynchronizationMode);
```

**User Workflow**:
```bash
# Default: Single file (administrative convenience)
osm full-export --output ./MyApp

# Production: Per-table emission for granular version control
osm full-export --output ./MyApp --emit-per-table-seeds
```

### Change 5: Module Ordering (Now Lower Priority)

**Status**: Module alphabetical ordering is **no longer critical** because:

1. Bootstrap snapshot loads all data on first deployment (correct order guaranteed)
2. Baseline seeds run on subsequent deployments when data already exists (idempotent MERGE, order doesn't matter)
3. Cross-module FK violations can only occur if:
   - Bootstrap snapshot was skipped (user error)
   - Database was manually modified to remove data

**Recommendation**: Defer module topological ordering to future enhancement. Current approach solves the problem without this complexity.

**Optional Enhancement** (if desired later):
- Add warning log if cross-module FK dependencies detected
- Suggest using single-file mode instead of GroupByModule
- Or implement topological module ordering (replace line 107 alphabetical sort with topological sort of modules)

## User Workflow

### Generation (Developer runs OSM export)

```bash
osm full-export --output ./MyApp
```

**Output**:
```
MyApp/
‚îú‚îÄ‚îÄ Modules/                                       (Tables - unchanged)
‚îÇ   ‚îî‚îÄ‚îÄ [TableFiles]
‚îú‚îÄ‚îÄ Bootstrap/
‚îÇ   ‚îî‚îÄ‚îÄ AllEntitiesIncludingStatic.bootstrap.sql  (300 entities, topologically sorted)
‚îú‚îÄ‚îÄ BaselineSeeds/
‚îÇ   ‚îî‚îÄ‚îÄ StaticEntities.seed.sql                   (100 static entities, idempotent MERGE)
‚îî‚îÄ‚îÄ PostDeployment-Bootstrap.sql                   (COPY THIS TO SSDT)
```

**Note**: DynamicData/ folder not needed for SSDT deployment (bootstrap snapshot contains all data).

### Integration (Developer copies template to SSDT)

```bash
# Copy the generated template into SSDT project
cp MyApp/PostDeployment-Bootstrap.sql MyApp.sqlproj/PostDeployment/01-Bootstrap.sql

# Verify paths in SSDT project match expected structure
# Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql (relative to .sqlproj)
# BaselineSeeds/StaticEntities.seed.sql (relative to .sqlproj)
```

### First Deployment (SSDT to fresh database)

```
1. SSDT builds .dacpac
2. SSDT deploys:
   - Creates tables (DDL)
   - Creates FK constraints (ALTER TABLE ADD CONSTRAINT)
   - Runs PostDeployment/01-Bootstrap.sql:
     a. Guard checks: SELECT 1 FROM [OSSYS_ROLE] ‚Üí empty ‚Üí first deployment!
     b. Includes Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql
     c. All 300 entities loaded in topological order (MERGE)
     d. Includes BaselineSeeds/StaticEntities.seed.sql
     e. 100 static entities apply (no-op, already loaded via bootstrap)
```

### Ongoing Deployments (SSDT to existing database)

```
1. Developer modifies static seed data (e.g., adds new Role)
2. Updates BaselineSeeds/StaticEntities.seed.sql
3. SSDT deploys:
   - Updates schema if needed
   - Runs PostDeployment/01-Bootstrap.sql:
     a. Guard checks: SELECT 1 FROM [OSSYS_ROLE] ‚Üí has data ‚Üí skip bootstrap!
     b. Includes BaselineSeeds/StaticEntities.seed.sql
     c. 100 static entities apply (idempotent MERGE, updates new Role)
```

## Test Scenarios

### Test 1: MERGE Script Generation
```csharp
[Fact]
public void BuildMergeScript_WithCompositePrimaryKey_EmitsCorrectMerge()
{
    var definition = new StaticEntitySeedTableDefinition(
        Module: "Core",
        LogicalName: "Permission",
        Schema: "dbo",
        PhysicalName: "OSSYS_PERMISSION",
        EffectiveName: "OSSYS_PERMISSION",
        Columns: ImmutableArray.Create(
            new StaticEntitySeedColumn("RoleId", "RoleId", "RoleId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("ResourceId", "ResourceId", "ResourceId", "uniqueidentifier", null, null, null, IsPrimaryKey: true, IsIdentity: false, IsNullable: false),
            new StaticEntitySeedColumn("CanRead", "CanRead", "CanRead", "bit", null, null, null, IsPrimaryKey: false, IsIdentity: false, IsNullable: false)
        ),
        IsStatic: true);

    var rows = ImmutableArray.Create(
        StaticEntityRow.Create(new object[] {
            Guid.Parse("00000000-0000-0000-0000-000000000001"),
            Guid.Parse("00000000-0000-0000-0000-000000000002"),
            true
        }));

    var script = generator.BuildScript(definition, rows, batchSize: 1000);

    Assert.Contains("MERGE INTO [dbo].[OSSYS_PERMISSION]", script);
    Assert.Contains("ON Target.[RoleId] = Source.[RoleId] AND Target.[ResourceId] = Source.[ResourceId]", script);
    Assert.Contains("WHEN NOT MATCHED THEN", script);
    Assert.DoesNotContain("SET IDENTITY_INSERT", script);
}
```

### Test 2: Cross-Boundary FK Ordering
```csharp
[Fact]
public void SortByForeignKeys_WithStaticToRegularFK_OrdersGlobally()
{
    // Arrange: User (static) ‚Üí Department (regular)
    var model = CreateModelWithCrossBoundaryFK();
    var staticUser = CreateStaticEntityTable("User", isStatic: true, fkTo: "Department");
    var regularDept = CreateRegularEntityTable("Department", isStatic: false);
    var allEntities = ImmutableArray.Create(staticUser, regularDept);  // Wrong order

    // Act
    var result = EntityDependencySorter.SortByForeignKeys(allEntities, model);

    // Assert
    Assert.Equal("Department", result.Tables[0].Definition.LogicalName);  // Parent first
    Assert.Equal("User", result.Tables[1].Definition.LogicalName);  // Child second
    Assert.True(result.TopologicalOrderingApplied);
}
```

### Test 3: MERGE Idempotency
```csharp
[Fact]
public async Task LoadHarness_ApplyingBothStaticAndDynamic_Succeeds()
{
    // Arrange
    var db = CreateEmptyDatabase();
    await ApplyDDL(db, "tables.sql");

    var options = new LoadHarnessOptions
    {
        ConnectionString = db.ConnectionString,
        StaticSeedScriptPaths = ImmutableArray.Create("StaticEntities.seed.sql"),
        DynamicInsertScriptPaths = ImmutableArray.Create("DynamicData.all.dynamic.sql")
    };

    // Act - Apply both static seeds AND dynamic data (dynamic uses MERGE)
    var result = await loadHarnessRunner.RunAsync(options);

    // Assert - No errors, no duplicate key violations
    Assert.Empty(result.Errors);
    Assert.True(result.AllScriptsSucceeded);
}
```

### End-to-End Integration Testing

**Note**: The above tests focus on unit-level validation. A comprehensive end-to-end integration test should validate the complete flow:

1. **Export** ‚Üí Generate bootstrap snapshot + baseline seeds + PostDeployment template (M1.0)
2. **Verify Artifacts** ‚Üí Validate files exist, checksums match (M1.1)
3. **Apply Bootstrap** ‚Üí LoadHarness applies bootstrap to empty target DB
4. **Validate Ordering** ‚Üí Runtime checks confirm no child-before-parent violations (M1.2)
5. **Verify Data** ‚Üí Row counts and NULL counts match source (M1.3)
6. **Apply Baseline Seeds** ‚Üí LoadHarness applies baseline seeds (should be no-op due to MERGE idempotency)
7. **Verify Proof** ‚Üí Topological proof artifacts generated correctly (M1.7, deferred)

This end-to-end test should be added to **M1.4 (verification test coverage)** or created as a separate integration test suite.

---

## Migration Path

M1.0 is **purely additive** - no breaking changes to existing behavior.

### Non-Breaking Changes
1. **Add new directory**: `Bootstrap/` (gitignored)
2. **Rename directory**: `Seeds/` ‚Üí `BaselineSeeds/` (migration happens during first export after M1.0)
3. **Add new files**:
   - `Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql` (new artifact)
   - `PostDeployment-Bootstrap.sql` (new artifact at root)
4. **Add new configuration option**: `EmitPerTableSeeds` (default: `false`)

### Existing Behavior Preserved
- ‚úÖ Static seed generation unchanged (still uses MERGE, still topologically sorted)
- ‚úÖ Dynamic data generation unchanged (no modifications)
- ‚úÖ Existing exports continue to work
- ‚úÖ Users can opt-in to bootstrap snapshot workflow when ready

### Migration for Existing Users
1. Run `osm full-export` with M1.0 ‚Üí new `Bootstrap/` and `PostDeployment-Bootstrap.sql` files appear
2. Copy `PostDeployment-Bootstrap.sql` content into SSDT project's PostDeployment folder
3. Verify paths in SSDT match expected structure
4. Deploy to test environment and verify guard logic works correctly

## Success Criteria

1. ‚úÖ Bootstrap snapshot generated with ALL entities in global topological order
2. ‚úÖ Bootstrap snapshot includes observability measures (GO statements, PRINT diagnostics, topological comments)
3. ‚úÖ PostDeployment-Bootstrap.sql template dynamically adapts to emission mode (single-file, per-module, or per-table)
4. ‚úÖ Per-table emission mode works correctly (one .seed.sql file per static entity) - DEFERRED TO M1.5
5. ‚úÖ Guard logic correctly detects first vs. subsequent deployments
6. ‚úÖ Existing static seed emission unchanged (backward compatible)
7. ‚úÖ Directory rename (Seeds ‚Üí BaselineSeeds) happens automatically
8. ‚úÖ All existing tests pass
9. ‚úÖ New integration tests verify bootstrap snapshot correctness
10. ‚úÖ Operators can verify execution order from SSDT deployment output

## Observability and Defensive Measures (üî¥ IN M1.0 MVP)

**Status**: Critical for debuggability - included in M1.0 MVP
**Rationale**: While M1.0 bootstrap will be correct (uses proven EntityDependencySorter), observability measures are crucial for operators to verify execution order, diagnose issues, and build confidence in the deployment process.

### Root Cause Confirmation (For Context)

**VERIFIED** (via code analysis and user confirmation):
1. ‚úÖ Static entities ARE included in dynamic data (`SqlDynamicEntityDataProvider` does not filter by `IsStatic`)
2. ‚úÖ Topological sorting works correctly (`EntityDependencySorter` handles FK dependencies properly)
3. ‚úÖ The REAL issue: Static seed files partitioned by module + alphabetical module ordering in SSDT = cross-module FK violations

**User's Observation**: "Even when I reordered parent and child entities WITHIN a module, FK violations still occurred. The problem was cross-MODULE dependencies - ModuleA loaded before ModuleB alphabetically."

### Bootstrap Snapshot Defensive Measures

#### Measure 1: Junction Table Deferral Across All Entities

**Existing code**: `JunctionTableClassifier` (line 616-782) identifies junction tables:
- Entity has 2+ FK relationships to different tables (line 743-745)
- All non-PK columns are FKs (line 748-759)
- Junction tables get lower priority in sort (line 821: `ReadyQueueComparer`)

**Bootstrap requirement**: Junction classification must run on the COMBINED set of all entities (static + regular), not separately, to handle cross-boundary junctions correctly.

**Verification Required**:
- Ensure junction classification runs on **combined static + regular set**
- Test: Junction with 1 FK to static, 1 FK to regular entity

#### Measure 2: Explicit GO Statements Between Entities in Bootstrap Snapshot

**Purpose**: Ensure clear transaction boundaries between entities in the bootstrap snapshot file.

**Implementation**: Add explicit GO statements between entity scripts in bootstrap generation:

```csharp
foreach (var script in scripts)
{
    cancellationToken.ThrowIfCancellationRequested();

    builder.AppendLine(script.Script.TrimEnd());
    builder.AppendLine();
    builder.AppendLine("GO");  // ‚Üê DEFENSIVE: Ensure transaction boundary
    builder.AppendLine("-- ===== Entity boundary =====");
    builder.AppendLine();
}
```

**Rationale**: Even though each script ends with GO, an explicit boundary ensures previous entity's data is fully committed before next entity begins.

#### Measure 3: Diagnostic PRINT Statements for Bootstrap Execution

**Purpose**: Enable operators to verify bootstrap snapshot execution order and completion.

```csharp
private string BuildMergeScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] ‚úì Completed MERGE for {definition.Schema}.{definition.PhysicalName} (static entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}

private string BuildInsertScript(...)
{
    // ... existing code ...

    builder.AppendLine($"PRINT '[M1.0] ‚úì Completed INSERT for {definition.Schema}.{definition.PhysicalName} (regular entity, {rows.Length} rows)';");
    builder.AppendLine("GO");

    return builder.ToString();
}
```

**Benefit**: LoadHarness output will show exactly which entities completed before FK violation occurs.

#### Measure 4: FK Constraint State Validation (Optional Enhancement)

**Purpose**: Verify FK constraints exist and are enabled before bootstrap snapshot execution.

```sql
-- Query sys.foreign_keys to list all FK constraints
-- Verify is_disabled = 0 (enabled)
-- Verify is_not_trusted = 0 (trusted, checks existing data)
-- Log any disabled or untrusted FKs as warnings
```

**Benefit**: Catches scenarios where FKs are created WITH NOCHECK or disabled, which would mask ordering issues.

#### Measure 5: Topological Position Comments in Bootstrap Snapshot

**Purpose**: Document topological position and dependencies in bootstrap snapshot for debugging.

```sql
--------------------------------------------------------------------------------
-- Entity: User (dbo.OSSYS_USER)
-- Topological Order: 15 of 87
-- Dependencies: Role (14), Department (12)  -- ‚Üê Shows parent positions
-- Dependents: AuditLog (23), Session (31)  -- ‚Üê Shows child positions
--------------------------------------------------------------------------------
```

**Benefit**: Easy visual verification that scripts are in correct order during debugging.

---

## Codebase Integration Guide

### Existing Infrastructure (Leverage These)

‚úÖ **FK-Aware Topological Sorting** - Already Implemented
- **File**: `src/Osm.Emission/Seeds/EntityDependencySorter.cs` (967 lines)
- **Method**: `EntityDependencySorter.SortByForeignKeys()` (lines 24-200+)
- **Algorithm**: Kahn's algorithm with cycle detection
- **Status**: Complete - reuse as-is for M1.0
- **Usage**: Already used in `BuildSsdtStaticSeedStep.cs` (line 82)

‚úÖ **Junction Table Classification** - Already Implemented
- **File**: `src/Osm.Emission/Seeds/JunctionTableClassifier.cs` (lines 616-782 in EntityDependencySorter.cs)
- **Status**: Complete - deferral logic exists

‚úÖ **FK Preflight Validation** - Already Implemented
- **File**: `src/Osm.Emission/Seeds/StaticSeedForeignKeyPreflight.cs` (217 lines)
- **Status**: Complete - detects orphan FKs and ordering violations

‚úÖ **MERGE Script Generation** - Assumed Implemented
- **File**: `src/Osm.Emission/Seeds/StaticSeedSqlBuilder.cs`
- **Status**: Used by StaticSeedStep - may need extension for observability (GO statements, PRINT)

‚úÖ **Pipeline Orchestration Pattern** - Established
- **File**: `src/Osm.Pipeline/Orchestration/BuildSsdtPipeline.cs` (180 lines)
- **Pattern**: Constructor injection + `.BindAsync()` chaining
- **Chain**: Lines 77-86 show step sequence

‚úÖ **Manifest Tracking** - Already Supports Artifacts
- **File**: `src/Osm.Pipeline/Runtime/FullExportRunManifest.cs`
- **Properties**: `DynamicArtifacts`, `StaticSeedArtifacts` (lines 20-21)
- **Status**: Ready for M1.1 verification framework

### Required Changes

#### Change 1: Add Bootstrap Snapshot Step

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtBootstrapSnapshotStep.cs` (NEW)

**Pattern**: Follow `BuildSsdtStaticSeedStep.cs` as template
- Implements: `IBuildSsdtStep<DynamicInsertsGenerated, BootstrapSnapshotGenerated>`
- Input state: `DynamicInsertsGenerated` (after dynamic inserts step)
- Output state: `BootstrapSnapshotGenerated` (add to `BuildSsdtPipelineStates.cs`)

**Key Implementation Details**:
```csharp
// 1. Combine static + dynamic entities
var staticEntities = state.StaticSeedData ?? ImmutableArray<StaticEntityTableData>.Empty;
var dynamicEntities = state.Request.DynamicDataset?.Tables ?? ImmutableArray<StaticEntityTableData>.Empty;
var allEntities = staticEntities.Concat(dynamicEntities).ToImmutableArray();

// 2. Global topological sort (reuse existing sorter)
var ordering = EntityDependencySorter.SortByForeignKeys(
    allEntities,
    state.Bootstrap.FilteredModel,
    state.Request.Scope.SmoOptions.NamingOverrides,
    state.Request.DeferJunctionTables
        ? new EntityDependencySortOptions(true)
        : EntityDependencySortOptions.Default);

// 3. Generate MERGE script with observability
// See "Required Change 3" below if StaticSeedSqlBuilder needs extension

// 4. Write to Bootstrap directory
var bootstrapDir = Path.Combine(state.Request.OutputDirectory, "Bootstrap");
Directory.CreateDirectory(bootstrapDir);
var bootstrapPath = Path.Combine(bootstrapDir, "AllEntitiesIncludingStatic.bootstrap.sql");
```

**Dependencies**:
- May need to create `BootstrapScriptGenerator` if `StaticSeedSqlBuilder` doesn't support:
  - GO statements between entities
  - PRINT diagnostics
  - Topological position comments

#### Change 2: Add PostDeployment Template Step

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtPostDeploymentTemplateStep.cs` (NEW)

**Pattern**: Simple step, no external dependencies
- Implements: `IBuildSsdtStep<BootstrapSnapshotGenerated, PostDeploymentTemplateGenerated>`
- Reads: `state.StaticSeedScriptPaths` to determine single-file vs per-module
- Writes: `PostDeployment-Bootstrap.sql` at output root

**Template Generation**:
```csharp
// Guard logic uses first static table as sentinel
var canonicalTable = state.StaticSeedData.FirstOrDefault()?.Definition;
builder.AppendLine($"IF NOT EXISTS (SELECT 1 FROM [{canonicalTable.Schema}].[{canonicalTable.PhysicalName}])");
builder.AppendLine("BEGIN");
builder.AppendLine("    :r Bootstrap\\AllEntitiesIncludingStatic.bootstrap.sql");
builder.AppendLine("END");

// Baseline seeds (dynamic based on emission mode)
if (state.StaticSeedScriptPaths.Length == 1)
    builder.AppendLine(":r BaselineSeeds\\StaticEntities.seed.sql");
else
    // Per-module mode: multiple :r statements
```

#### Change 3: Extend StaticSeedSqlBuilder or Create BootstrapScriptGenerator

**Decision Point**: Does `StaticSeedSqlBuilder` support observability additions?

**Option A** (if YES): Extend existing builder
- **File**: `src/Osm.Emission/Seeds/StaticSeedSqlBuilder.cs`
- **Add parameter**: `bool includeObservability` to `WriteAsync()` method
- **Changes**: Add GO, PRINT, and comments when flag is true

**Option B** (if NO): Create new builder
- **File**: `src/Osm.Emission/Seeds/BootstrapScriptGenerator.cs` (NEW)
- **Delegates**: Calls `StaticSeedSqlBuilder` for MERGE generation
- **Wraps**: Adds observability around each MERGE statement

**Observability Format**:
```csharp
foreach (var table in orderedTables)
{
    builder.AppendLine($"-- Entity: {table.Definition.LogicalName} ({table.Definition.Schema}.{table.Definition.PhysicalName})");
    builder.AppendLine($"-- Topological Order: {position + 1} of {orderedTables.Length}");
    builder.AppendLine();

    // Generate MERGE (delegate to StaticSeedSqlBuilder)
    var mergeScript = GenerateMergeStatement(table, model);
    builder.AppendLine(mergeScript);

    builder.AppendLine($"PRINT '[M1.0] ‚úì Completed MERGE for {table.Definition.Schema}.{table.Definition.PhysicalName} ({table.Rows.Length} rows)';");
    builder.AppendLine("GO");
    builder.AppendLine();
}
```

#### Change 4: Update Pipeline Orchestration

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtPipeline.cs`

**Constructor Addition** (after line 24):
```csharp
private readonly BuildSsdtBootstrapSnapshotStep _bootstrapSnapshotStep;
private readonly BuildSsdtPostDeploymentTemplateStep _postDeploymentTemplateStep;
```

**Constructor Parameters** (after line 36):
```csharp
BuildSsdtBootstrapSnapshotStep bootstrapSnapshotStep,
BuildSsdtPostDeploymentTemplateStep postDeploymentTemplateStep,
```

**Pipeline Chain** (insert between lines 85-86):
```csharp
.BindAsync((seeds, token) => _dynamicInsertStep.ExecuteAsync(seeds, token), cancellationToken)
.BindAsync((dynamicInserts, token) => _bootstrapSnapshotStep.ExecuteAsync(dynamicInserts, token), cancellationToken)    // ‚Üê NEW
.BindAsync((bootstrapSnapshot, token) => _postDeploymentTemplateStep.ExecuteAsync(bootstrapSnapshot, token), cancellationToken)    // ‚Üê NEW
.BindAsync((postDeployment, token) => _telemetryPackagingStep.ExecuteAsync(postDeployment, token), cancellationToken)
```

**Note**: `_telemetryPackagingStep` must be updated to accept `PostDeploymentTemplateGenerated` state (or make it accept final state generically)

#### Change 5: Add Pipeline State Records

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtPipelineStates.cs`

**Add Two New Records**:
```csharp
public sealed record BootstrapSnapshotGenerated(
    BuildSsdtPipelineRequest Request,
    PipelineExecutionLogBuilder Log,
    PipelineBootstrapResult Bootstrap,
    EvidenceCache? EvidenceCache,
    PolicyDecisionCollection Decisions,
    EmissionReport Report,
    OpportunityReport Opportunities,
    ValidationReport Validations,
    GlobalInsightsReport Insights,
    SsdtManifest Manifest,
    string? DecisionLogPath,
    OpportunityArtifacts OpportunityArtifacts,
    string SqlProjectPath,
    ValidationReport SqlValidation,
    ImmutableArray<string> StaticSeedScriptPaths,
    ImmutableArray<StaticEntityTableData> StaticSeedData,
    ImmutableArray<string> DynamicInsertScriptPaths,
    DynamicInsertOutputMode DynamicInsertOutputMode,
    bool StaticSeedTopologicalOrderApplied,
    EntityDependencyOrderingMode StaticSeedOrderingMode,
    bool DynamicInsertTopologicalOrderApplied,
    EntityDependencyOrderingMode DynamicInsertOrderingMode,
    // NEW FIELDS:
    string BootstrapSnapshotPath,
    EntityDependencyOrderingResult BootstrapOrdering
) : DynamicInsertsGenerated(/* pass through all fields */);

public sealed record PostDeploymentTemplateGenerated(
    // ... same fields as BootstrapSnapshotGenerated ...
    string PostDeploymentTemplatePath
) : BootstrapSnapshotGenerated(/* pass through all fields */);
```

#### Change 6: Rename Seeds Directory

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtStaticSeedStep.cs` (line 96)

**Change**:
```csharp
// OLD
seedsRoot = Path.Combine(state.Request.OutputDirectory, "Seeds");

// NEW
seedsRoot = Path.Combine(state.Request.OutputDirectory, "BaselineSeeds");
```

**File**: Update gitignore patterns (if Seeds/ is gitignored, update to BaselineSeeds/)

#### Change 7: DI Registration

**File**: Find where services are registered (likely `Program.cs` or `ServiceCollectionExtensions.cs`)

**Add Registrations**:
```csharp
services.AddTransient<BuildSsdtBootstrapSnapshotStep>();
services.AddTransient<BuildSsdtPostDeploymentTemplateStep>();
// If creating new builder:
services.AddTransient<BootstrapScriptGenerator>();
```

### Testing Infrastructure

**Existing Test Pattern** - Follow This
- **File**: `tests/Osm.Emission.Tests/EntityDependencySorterTests.cs`
- **Pattern**: Uses mock `EntityModel` and `StaticEntityTableData`
- **Fixtures**: Create test entities with FK relationships

**New Test Files to Create**:
1. `tests/Osm.Pipeline.Tests/Orchestration/BuildSsdtBootstrapSnapshotStepTests.cs`
   - Test: Combines static + dynamic entities
   - Test: Topological ordering applied
   - Test: Observability included in output
   - Test: Directory created at correct path

2. `tests/Osm.Pipeline.Tests/Orchestration/BuildSsdtPostDeploymentTemplateStepTests.cs`
   - Test: Guard logic uses correct sentinel table
   - Test: Single-file mode emits one `:r` statement
   - Test: Per-module mode emits multiple `:r` statements
   - Test: Relative paths use backslashes

**Integration Test** (optional for MVP):
- Full pipeline test: verify bootstrap snapshot and PostDeployment template generated
- Verify SQL syntax valid (can parse but don't need to execute)

### Critical Questions to Resolve Before Implementation

1. **StaticSeedSqlBuilder Capabilities**:
   - ‚ùì Does it already support GO statements between entities?
   - ‚ùì Does it have hooks for adding PRINT diagnostics?
   - ‚ùì Can we add observability via parameters or need new builder?

2. **TelemetryPackagingStep State**:
   - ‚ùì Does it accept generic final state or specific `DynamicInsertsGenerated`?
   - ‚ùì If specific: Do we need to update it or insert steps differently?

3. **DI Container Location**:
   - ‚ùì Where are `BuildSsdt*Step` services registered?
   - ‚ùì Pattern: `AddTransient`, `AddScoped`, or `AddSingleton`?

4. **Build Environment**:
   - ‚ùì Can `dotnet build` run successfully now (NuGet restore fixed)?
   - ‚ùì What branch should implementation go on?

### File Location Quick Reference

**Existing Files to Modify**:
```
src/Osm.Pipeline/Orchestration/
  ‚îú‚îÄ BuildSsdtPipeline.cs (lines 24, 36, 85-86)
  ‚îú‚îÄ BuildSsdtPipelineStates.cs (add 2 new records)
  ‚îî‚îÄ BuildSsdtStaticSeedStep.cs (line 96: rename directory)

??? (DI registration file - need to locate)
  ‚îî‚îÄ Add step registrations
```

**New Files to Create**:
```
src/Osm.Pipeline/Orchestration/
  ‚îú‚îÄ BuildSsdtBootstrapSnapshotStep.cs (NEW)
  ‚îî‚îÄ BuildSsdtPostDeploymentTemplateStep.cs (NEW)

src/Osm.Emission/Seeds/
  ‚îî‚îÄ BootstrapScriptGenerator.cs (NEW - if needed)

tests/Osm.Pipeline.Tests/Orchestration/
  ‚îú‚îÄ BuildSsdtBootstrapSnapshotStepTests.cs (NEW)
  ‚îî‚îÄ BuildSsdtPostDeploymentTemplateStepTests.cs (NEW)
```

---

## Implementation Priority

### üî¥ M1.0 MVP (Ship This Week)

**Tasks**:
1. Create `BuildSsdtBootstrapSnapshotStep.cs`
   - Combine static + regular entities
   - Call existing `EntityDependencySorter.SortByForeignKeys()`
   - Generate MERGE script for all entities
   - **Add GO statements between entities** (transaction boundaries)
   - **Add PRINT diagnostics** for execution progress
   - **Add topological position comments** in generated scripts
   - Write to `Bootstrap/AllEntitiesIncludingStatic.bootstrap.sql`

2. Create `BuildSsdtPostDeploymentTemplateStep.cs`
   - Guard logic: `IF NOT EXISTS (SELECT 1 FROM [canonical_static_table])`
   - Bootstrap include: `:r Bootstrap\AllEntitiesIncludingStatic.bootstrap.sql`
   - Baseline seeds includes (single-file or per-module)
   - Write to `PostDeployment-Bootstrap.sql`

3. Update directory structure
   - Rename `Seeds/` ‚Üí `BaselineSeeds/`
   - Create `Bootstrap/` directory
   - Mark Bootstrap/ as gitignored

4. Integration tests
   - Test bootstrap generation
   - Test PostDeployment template generation
   - Test guard logic detection
   - Verify observability output (PRINT statements, comments)

**Acceptance Criteria**:
- ‚úÖ `osm full-export` generates Bootstrap/ and PostDeployment-Bootstrap.sql
- ‚úÖ User can copy PostDeployment-Bootstrap.sql into SSDT project
- ‚úÖ First deployment applies bootstrap snapshot successfully
- ‚úÖ Subsequent deployments skip bootstrap, apply baseline seeds
- ‚úÖ No FK violations during SSDT deployment
- ‚úÖ Bootstrap snapshot includes GO statements, PRINT diagnostics, topological comments
- ‚úÖ Operators can verify execution order from SSDT output

---

### üü° M1.5 (Next Sprint)
**Per-Table Emission for Production**
- Add `EmitPerTableSeeds` configuration option
- Implement per-table emission in `BuildSsdtStaticSeedStep.cs`
- Update PostDeployment template to handle per-table mode
- Tests for per-table emission

---

## Summary

### Files Emitted by M1.0

| File | Purpose | Version Control | Used When |
|------|---------|----------------|-----------|
| `AllEntitiesIncludingStatic.bootstrap.sql` | Complete dataset (300 entities) topologically sorted | ‚ùå Gitignored | First deployment only |
| `PostDeployment-Bootstrap.sql` | SSDT PostDeployment template with guard + includes | ‚úÖ Copy to SSDT once | Every deployment (guard skips bootstrap after first) |
| `StaticEntities.seed.sql` or per-table files | Baseline seeds (100 static entities) | ‚úÖ Committed | Every deployment (idempotent) |

### Why This Solves the Problem

**Original Issue**: Static seed files ordered alphabetically by module ‚Üí cross-module FK violations

**M1.0 Solution**:
1. **First deployment uses bootstrap snapshot** (global topological order, no module partitioning) ‚Üí FK dependencies satisfied
2. **Subsequent deployments use baseline seeds** (data already exists from bootstrap, MERGE is idempotent) ‚Üí order doesn't matter
3. **Module ordering becomes irrelevant** ‚Üí baseline seeds can be organized however is convenient for developers

**Conclusion**: M1.0 solves the FK constraint violation problem by:
1. **Bootstrap Snapshot**: First deployment uses global topological order (correct)
2. **Baseline Seeds**: Ongoing deployments use idempotent MERGE (order irrelevant)
3. **Clean Separation**: Administrative efficiency (bootstrap) vs. developer-maintained (baseline seeds)
