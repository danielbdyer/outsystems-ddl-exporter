# M1.0 Codebase Reality Check

**Date**: 2025-11-18
**Status**: CRITICAL FINDINGS - M1.0 specification may be redundant

## Executive Summary

**The M1.0 proposal to add topological sorting for FK dependencies is MOSTLY ALREADY IMPLEMENTED in the codebase.** This document reconciles the M1.0 specification with actual codebase findings and identifies the TRUE gap to address.

## What M1.0 Proposed

M1.0 proposed to solve FK constraint violations during static seed loading by:
1. Building a global dependency graph for all entities
2. Using Kahn's algorithm for topological sorting
3. Enriching with SMO metadata to capture manually-added FKs
4. Handling cycles gracefully with detection and fallback
5. Emitting entities in FK-safe order (parents before children)

## What the Codebase ALREADY Has

### âœ… 1. Comprehensive FK-Aware Topological Sorting

**File**: `src/Osm.Emission/Seeds/EntityDependencySorter.cs` (967 lines)

**Key Components**:
- **Lines 24-157**: `SortByForeignKeys()` - Main entry point for FK-aware sorting
- **Lines 264-302**: Kahn's algorithm implementation (BFS with in-degree tracking)
- **Lines 159-262**: `BuildDependencyGraph()` - Extracts FK relationships from OutSystems model
- **Lines 122-156**: Cycle detection with alphabetical fallback

**Example Usage**:
```csharp
var ordering = EntityDependencySorter.SortByForeignKeys(tables, model);
var ordered = ordering.Tables;
var cycleDetected = ordering.CycleDetected;
var topologicalOrderApplied = ordering.TopologicalOrderingApplied;
```

### âœ… 2. Static Seed Topological Sorting

**File**: `src/Osm.Emission/Seeds/StaticEntitySeedScriptGenerator.cs`

**Lines 48-49**:
```csharp
var ordering = EntityDependencySorter.SortByForeignKeys(tables, model);
var ordered = ordering.Tables;
```

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtStaticSeedStep.cs`

**Lines 82-86**:
```csharp
var ordering = EntityDependencySorter.SortByForeignKeys(
    deterministicData,
    model,
    state.Request.Scope.SmoOptions.NamingOverrides,
    sortOptions);
```

**Static seeds ARE topologically sorted before emission!**

### âœ… 3. Dynamic Data Topological Sorting

**File**: `src/Osm.Emission/DynamicEntityInsertGenerator.cs`

**Lines 92-94**:
```csharp
var orderedTables = EntityDependencySorter
    .SortByForeignKeys(dataset.Tables, model, namingOverrides, sortOptions)
    .Tables;
```

**Lines 633-675**: `ApplyDependencyOrdering()` - Re-orders final scripts topologically

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtDynamicInsertStep.cs`

**Lines 87-91**:
```csharp
var ordering = EntityDependencySorter.SortByForeignKeys(
    dataset.Tables,
    state.Bootstrap.FilteredModel,
    namingOverrides,
    sortOptions);
```

**Dynamic data IS topologically sorted before emission!**

### âœ… 4. Cycle Detection with Fallback

**File**: `src/Osm.Emission/Seeds/EntityDependencySorter.cs`

**Lines 122-139**:
```csharp
var ordered = TopologicalSort(nodes, edges, indegree, comparer, classification);
var cycleDetected = ordered.Length != nodes.Count;
var fallbackApplied = false;

if (cycleDetected)
{
    // Cycles detected. Append remaining nodes using the alphabetical fallback
    var remainingKeys = nodes.Keys
        .Where(key => ordered.All(table => !TableKey.Equals(table.Definition, key)))
        .ToArray();

    if (remainingKeys.Length > 0)
    {
        var fallback = SortAlphabetically(remainingKeys.Select(key => nodes[key]).ToImmutableArray());
        ordered = ordered.AddRange(fallback);
        fallbackApplied = true;
    }
}
```

**System handles cycles by appending unordered nodes alphabetically!**

### âœ… 5. Junction Table Prioritization

**File**: `src/Osm.Emission/Seeds/EntityDependencySorter.cs`

**Lines 616-782**: `JunctionTableClassifier` - Identifies many-to-many junction tables and defers them to end of ordering

**This ensures parent tables load before junction tables!**

### âœ… 6. Self-Referencing FK Ordering

**File**: `src/Osm.Emission/DynamicEntityInsertGenerator.cs`

**Lines 152-169**: `OrderRows()` - Handles self-referencing FKs (e.g., Employee.ManagerId â†’ Employee.Id)
**Lines 273-405**: `ApplySelfReferencingOrdering()` - Kahn's algorithm at the ROW level

**Example**: User table with ManagerId FK to User.Id - rows are ordered so managers are inserted before their subordinates!

### âœ… 7. FK Preflight Validation

**File**: `src/Osm.Emission/Seeds/StaticSeedForeignKeyPreflight.cs`

**Lines 11-122**: `Analyze()` - Validates FK ordering and detects:
- **MissingParent**: FK references to tables not in the set
- **ParentAfterChild**: Ordering violations (parent emitted after child)

**This is a diagnostic tool already in the codebase!**

### âœ… 8. LoadHarness Trusts Manifest Order

**File**: `src/Osm.LoadHarness/LoadHarnessRunner.cs`

**Lines 169-206**: `BuildScriptQueue()` - Builds execution queue from options
**Lines 76-87**: Executes scripts in the order provided (no re-sorting!)

```csharp
foreach (var item in scripts)
{
    var result = await ExecuteScriptAsync(
            connection,
            item.Category,
            item.Path,
            options.CommandTimeoutSeconds,
            cancellationToken)
        .ConfigureAwait(false);

    results.Add(result);
}
```

**LoadHarness does NOT re-sort scripts - it executes them in manifest order!**

### âœ… 9. Extensive Telemetry

**File**: `src/Osm.Pipeline/Orchestration/BuildSsdtStaticSeedStep.cs`

**Lines 158-172**: Logs ordering diagnostics
```csharp
.WithCount("ordering.nodes", ordering.NodeCount)
.WithCount("ordering.edges", ordering.EdgeCount)
.WithCount("ordering.missingEdges", ordering.MissingEdgeCount)
.WithValue("ordering.cycleDetected", ordering.CycleDetected ? "true" : "false")
.WithValue("ordering.fallbackApplied", ordering.AlphabeticalFallbackApplied ? "true" : "false")
.WithValue("ordering.mode", ordering.Mode.ToMetadataValue())
```

**The system already logs topological ordering diagnostics!**

## What the Codebase DOES NOT Have

### âŒ 1. SMO Enrichment

**Gap**: The system uses **model-based FK extraction** only. It does NOT query `sys.foreign_keys` to capture manually-added FKs that aren't in the OutSystems model.

**Evidence**: `EntityDependencySorter.BuildDependencyGraph()` (lines 159-262) extracts FKs from:
```csharp
foreach (var relationship in entity.Relationships)
{
    foreach (var constraint in relationship.ActualConstraints)
    {
        // ... build edges from model metadata ...
    }
}
```

**No SMO queries for runtime FK metadata!**

**Impact**: If a developer manually adds a FK constraint via SSDT or SQL script (not through OutSystems), the topological sort will miss it and may emit in wrong order.

### âŒ 2. Global Ordering Across Static + Dynamic

**Gap**: Static seeds and dynamic data are **sorted separately**, not as a unified global graph.

**Evidence**:
- `BuildSsdtStaticSeedStep.cs` (lines 82-86): Sorts static entities
- `BuildSsdtDynamicInsertStep.cs` (lines 87-91): Sorts dynamic entities separately
- No code that merges both sets into a single dependency graph

**Potential Issue**:
- If a static entity (e.g., `User`) has FK to a regular entity (e.g., `Department`)
- Static seeds are emitted first, then dynamic data
- Result: `User` (static) inserted before `Department` (dynamic) â†’ **FK violation!**

**Current Workflow**:
1. Static seeds: Topologically sorted within static entities
2. Dynamic data: Topologically sorted within regular entities
3. Execution: All static first, then all dynamic

**Desired Workflow (per M1.0)**:
1. Build ONE graph: ALL entities (static + regular)
2. Topologically sort the combined set
3. Emit in unified order

### âŒ 3. Module-Based Partitioning May Break Global Order

**Gap**: Static seeds can be grouped by module into separate files, and modules are ordered **alphabetically**, not topologically.

**Evidence**: `BuildSsdtStaticSeedStep.cs` (lines 102-137)

```csharp
if (seedOptions.GroupByModule)
{
    var modules = orderedData
        .Select(table => table.Definition.Module)
        .Distinct(StringComparer.OrdinalIgnoreCase)
        .OrderBy(name => name, StringComparer.OrdinalIgnoreCase)  // â† ALPHABETICAL!
        .ToArray();

    foreach (var moduleName in modules)
    {
        var moduleTables = orderedData
            .Where(table => string.Equals(table.Definition.Module, moduleName, StringComparison.OrdinalIgnoreCase))
            .ToArray();

        var modulePath = Path.Combine(moduleDirectory, "StaticEntities.seed.sql");
        await _seedGenerator.WriteAsync(modulePath, moduleTables, ...);
        seedPathBuilder.Add(modulePath);  // â† Files added in alphabetical module order!
    }
}
```

**Potential Issue**:
- `orderedData` is globally topologically sorted (line 87)
- But when partitioned by module, each module becomes a separate file
- Files are added to manifest in **alphabetical module order**
- If ModuleA contains `User` (depends on `Role` from ModuleB)
- Alphabetical module order: ModuleA before ModuleB â†’ FK violation!

**Mitigation**: The `moduleTables` filter preserves the original topological order from `orderedData`, so within each file the order is correct. But the FILE ordering may be wrong.

**Note**: This only matters if `GroupByModule` is enabled. If all static seeds are in one file, the order is correct.

## Architecture Comparison

### Current System

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Static Entities                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ EntityDependencySorter.SortByForeignKeys()         â”‚  â”‚
â”‚  â”‚  - Model-based FK extraction                       â”‚  â”‚
â”‚  â”‚  - Kahn's algorithm                                â”‚  â”‚
â”‚  â”‚  - Cycle detection â†’ alphabetical fallback         â”‚  â”‚
â”‚  â”‚  - Junction table deferral                         â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â”‚  Output: StaticEntities.seed.sql (or per-module files)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Dynamic Entities                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ EntityDependencySorter.SortByForeignKeys()         â”‚  â”‚
â”‚  â”‚  - Model-based FK extraction                       â”‚  â”‚
â”‚  â”‚  - Kahn's algorithm                                â”‚  â”‚
â”‚  â”‚  - Cycle detection â†’ alphabetical fallback         â”‚  â”‚
â”‚  â”‚  - Self-referencing row ordering                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â”‚  Output: DynamicData/*.dynamic.sql                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LoadHarness Execution Order:
  1. Safe
  2. Remediation
  3. StaticSeeds (all static seed files in manifest order)
  4. Dynamic (all dynamic files in manifest order)
```

### M1.0 Proposed (May Not Be Needed!)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ALL Entities (Static + Regular)                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ GlobalTopologicalOrderingService                   â”‚  â”‚
â”‚  â”‚  - Model-based FK extraction                       â”‚  â”‚
â”‚  â”‚  - SMO enrichment (sys.foreign_keys query) â† NEW!  â”‚  â”‚
â”‚  â”‚  - Kahn's algorithm (already exists!)              â”‚  â”‚
â”‚  â”‚  - Cycle detection (already exists!)               â”‚  â”‚
â”‚  â”‚  - Unified ordering across static + dynamic â† NEW! â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â”‚  Output: Ordered scripts (static + dynamic mixed)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

LoadHarness Execution Order:
  1. Safe
  2. Remediation
  3. All data scripts in global topological order
```

## TRUE Gap Analysis

| Feature | M1.0 Proposed | Current Reality | Gap |
|---------|---------------|-----------------|-----|
| FK dependency graph | âœ… Yes | âœ… **Already exists** | None |
| Kahn's algorithm | âœ… Yes | âœ… **Already exists** | None |
| Cycle detection | âœ… Yes | âœ… **Already exists** | None |
| Alphabetical fallback | âœ… Yes | âœ… **Already exists** | None |
| Junction table deferral | âœ… Yes | âœ… **Already exists** | None |
| Self-referencing FK | âœ… Yes | âœ… **Already exists** | None |
| Static seed topological sort | âœ… Yes | âœ… **Already exists** | None |
| Dynamic data topological sort | âœ… Yes | âœ… **Already exists** | None |
| LoadHarness trusts manifest | âœ… Yes | âœ… **Already exists** | None |
| FK preflight validation | âœ… Yes | âœ… **Already exists** | None |
| Ordering telemetry | âœ… Yes | âœ… **Already exists** | None |
| **SMO enrichment** | âœ… Yes | âŒ **NOT implemented** | **HIGH** |
| **Global static + dynamic ordering** | âœ… Yes | âŒ **Separate sorting** | **CRITICAL** |
| **Module file order awareness** | Not in M1.0 | âŒ **Alphabetical** | **MEDIUM** |

## Actual Problem to Solve

Based on codebase analysis, the REAL issues are:

### Issue 1: Cross-Boundary FK Dependencies (CRITICAL)

**Problem**: Static and dynamic entities are sorted separately, so cross-boundary FKs can violate execution order.

**Example**:
- Static entity `User` has FK to regular entity `Department`
- Current order: Static first (`User`), then dynamic (`Department`) â†’ FK violation!

**Solution**: Build unified dependency graph for ALL entities (static + regular), sort globally, emit in mixed order.

### Issue 2: SMO Enrichment Missing (HIGH)

**Problem**: Manual FKs added via SSDT/SQL (not in OutSystems model) are invisible to topological sort.

**Example**:
- Developer adds FK via SSDT: `ALTER TABLE User ADD CONSTRAINT FK_User_Role FOREIGN KEY (RoleId) REFERENCES Role(Id)`
- OutSystems model doesn't know about this FK
- Topological sort misses the dependency

**Solution**: Query `sys.foreign_keys` after model-based extraction, add missing edges to graph.

### Issue 3: Module-Based File Partitioning (MEDIUM)

**Problem**: When `GroupByModule=true`, static seeds split into multiple files ordered alphabetically by module name, potentially breaking global topological order.

**Example**:
- ModuleA: `User` (depends on `Role`)
- ModuleB: `Role`
- Alphabetical module order: A before B
- Result: `User` file before `Role` file â†’ FK violation!

**Solution**: Either:
- Option A: Don't partition by module (single file maintains topological order)
- Option B: Order modules topologically (compute module dependency graph)
- Option C: Emit cross-module dependency warnings in preflight

## Recommendations

### ğŸ”´ STOP - Do Not Implement M1.0 As Written

**The M1.0 specification proposes building infrastructure that ALREADY EXISTS.** Implementing M1.0 as written would create duplicate code.

### âœ… INSTEAD - Implement Targeted Fixes

#### Fix 1: Global Ordering Across Static + Dynamic

**Objective**: Merge static and dynamic entities into a single topological sort.

**Changes Required**:
1. Modify `BuildSsdtStaticSeedStep` and `BuildSsdtDynamicInsertStep` to share dependency graph
2. Create `GlobalEntityOrdering` service that:
   - Accepts both static and dynamic entities
   - Builds unified dependency graph
   - Sorts globally
   - Returns partitioned results (static subset, dynamic subset) preserving global order
3. Update emission to respect global order (may require interleaving static and dynamic files)

**Estimated Effort**: 2-3 days

**Files to Modify**:
- `src/Osm.Pipeline/Orchestration/BuildSsdtStaticSeedStep.cs`
- `src/Osm.Pipeline/Orchestration/BuildSsdtDynamicInsertStep.cs`
- NEW: `src/Osm.Emission/Seeds/GlobalEntityOrderingService.cs`

#### Fix 2: Add SMO Enrichment

**Objective**: Query `sys.foreign_keys` to capture manually-added FKs not in OutSystems model.

**Changes Required**:
1. Add `EnrichWithSmoMetadataAsync()` method to `EntityDependencySorter`
2. Query:
```sql
SELECT
    OBJECT_SCHEMA_NAME(parent_object_id) AS ChildSchema,
    OBJECT_NAME(parent_object_id) AS ChildTable,
    OBJECT_SCHEMA_NAME(referenced_object_id) AS ParentSchema,
    OBJECT_NAME(referenced_object_id) AS ParentTable,
    name AS ConstraintName
FROM sys.foreign_keys
WHERE is_disabled = 0
```
3. Add edges to dependency graph for FKs not already present from model
4. Add timeout (30s) and warning logging if SMO query fails

**Estimated Effort**: 1-2 days

**Files to Modify**:
- `src/Osm.Emission/Seeds/EntityDependencySorter.cs`
- Tests: `tests/Osm.Emission.Tests/EntityDependencySorterTests.cs`

#### Fix 3: Module Ordering Awareness

**Objective**: Detect when module partitioning breaks global topological order.

**Changes Required**:
1. Add preflight check in `BuildSsdtStaticSeedStep` when `GroupByModule=true`
2. Compute module dependency graph (module A depends on module B if any entity in A has FK to entity in B)
3. If module alphabetical order != module topological order â†’ **WARN** (don't fail)
4. Log warning with details of cross-module FKs that may violate order

**Estimated Effort**: 1 day

**Files to Modify**:
- `src/Osm.Pipeline/Orchestration/BuildSsdtStaticSeedStep.cs`
- Tests: Add module ordering violation test case

## Open Questions for User

1. **Is cross-boundary FK dependency (static â†” dynamic) actually occurring in production?**
   - If not, Fix 1 may not be needed
   - Can be validated by analyzing production schemas

2. **Are manual FKs (not in OutSystems model) common?**
   - If not, Fix 2 may be low priority
   - Can be validated by comparing model FK count to `sys.foreign_keys` count

3. **Is `GroupByModule` enabled in production exports?**
   - If not, Fix 3 is not needed
   - Check configuration/CLI defaults

4. **What is the ACTUAL failure scenario the user observed?**
   - Need concrete example: which tables, which FK, which error message
   - This will confirm which of the 3 issues is the real problem

## Next Steps

1. **Validate** with user: Which of the 3 issues is the actual problem?
2. **Search** codebase for existing FK violation errors/logs
3. **Analyze** production schemas to confirm cross-boundary dependencies exist
4. **Implement** targeted fixes (NOT full M1.0 specification)
5. **Test** with real OutSystems applications

---

**Conclusion**: The M1.0 specification is 80% redundant. The codebase already has sophisticated FK-aware topological sorting. The TRUE gaps are:
1. SMO enrichment (manual FKs)
2. Global ordering across static + dynamic
3. Module partitioning order awareness

We should implement targeted fixes for these specific gaps rather than building parallel infrastructure.
