# M1.3: Data Integrity Checks (MVP)

**Date**: 2025-11-18
**Status**: READY FOR IMPLEMENTATION
**Dependencies**: M1.0 (Global Topological Ordering), M1.1 (Export Verification Framework)
**Priority**: üü° Ship after M1.0+M1.1+M1.2, provides basic data verification

## Executive Summary

This specification defines **minimal data integrity checks** to verify basic correctness after loading data from bootstrap snapshot or baseline seeds. Unlike M1.8 (DMM replacement), M1.3 focuses on quick sanity checks with minimal overhead.

**MVP Scope**:
1. ‚úÖ Row count verification (source vs target)
2. ‚úÖ Basic NULL count checks on nullable columns
3. ‚úÖ Simple logging of discrepancies
4. ‚ùå NOT full hash comparison (deferred to M1.8)
5. ‚ùå NOT comprehensive data type validation (deferred to M1.8)
6. ‚ùå NOT DMM replacement (deferred to M1.8)

**Key Difference from M1.8**:
- M1.3 = **Quick sanity checks** (row counts, basic NULL verification)
- M1.8 = **Comprehensive validation** (hash comparison, type checking, DMM replacement)

---

## Problem Statement

### Current State (After M1.0)

M1.0 generates bootstrap snapshot with data, but:
- No verification that data actually loaded correctly
- Silent data loss possible (e.g., row truncation, NULL handling bugs)
- Operators discover issues only through manual inspection or production failures
- No quick feedback on data correctness

### Desired State (M1.3 MVP)

- **Quick row count check**: Verify source and target have same number of rows per table
- **NULL preservation check**: Verify NULL counts match for nullable columns
- **Fast execution**: < 1 second for typical datasets (~100k rows)
- **Actionable warnings**: Log discrepancies without failing export
- **Optional verification**: Can be skipped for performance-critical exports

---

## Architecture

### Component Overview

```
LoadHarness (applies bootstrap snapshot or baseline seeds)
  ‚Üì data loaded
Target Database (logical names)
  ‚Üì verify against
Source Database (physical names)
  ‚Üì using (NEW)
BasicDataIntegrityChecker
  ‚Üì performs
  1. Row count comparison (per table)
  2. NULL count comparison (per nullable column)
  ‚Üì logs
IntegrityCheckResult { Passed, Warnings }
```

### Data Models

#### BasicIntegrityCheckResult

```csharp
public sealed record BasicIntegrityCheckResult(
    bool Passed,
    ImmutableArray<IntegrityWarning> Warnings,
    int TablesChecked,
    int RowCountMatches,
    int NullCountMatches);

public sealed record IntegrityWarning(
    string TableName,
    string ColumnName,
    string WarningType, // "RowCountMismatch", "NullCountMismatch"
    long ExpectedValue,
    long ActualValue,
    string Message);
```

---

## Implementation Details

### 1. Create BasicDataIntegrityChecker

**File**: `src/Osm.Pipeline/Orchestration/BasicDataIntegrityChecker.cs`

```csharp
using System.Collections.Immutable;
using System.Data;
using Microsoft.Data.SqlClient;
using Osm.Domain.Abstractions;

namespace Osm.Pipeline.Orchestration;

public sealed class BasicDataIntegrityChecker
{
    public async Task<BasicIntegrityCheckResult> CheckAsync(
        string sourceConnectionString,
        string targetConnectionString,
        ImmutableArray<StaticEntityTableData> tables,
        FilteredOsmModel model,
        NamingOverrideOptions namingOverrides,
        CancellationToken cancellationToken = default)
    {
        var warnings = ImmutableArray.CreateBuilder<IntegrityWarning>();
        var rowCountMatches = 0;
        var nullCountMatches = 0;

        foreach (var table in tables)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var entity = model.TryGetEntityByPhysicalName(table.Definition.PhysicalName);
            if (entity is null)
            {
                continue;
            }

            var sourceTableName = table.Definition.PhysicalName;
            var targetTableName = namingOverrides.ApplyToTableName(
                entity.LogicalTableName ?? entity.PhysicalTableName);

            // 1. Row count check
            var sourceRowCount = await GetRowCountAsync(sourceConnectionString, sourceTableName, cancellationToken);
            var targetRowCount = await GetRowCountAsync(targetConnectionString, targetTableName, cancellationToken);

            if (sourceRowCount != targetRowCount)
            {
                warnings.Add(new IntegrityWarning(
                    TableName: sourceTableName,
                    ColumnName: "<row count>",
                    WarningType: "RowCountMismatch",
                    ExpectedValue: sourceRowCount,
                    ActualValue: targetRowCount,
                    Message: $"Row count mismatch: expected {sourceRowCount}, got {targetRowCount}"));
            }
            else
            {
                rowCountMatches++;
            }

            // 2. NULL count checks (only for nullable columns)
            foreach (var attribute in entity.Attributes.Where(a => a.IsNullable))
            {
                var sourceColName = attribute.PhysicalColumnName;
                var targetColName = namingOverrides.ApplyToColumnName(
                    attribute.LogicalColumnName ?? attribute.PhysicalColumnName);

                var sourceNullCount = await GetNullCountAsync(
                    sourceConnectionString,
                    sourceTableName,
                    sourceColName,
                    cancellationToken);

                var targetNullCount = await GetNullCountAsync(
                    targetConnectionString,
                    targetTableName,
                    targetColName,
                    cancellationToken);

                if (sourceNullCount != targetNullCount)
                {
                    warnings.Add(new IntegrityWarning(
                        TableName: sourceTableName,
                        ColumnName: sourceColName,
                        WarningType: "NullCountMismatch",
                        ExpectedValue: sourceNullCount,
                        ActualValue: targetNullCount,
                        Message: $"NULL count mismatch on {sourceColName}: expected {sourceNullCount}, got {targetNullCount}"));
                }
                else
                {
                    nullCountMatches++;
                }
            }
        }

        return new BasicIntegrityCheckResult(
            Passed: warnings.Count == 0,
            Warnings: warnings.ToImmutable(),
            TablesChecked: tables.Length,
            RowCountMatches: rowCountMatches,
            NullCountMatches: nullCountMatches);
    }

    private static async Task<long> GetRowCountAsync(
        string connectionString,
        string tableName,
        CancellationToken cancellationToken)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = $"SELECT COUNT_BIG(*) FROM [{tableName}]";
        command.CommandType = CommandType.Text;

        var result = await command.ExecuteScalarAsync(cancellationToken);
        return result is long count ? count : 0;
    }

    private static async Task<long> GetNullCountAsync(
        string connectionString,
        string tableName,
        string columnName,
        CancellationToken cancellationToken)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = $"SELECT COUNT_BIG(*) FROM [{tableName}] WHERE [{columnName}] IS NULL";
        command.CommandType = CommandType.Text;

        var result = await command.ExecuteScalarAsync(cancellationToken);
        return result is long count ? count : 0;
    }
}
```

### 2. Optional Integration into LoadHarness

**Option 1: Manual Verification** (Recommended for M1.3)

Operators run verification separately after LoadHarness completes:

```bash
# 1. Run LoadHarness (applies bootstrap snapshot)
osm load-harness \
  --manifest ./MyApp/manifest.json \
  --target-connection "Server=localhost;Database=MyApp_Target;..." \
  --apply-bootstrap

# 2. Run basic integrity check (NEW)
osm verify-data \
  --manifest ./MyApp/manifest.json \
  --source-connection "Server=localhost;Database=MyApp_Source;..." \
  --target-connection "Server=localhost;Database=MyApp_Target;..."
```

**Option 2: Integrated into LoadHarness** (Future Enhancement)

```csharp
// After LoadHarness completes all scripts
if (options.VerifyDataIntegrity)
{
    var checker = new BasicDataIntegrityChecker();
    var result = await checker.CheckAsync(
        options.SourceConnectionString,
        options.TargetConnectionString,
        manifest.StaticEntities,
        model,
        namingOverrides,
        cancellationToken);

    log.Record(
        "loadHarness.dataIntegrity.checked",
        $"Data integrity check: {result.TablesChecked} tables, {result.Warnings.Length} warnings",
        new PipelineLogMetadataBuilder()
            .WithCount("tablesChecked", result.TablesChecked)
            .WithCount("rowCountMatches", result.RowCountMatches)
            .WithCount("nullCountMatches", result.NullCountMatches)
            .WithCount("warnings", result.Warnings.Length)
            .WithValue("passed", result.Passed ? "true" : "false")
            .Build());

    if (!result.Passed)
    {
        foreach (var warning in result.Warnings.Take(10))
        {
            log.Record(
                "loadHarness.dataIntegrity.warning",
                warning.Message);
        }
    }
}
```

### 3. Create CLI Command (Option 1)

**File**: `src/Osm.Cli/Commands/VerifyDataCommand.cs`

```csharp
using System.CommandLine;
using Osm.Pipeline.Orchestration;

namespace Osm.Cli.Commands;

public sealed class VerifyDataCommand : Command
{
    public VerifyDataCommand() : base("verify-data", "Quick data integrity checks (row counts, NULL counts)")
    {
        var manifestOption = new Option<string>(
            "--manifest",
            "Path to manifest.json");

        var sourceConnectionOption = new Option<string>(
            "--source-connection",
            "Source database connection string");

        var targetConnectionOption = new Option<string>(
            "--target-connection",
            "Target database connection string");

        AddOption(manifestOption);
        AddOption(sourceConnectionOption);
        AddOption(targetConnectionOption);

        this.SetHandler(
            ExecuteAsync,
            manifestOption,
            sourceConnectionOption,
            targetConnectionOption);
    }

    private static async Task<int> ExecuteAsync(
        string manifestPath,
        string sourceConnection,
        string targetConnection)
    {
        // Load manifest
        var manifest = await LoadManifestAsync(manifestPath);

        // Run checks
        var checker = new BasicDataIntegrityChecker();
        var result = await checker.CheckAsync(
            sourceConnection,
            targetConnection,
            manifest.StaticEntities,
            manifest.Model,
            manifest.NamingOverrides);

        // Display results
        Console.WriteLine($"‚úì Checked {result.TablesChecked} tables");
        Console.WriteLine($"  Row count matches: {result.RowCountMatches}");
        Console.WriteLine($"  NULL count matches: {result.NullCountMatches}");
        Console.WriteLine($"  Warnings: {result.Warnings.Length}");
        Console.WriteLine();

        if (!result.Passed)
        {
            Console.WriteLine("‚ö† Data integrity warnings detected:");
            foreach (var warning in result.Warnings)
            {
                Console.WriteLine($"  - {warning.Message}");
            }
            return 1; // Exit code 1 = warnings detected
        }

        Console.WriteLine("‚úì All checks passed");
        return 0;
    }
}
```

---

## Integration Points

### M1.0 Bootstrap Snapshot
- Verification runs AFTER bootstrap snapshot is applied
- Compares source (OutSystems DB) vs target (SSDT deployment)

### M1.1 Export Verification
- Verification results logged to execution log
- Warnings included in manifest metadata (if integrated)

### M1.8 Full Integrity Verification (Future)
- M1.8 extends M1.3 with hash comparison, type checking
- M1.3 = quick sanity check
- M1.8 = comprehensive DMM replacement

---

## Test Scenarios

### Test 1: Matching Row Counts
```csharp
[Fact]
public async Task CheckAsync_MatchingRowCounts_ReturnsSuccess()
{
    // Arrange: Source and target both have 100 rows
    var source = CreateDatabase("Source", rowCount: 100);
    var target = CreateDatabase("Target", rowCount: 100);

    // Act
    var result = await checker.CheckAsync(source, target, tables, model, namingOverrides);

    // Assert
    Assert.True(result.Passed);
    Assert.Empty(result.Warnings);
    Assert.Equal(1, result.RowCountMatches);
}
```

### Test 2: Row Count Mismatch
```csharp
[Fact]
public async Task CheckAsync_RowCountMismatch_ReturnsWarning()
{
    // Arrange: Source has 100 rows, target has 95 rows
    var source = CreateDatabase("Source", rowCount: 100);
    var target = CreateDatabase("Target", rowCount: 95);

    // Act
    var result = await checker.CheckAsync(source, target, tables, model, namingOverrides);

    // Assert
    Assert.False(result.Passed);
    Assert.Single(result.Warnings);
    Assert.Equal("RowCountMismatch", result.Warnings[0].WarningType);
    Assert.Equal(100, result.Warnings[0].ExpectedValue);
    Assert.Equal(95, result.Warnings[0].ActualValue);
}
```

### Test 3: NULL Count Mismatch
```csharp
[Fact]
public async Task CheckAsync_NullCountMismatch_ReturnsWarning()
{
    // Arrange: Source has 10 NULLs, target has 5 NULLs
    var source = CreateDatabase("Source", nullCount: 10);
    var target = CreateDatabase("Target", nullCount: 5);

    // Act
    var result = await checker.CheckAsync(source, target, tables, model, namingOverrides);

    // Assert
    Assert.False(result.Passed);
    Assert.Single(result.Warnings);
    Assert.Equal("NullCountMismatch", result.Warnings[0].WarningType);
}
```

---

## Success Criteria

1. ‚úÖ Row count verification works for all tables
2. ‚úÖ NULL count verification works for all nullable columns
3. ‚úÖ Warnings logged for discrepancies, not errors
4. ‚úÖ Verification completes in < 1 second for typical datasets
5. ‚úÖ CLI command provides operator-friendly output
6. ‚úÖ All existing tests pass
7. ‚úÖ New verification tests cover matching/mismatching counts

---

## Performance Considerations

**M1.3 is designed for speed**:
- Only COUNT queries (no full table scans for hash comparison)
- No data type validation (quick metadata checks only)
- Can be run in parallel for multiple tables
- Typical execution time: < 1 second for 100 tables with 100k rows each

**Deferred to M1.8** (expensive operations):
- HASHBYTES(SHA2_256) on all rows (full table scan)
- Data type conversion detection (requires sys.columns joins)
- Comprehensive NULL preservation checks (all columns)

---

## Migration Path

**M1.3 is optional**:
- No changes to M1.0 bootstrap generation
- No changes to LoadHarness (unless integrated)
- Operators can run verification manually via CLI
- If verification passes (expected), behavior unchanged

**Future M1.8 Enhancement**:
- M1.8 replaces M1.3 with comprehensive validation
- M1.3 can remain as "quick check" option for performance-critical exports
- M1.8 = full DMM replacement (hash comparison, type checking)

---

## Summary

**M1.3 MVP provides quick sanity checks**:
1. Catches obvious data loss (row count mismatches)
2. Verifies NULL preservation (nullable columns)
3. Minimal overhead (COUNT queries only)
4. Actionable operator feedback (warnings, not errors)

**Deferred to M1.8** (comprehensive validation):
- Hash comparison (byte-identical verification)
- Data type conversion detection
- Comprehensive NULL preservation checks
- DMM replacement goal
