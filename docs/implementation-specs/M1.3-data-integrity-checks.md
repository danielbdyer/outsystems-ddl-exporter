# M1.3: Data Integrity Checks (MVP)

**Date**: 2025-11-18
**Status**: IMPLEMENTED
**Dependencies**: M1.0 (Global Topological Ordering), M1.1 (Export Verification Framework)
**Priority**: ðŸŸ¡ Ship after M1.0+M1.1+M1.2, provides basic data verification

## Executive Summary

### The Specific Problem

After LoadHarness applies bootstrap snapshot or baseline seeds to the target database, **there is no quick sanity check to verify data loaded correctly**. This creates risks:

- **Silent Data Loss**: Rows may be missing due to constraint violations, script errors, or transaction rollbacks without detection
- **NULL Handling Bugs**: Data loading code may incorrectly transform NULLs to default values or vice versa
- **No Quick Feedback**: Operators must wait for comprehensive M1.8 validation or discover issues in production
- **Manual Inspection**: Operators run ad-hoc row count queries to verify loading succeeded

**Example**: LoadHarness script fails halfway through due to constraint violation, loads 50 of 100 tables. Operator doesn't notice, deploys partial data â†’ production failures.

### Recommended Solution

**Basic Data Integrity Checks**

Implement lightweight post-load verification that runs immediately after LoadHarness completes (or after a manual apply when the harness is skipped):

1. **Row Count Verification**: Compare source vs. target row counts for each table
2. **NULL Count Checks**: Verify NULL counts match for nullable columns (detects NULL transformation bugs)
3. **Fast Execution**: Complete in <1 second for typical datasets (~100k rows total)
4. **Warning-Level Logging**: Log discrepancies without failing deployment (allows investigation)

This provides quick confidence that data loaded correctly, with minimal overhead.

### How It Fixes the Problem

1. **Immediate Feedback**: Catches data loss within seconds of load completion
2. **NULL Bug Detection**: Identifies incorrect NULL handling (common source of data corruption)
3. **Fast**: No expensive hash computation, just simple COUNT queries
4. **Actionable**: Shows specific tables/columns with mismatches

### Alternative Approaches Considered

**Alternative 1: No Validation (Trust LoadHarness)**
- Assume LoadHarness always succeeds, skip verification
- **Rejected**: Risky (constraint violations, script errors), silent data loss possible

**Alternative 2: Full Hash Comparison (M1.8)**
- Compute cryptographic hashes for byte-level comparison
- **Rejected**: Too slow for quick sanity check (M1.8 provides this later)

**Alternative 3: Sample-Based Validation**
- Check only a subset of rows (e.g., first 100 per table)
- **Rejected**: May miss data loss in unsampled portions, row counts are just as fast

**Alternative 4: Schema-Only Validation**
- Verify tables exist, skip data validation
- **Rejected**: Doesn't catch data loss, which is the primary failure mode

**Alternative 5: Application-Level Validation**
- Rely on application to detect missing data
- **Rejected**: Fails too late (in production), wastes deployment time

**Why Basic Integrity Checks Win**: Fast (<1s), catches 90% of data loading failures, minimal code, doesn't block deployment, enables quick iteration.

**MVP Scope**:
1. âœ… Row count verification (source vs target)
2. âœ… Basic NULL count checks on nullable columns
3. âœ… Simple logging of discrepancies
4. âŒ NOT full hash comparison (deferred to M1.8)
5. âŒ NOT comprehensive data type validation (deferred to M1.8)
6. âŒ NOT DMM replacement (deferred to M1.8)

**Key Difference from M1.8**:
- M1.3 = **Quick sanity checks** (row counts, basic NULL verification)
- M1.8 = **Comprehensive validation** (hash comparison, type checking, DMM replacement)

### Implementation notes (2025-11-20)
- Implemented `BasicDataIntegrityChecker` + `SqlDataIntegrityQueryExecutor` to compare source/target row counts and nullable column NULL counts using the filtered model and naming overrides.
- Added the `verify-data` CLI command to run the checks standalone and emit `data-integrity-verification.json`; see `docs/verbs/verify-data.md` for usage, including manual apply flows when the load harness is not used.
- The verification stage remains warning-only to keep base checks lightweight; load harness replay is still optional and documented for operators who prefer automated apply + verify cycles.

---

## Problem Statement

### Current State (After M1.0)

M1.0 generates bootstrap snapshot with data, but:
- No verification that data actually loaded correctly
- Silent data loss possible (e.g., row truncation, NULL handling bugs)
- Operators discover issues only through manual inspection or production failures
- No quick feedback on data correctness

### Desired State (M1.3 MVP)

- **Quick row count check**: Verify source and target have same number of rows per table
- **NULL preservation check**: Verify NULL counts match for nullable columns
- **Fast execution**: < 1 second for typical datasets (~100k rows)
- **Actionable warnings**: Log discrepancies without failing export
- **Optional verification**: Can be skipped for performance-critical exports

---

## Architecture

### Component Overview

```
LoadHarness (applies bootstrap snapshot or baseline seeds)
  â†“ data loaded
Target Database (logical names)
  â†“ verify against
Source Database (physical names)
  â†“ using (NEW)
BasicDataIntegrityChecker
  â†“ performs
  1. Row count comparison (per table)
  2. NULL count comparison (per nullable column)
  â†“ logs
IntegrityCheckResult { Passed, Warnings }
```

### Data Models

#### BasicIntegrityCheckResult

```csharp
public sealed record BasicIntegrityCheckResult(
    bool Passed,
    ImmutableArray<IntegrityWarning> Warnings,
    int TablesChecked,
    int RowCountMatches,
    int NullCountMatches);

public sealed record IntegrityWarning(
    string TableName,
    string ColumnName,
    string WarningType, // "RowCountMismatch", "NullCountMismatch"
    long ExpectedValue,
    long ActualValue,
    string Message);
```

---

## Implementation Details

### 1. Create BasicDataIntegrityChecker

**File**: `src/Osm.Pipeline/Orchestration/BasicDataIntegrityChecker.cs`

```csharp
using System.Collections.Immutable;
using System.Data;
using Microsoft.Data.SqlClient;
using Osm.Domain.Abstractions;

namespace Osm.Pipeline.Orchestration;

public sealed class BasicDataIntegrityChecker
{
    public async Task<BasicIntegrityCheckResult> CheckAsync(
        string sourceConnectionString,
        string targetConnectionString,
        ImmutableArray<StaticEntityTableData> tables,
        FilteredOsmModel model,
        NamingOverrideOptions namingOverrides,
        CancellationToken cancellationToken = default)
    {
        var warnings = ImmutableArray.CreateBuilder<IntegrityWarning>();
        var rowCountMatches = 0;
        var nullCountMatches = 0;

        foreach (var table in tables)
        {
            cancellationToken.ThrowIfCancellationRequested();

            var entity = model.TryGetEntityByPhysicalName(table.Definition.PhysicalName);
            if (entity is null)
            {
                continue;
            }

            var sourceTableName = table.Definition.PhysicalName;
            var targetTableName = namingOverrides.ApplyToTableName(
                entity.LogicalTableName ?? entity.PhysicalTableName);

            // 1. Row count check
            var sourceRowCount = await GetRowCountAsync(sourceConnectionString, sourceTableName, cancellationToken);
            var targetRowCount = await GetRowCountAsync(targetConnectionString, targetTableName, cancellationToken);

            if (sourceRowCount != targetRowCount)
            {
                warnings.Add(new IntegrityWarning(
                    TableName: sourceTableName,
                    ColumnName: "<row count>",
                    WarningType: "RowCountMismatch",
                    ExpectedValue: sourceRowCount,
                    ActualValue: targetRowCount,
                    Message: $"Row count mismatch: expected {sourceRowCount}, got {targetRowCount}"));
            }
            else
            {
                rowCountMatches++;
            }

            // 2. NULL count checks (only for nullable columns)
            foreach (var attribute in entity.Attributes.Where(a => a.IsNullable))
            {
                var sourceColName = attribute.PhysicalColumnName;
                var targetColName = namingOverrides.ApplyToColumnName(
                    attribute.LogicalColumnName ?? attribute.PhysicalColumnName);

                var sourceNullCount = await GetNullCountAsync(
                    sourceConnectionString,
                    sourceTableName,
                    sourceColName,
                    cancellationToken);

                var targetNullCount = await GetNullCountAsync(
                    targetConnectionString,
                    targetTableName,
                    targetColName,
                    cancellationToken);

                if (sourceNullCount != targetNullCount)
                {
                    warnings.Add(new IntegrityWarning(
                        TableName: sourceTableName,
                        ColumnName: sourceColName,
                        WarningType: "NullCountMismatch",
                        ExpectedValue: sourceNullCount,
                        ActualValue: targetNullCount,
                        Message: $"NULL count mismatch on {sourceColName}: expected {sourceNullCount}, got {targetNullCount}"));
                }
                else
                {
                    nullCountMatches++;
                }
            }
        }

        return new BasicIntegrityCheckResult(
            Passed: warnings.Count == 0,
            Warnings: warnings.ToImmutable(),
            TablesChecked: tables.Length,
            RowCountMatches: rowCountMatches,
            NullCountMatches: nullCountMatches);
    }

    private static async Task<long> GetRowCountAsync(
        string connectionString,
        string tableName,
        CancellationToken cancellationToken)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = $"SELECT COUNT_BIG(*) FROM [{tableName}]";
        command.CommandType = CommandType.Text;

        var result = await command.ExecuteScalarAsync(cancellationToken);
        return result is long count ? count : 0;
    }

    private static async Task<long> GetNullCountAsync(
        string connectionString,
        string tableName,
        string columnName,
        CancellationToken cancellationToken)
    {
        await using var connection = new SqlConnection(connectionString);
        await connection.OpenAsync(cancellationToken);

        await using var command = connection.CreateCommand();
        command.CommandText = $"SELECT COUNT_BIG(*) FROM [{tableName}] WHERE [{columnName}] IS NULL";
        command.CommandType = CommandType.Text;

        var result = await command.ExecuteScalarAsync(cancellationToken);
        return result is long count ? count : 0;
    }
}
```

### 2. Optional Integration into LoadHarness

**Option 1: Manual Verification** (Recommended for M1.3)

Operators run verification separately after LoadHarness completes:

```bash
# 1. Run LoadHarness (applies bootstrap snapshot)
osm load-harness \
  --manifest ./MyApp/manifest.json \
  --target-connection "Server=localhost;Database=MyApp_Target;..." \
  --apply-bootstrap

# 2. Run basic integrity check (NEW)
osm verify-data \
  --manifest ./MyApp/manifest.json \
  --source-connection "Server=localhost;Database=MyApp_Source;..." \
  --target-connection "Server=localhost;Database=MyApp_Target;..."
```

**Option 2: Integrated into LoadHarness** (Future Enhancement)

```csharp
// After LoadHarness completes all scripts
if (options.VerifyDataIntegrity)
{
    var checker = new BasicDataIntegrityChecker();
    var result = await checker.CheckAsync(
        options.SourceConnectionString,
        options.TargetConnectionString,
        manifest.StaticEntities,
        model,
        namingOverrides,
        cancellationToken);

    log.Record(
        "loadHarness.dataIntegrity.checked",
        $"Data integrity check: {result.TablesChecked} tables, {result.Warnings.Length} warnings",
        new PipelineLogMetadataBuilder()
            .WithCount("tablesChecked", result.TablesChecked)
            .WithCount("rowCountMatches", result.RowCountMatches)
            .WithCount("nullCountMatches", result.NullCountMatches)
            .WithCount("warnings", result.Warnings.Length)
            .WithValue("passed", result.Passed ? "true" : "false")
            .Build());

    if (!result.Passed)
    {
        foreach (var warning in result.Warnings.Take(10))
        {
            log.Record(
                "loadHarness.dataIntegrity.warning",
                warning.Message);
        }
    }
}
```

### 3. Create CLI Command (Option 1)

**File**: `src/Osm.Cli/Commands/VerifyDataCommand.cs`

```csharp
using System.CommandLine;
using Osm.Pipeline.Orchestration;

namespace Osm.Cli.Commands;

public sealed class VerifyDataCommand : Command
{
    public VerifyDataCommand() : base("verify-data", "Quick data integrity checks (row counts, NULL counts)")
    {
        var manifestOption = new Option<string>(
            "--manifest",
            "Path to manifest.json");

        var sourceConnectionOption = new Option<string>(
            "--source-connection",
            "Source database connection string");

        var targetConnectionOption = new Option<string>(
            "--target-connection",
            "Target database connection string");

        AddOption(manifestOption);
        AddOption(sourceConnectionOption);
        AddOption(targetConnectionOption);

        this.SetHandler(
            ExecuteAsync,
            manifestOption,
            sourceConnectionOption,
            targetConnectionOption);
    }

    private static async Task<int> ExecuteAsync(
        string manifestPath,
        string sourceConnection,
        string targetConnection)
    {
        // Load manifest
        var manifest = await LoadManifestAsync(manifestPath);

        // Run checks
        var checker = new BasicDataIntegrityChecker();
        var result = await checker.CheckAsync(
            sourceConnection,
            targetConnection,
            manifest.StaticEntities,
            manifest.Model,
            manifest.NamingOverrides);

        // Display results
        Console.WriteLine($"âœ“ Checked {result.TablesChecked} tables");
        Console.WriteLine($"  Row count matches: {result.RowCountMatches}");
        Console.WriteLine($"  NULL count matches: {result.NullCountMatches}");
        Console.WriteLine($"  Warnings: {result.Warnings.Length}");
        Console.WriteLine();

        if (!result.Passed)
        {
            Console.WriteLine("âš  Data integrity warnings detected:");
            foreach (var warning in result.Warnings)
            {
                Console.WriteLine($"  - {warning.Message}");
            }
            return 1; // Exit code 1 = warnings detected
        }

        Console.WriteLine("âœ“ All checks passed");
        return 0;
    }
}
```

---

## Integration Points

### M1.0 Bootstrap Snapshot
- Verification runs AFTER bootstrap snapshot is applied
- Compares source (OutSystems DB) vs target (SSDT deployment)

### M1.1 Export Verification
- Verification results logged to execution log
- Warnings included in manifest metadata (if integrated)

### M1.8 Full Integrity Verification (Future)
- M1.8 extends M1.3 with hash comparison, type checking
- M1.3 = quick sanity check
- M1.8 = comprehensive DMM replacement

---

## Test Scenarios

### Test 1: Matching Row Counts
```csharp
[Fact]
public async Task CheckAsync_MatchingRowCounts_ReturnsSuccess()
{
    // Arrange: Source and target both have 100 rows
    var source = CreateDatabase("Source", rowCount: 100);
    var target = CreateDatabase("Target", rowCount: 100);

    // Act
    var result = await checker.CheckAsync(source, target, tables, model, namingOverrides);

    // Assert
    Assert.True(result.Passed);
    Assert.Empty(result.Warnings);
    Assert.Equal(1, result.RowCountMatches);
}
```

### Test 2: Row Count Mismatch
```csharp
[Fact]
public async Task CheckAsync_RowCountMismatch_ReturnsWarning()
{
    // Arrange: Source has 100 rows, target has 95 rows
    var source = CreateDatabase("Source", rowCount: 100);
    var target = CreateDatabase("Target", rowCount: 95);

    // Act
    var result = await checker.CheckAsync(source, target, tables, model, namingOverrides);

    // Assert
    Assert.False(result.Passed);
    Assert.Single(result.Warnings);
    Assert.Equal("RowCountMismatch", result.Warnings[0].WarningType);
    Assert.Equal(100, result.Warnings[0].ExpectedValue);
    Assert.Equal(95, result.Warnings[0].ActualValue);
}
```

### Test 3: NULL Count Mismatch
```csharp
[Fact]
public async Task CheckAsync_NullCountMismatch_ReturnsWarning()
{
    // Arrange: Source has 10 NULLs, target has 5 NULLs
    var source = CreateDatabase("Source", nullCount: 10);
    var target = CreateDatabase("Target", nullCount: 5);

    // Act
    var result = await checker.CheckAsync(source, target, tables, model, namingOverrides);

    // Assert
    Assert.False(result.Passed);
    Assert.Single(result.Warnings);
    Assert.Equal("NullCountMismatch", result.Warnings[0].WarningType);
}
```

---

## Success Criteria

1. âœ… Row count verification works for all tables
2. âœ… NULL count verification works for all nullable columns
3. âœ… Warnings logged for discrepancies, not errors
4. âœ… Verification completes in < 1 second for typical datasets
5. âœ… CLI command provides operator-friendly output
6. âœ… All existing tests pass
7. âœ… New verification tests cover matching/mismatching counts

---

## Performance Considerations

**M1.3 is designed for speed**:
- Only COUNT queries (no full table scans for hash comparison)
- No data type validation (quick metadata checks only)
- Can be run in parallel for multiple tables
- Typical execution time: < 1 second for 100 tables with 100k rows each

**Deferred to M1.8** (expensive operations):
- HASHBYTES(SHA2_256) on all rows (full table scan)
- Data type conversion detection (requires sys.columns joins)
- Comprehensive NULL preservation checks (all columns)

---

## Migration Path

**M1.3 is optional**:
- No changes to M1.0 bootstrap generation
- No changes to LoadHarness (unless integrated)
- Operators can run verification manually via CLI
- If verification passes (expected), behavior unchanged

**Future M1.8 Enhancement**:
- M1.8 replaces M1.3 with comprehensive validation
- M1.3 can remain as "quick check" option for performance-critical exports
- M1.8 = full DMM replacement (hash comparison, type checking)

---

## Summary

**M1.3 MVP provides quick sanity checks**:
1. Catches obvious data loss (row count mismatches)
2. Verifies NULL preservation (nullable columns)
3. Minimal overhead (COUNT queries only)
4. Actionable operator feedback (warnings, not errors)

**Deferred to M1.8** (comprehensive validation):
- Hash comparison (byte-identical verification)
- Data type conversion detection
- Comprehensive NULL preservation checks
- DMM replacement goal
