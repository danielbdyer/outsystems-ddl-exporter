# M1.0 Global Topological Ordering - Red Team Analysis

**Date**: 2025-11-18
**Status**: Pre-Implementation Risk Assessment
**Purpose**: Defensive analysis of proposed topological ordering refactoring

---

## Executive Summary

**Proposal**: Refactor static seed and dynamic data emission to use a single global topological sort based on FK dependencies, replacing current alphabetical ordering.

**Criticality**: **HIGH RISK** - This touches core emission logic used by every export operation.

**Recommendation**: Proceed with extreme caution. Implement in phases with extensive testing and rollback capability.

---

## 1. Core Assumptions to Challenge

### 1.1 Assumption: "Model.ForeignKeys contains all FK relationships"

**Risk**: What if the model extraction misses some FKs?

**Evidence to Check**:
```csharp
// src/Osm.Domain/Model/EntityModel.cs
public ImmutableArray<ForeignKeyModel> ForeignKeys { get; init; }
```

**Questions**:
1. Does extraction capture ALL SQL Server FKs or only OutSystems-managed ones?
2. What about FKs added manually by DBAs outside OutSystems?
3. Are disabled FKs captured?
4. Are cross-module FKs captured?

**Mitigation**: Proposed SMO enrichment (query `sys.foreign_keys` directly) addresses this, but adds DB dependency.

### 1.2 Assumption: "FK graph is always acyclic or cycles are rare"

**Risk**: Production databases MAY have circular dependencies (self-referencing tables, mutual FK chains).

**Real-World Example**:
```sql
-- User.ManagerId → User.Id (self-reference)
-- Department.HeadUserId → User.Id
-- User.DepartmentId → Department.Id
-- Cycle: User → Department → User
```

**Current Spec Handling**: Fallback to alphabetical ordering within cycle group + warnings.

**Questions**:
1. Is alphabetical ordering safe for cycles? (NO - FK violations still possible)
2. Should we use deferrable constraints for cycle resolution? (Requires DDL changes)
3. Should we use SET IDENTITY_INSERT for cycles? (Complex, error-prone)
4. Can we detect cycles BEFORE emission and abort? (Safer failure mode)

**Recommendation**: Don't emit data for cyclic dependencies. Fail loudly. Force user to fix schema design.

### 1.3 Assumption: "Static entities are a subset of all entities"

**Risk**: What if static/dynamic distinction changes in OutSystems platform evolution?

**Evidence**: `EntityModel.IsStatic` property exists today, but is it stable?

**Questions**:
1. Can an entity change from static to dynamic (or vice versa) between exports?
2. What happens to existing static seed files if entity becomes dynamic?
3. Are there "hybrid" entities (partial static data + partial dynamic)?

**Mitigation**: Version the emission strategy in manifest metadata.

---

## 2. Integration Point Risks

### 2.1 Static Seed Emitter Changes

**Current Code** (assumed structure):
```csharp
// src/Osm.Emission/StaticEntitySeedScriptGenerator.cs
foreach (var entity in staticEntities.OrderBy(e => e.Name))
{
    await EmitScriptAsync(entity, outputRoot);
}
```

**Proposed Change**:
```csharp
foreach (var entityNode in orderedStaticEntities) // Pre-sorted by M1.0
{
    await EmitScriptAsync(entity, outputRoot);
}
```

**CRITICAL QUESTIONS**:

1. **What if emitter logic DEPENDS on alphabetical ordering?**
   - Example: File naming conventions assume alphabetical order
   - Example: Directory structure created during iteration
   - Example: Manifest artifact references assume specific order

2. **What if emitter has side effects during iteration?**
   - Example: Accumulates state between entity emissions
   - Example: Writes to shared file (consolidated seed)
   - Example: Updates progress tracker

3. **What if there are MULTIPLE static seed emitters?**
   - Example: Separate emitters for different profiles
   - Example: UAT-users has its own static seed logic
   - Action: **GREP FOR ALL USAGES** before changing interface

**Action Items**:
- [ ] Search codebase for `IsStatic` references
- [ ] Find ALL static seed emission code paths
- [ ] Verify no hidden ordering assumptions
- [ ] Check if any code COUNTS on alphabetical order for determinism

### 2.2 Dynamic Insert Emitter Changes

**Current Assumption**: Dynamic emitter processes only `!IsStatic` entities.

**Proposed Change**: Dynamic emitter processes **ALL** entities (static + regular), using MERGE for static.

**RISKS**:

1. **MERGE syntax complexity**:
   - Requires identifying primary key column (what if composite PK?)
   - Requires column list in specific order (matches attribute order?)
   - MERGE is SQL Server 2008+ (version dependency)
   - MERGE has known bugs in older SQL Server versions

2. **Idempotency assumptions**:
   - What if static seed file uses IDENTITY_INSERT ON?
   - What if dynamic MERGE tries to insert same identity values?
   - Conflict: Which wins - static seed or dynamic MERGE?

3. **Data type conversions**:
   - Static seeds may have hardcoded values (e.g., `CAST('2024-01-01' AS DATETIME)`)
   - Dynamic MERGE may serialize differently (e.g., `'2024-01-01T00:00:00Z'`)
   - Do these match during MERGE ON clause?

**Action Items**:
- [ ] Test MERGE with IDENTITY columns
- [ ] Test MERGE with composite PKs
- [ ] Test MERGE with computed columns
- [ ] Test MERGE with triggers enabled
- [ ] Verify MERGE doesn't break on NULL PKs

### 2.3 Manifest Changes

**Proposed**: Add `topological-ordering` stage to manifest.

**RISKS**:

1. **Manifest version compatibility**:
   - Old tools reading new manifests (forward compatibility)
   - New tools reading old manifests (backward compatibility)
   - What if ordering stage fails but emission succeeds?

2. **Artifact path references**:
   - Manifest currently has semicolon-separated script paths
   - Does order matter for LoadHarness execution?
   - Does LoadHarness trust manifest order or sort again?

**Action Items**:
- [ ] Check `LoadHarnessRunner.cs` - does it sort scripts or trust manifest order?
- [ ] Verify manifest schema versioning strategy
- [ ] Test old LoadHarness with new manifest format

---

## 3. Edge Cases & Failure Modes

### 3.1 Empty Graphs (No Entities)

**Scenario**: Export with zero entities (fresh OutSystems environment).

**Expected**: Empty ordered list.

**Test**:
```csharp
var graph = new DirectedGraph(); // No nodes
var sorter = new TopologicalSorter();
var result = sorter.Sort(graph);

Assert.Empty(result.OrderedEntities);
Assert.Equal(0, result.Diagnostics.MaxDepth);
```

### 3.2 No-Edge Tables (Isolated Entities)

**Scenario**: Entity with no FKs (neither incoming nor outgoing).

**Examples**: Configuration tables, log tables.

**Proposed Handling**: Add at beginning of ordered list (alphabetically).

**Question**: Is beginning or end safer?
- Beginning: Static config loads first (good)
- End: Transactional data loads last (also good)

**Risk**: If code assumes "first = most important", this breaks semantic meaning.

### 3.3 External Entities

**Scenario**: `EntityModel.IsExternal = true` (references external system).

**Current Proposal**: Skip external entities in graph.

**Question**: What if external entity is referenced by FK from internal entity?

**Example**:
```
Order.CustomerId → ExternalCRM.Customer.Id (external)
```

**Risk**: Graph build fails if target entity not in graph.

**Mitigation**: Silently skip FK edges to external entities (log warning).

### 3.4 Multiple Disconnected Subgraphs

**Scenario**: Entities organized in modules with no cross-module FKs.

```
Module A: Order → Customer → Address
Module B: Product → Category
```

**Expected**: Two independent orderings concatenated.

**Question**: In what order do we concatenate subgraphs?

**Proposed**: Alphabetical by first entity in subgraph (deterministic).

**Risk**: Non-determinism if subgraph detection logic changes.

### 3.5 Large Graphs (Performance)

**Scenario**: 1000+ entities, 5000+ FK edges.

**Kahn's Algorithm Complexity**: O(V + E) where V=entities, E=edges.

**Estimated Time**: ~10ms for 1000 entities (acceptable).

**Risk**: SMO enrichment (SQL query) may be slow for large schemas.

**Mitigation**: Timeout SMO queries after 30 seconds, proceed without enrichment.

### 3.6 Malformed FK Metadata

**Scenario**: FK in model references non-existent target table.

**Example**:
```csharp
FK: OrderItem.ProductId → Product.Id
// But "Product" entity missing from model (deleted? external?)
```

**Current Proposal**: Log warning, skip edge.

**Risk**: Silent failure - FK ordering ignored, potential runtime violation.

**Better Approach**: Fail loudly. Force user to fix model inconsistency.

---

## 4. Backward Compatibility Risks

### 4.1 Existing Static Seed Files

**Scenario**: Production repository has hand-edited static seed files.

**User Workflow**:
1. Generate initial static seeds (alphabetical)
2. Edit `dbo.Role.static.sql` manually (add new roles)
3. Commit to version control
4. Deploy repeatedly

**After M1.0**: New export generates static seeds in **different order** (topological).

**Risks**:
1. Git diffs show massive churn (entire file reordered)
2. Merge conflicts if developer edited middle of file
3. CI/CD assumes static files are stable (caching, signatures)

**Questions**:
1. Can we preserve existing file order for backward compat?
2. Can we emit BOTH orders (old for compatibility, new for correctness)?
3. Should we version the emission strategy (v1=alphabetical, v2=topological)?

**Recommendation**: Emit new files alongside old, deprecate old after 1 release cycle.

### 4.2 LoadHarness Execution Order

**Current Behavior** (assumed):
- LoadHarness executes scripts in manifest order
- OR LoadHarness sorts scripts alphabetically (CHECK THIS!)

**After M1.0**: Manifest order = topological order.

**Risk**: If LoadHarness has its OWN sorting logic, M1.0 ordering is ignored.

**CRITICAL ACTION**: Examine `LoadHarnessRunner.cs` to verify execution order logic.

```csharp
// FIND THIS CODE:
// Does it sort scripts? Or trust manifest order?
foreach (var script in GetScriptsFromManifest(manifest))
{
    await ExecuteScriptAsync(script);
}
```

### 4.3 SSDT Project File Order

**Scenario**: SSDT `.sqlproj` file lists script files in specific order.

**Question**: Does SSDT care about file order in project? (Usually NO, but verify)

**Risk**: If SSDT re-sorts files on load, version control shows churn.

---

## 5. Testing Challenges

### 5.1 How to Test Topological Correctness?

**Approach 1**: Unit test known graph structures.

```csharp
[Fact]
public void LinearChain_OrdersCorrectly()
{
    var graph = BuildGraph("A→B→C");
    var result = sorter.Sort(graph);
    Assert.Equal(["C", "B", "A"], result.OrderedEntities.Select(e => e.TableName));
}
```

**Approach 2**: Property-based testing.

```csharp
[Property]
public void SortedGraph_RespectsAllEdges(DirectedGraph graph)
{
    var result = sorter.Sort(graph);

    // For every edge (A→B), verify B appears before A in result
    foreach (var edge in graph.Edges)
    {
        var sourcePos = result.GetPosition(edge.Source);
        var targetPos = result.GetPosition(edge.Target);
        Assert.True(targetPos < sourcePos, $"{edge.Target} must appear before {edge.Source}");
    }
}
```

**Approach 3**: Integration test with real OutSystems model.

**Challenge**: Need test database with known FK structure.

### 5.2 How to Test Cycle Detection?

**Approach**: Construct cyclic graph, verify fallback behavior.

```csharp
[Fact]
public void CyclicGraph_DetectsCycle()
{
    var graph = BuildGraph("A→B→C→A");
    var result = sorter.Sort(graph);

    Assert.False(result.Success);
    Assert.Single(result.Diagnostics.DetectedCycles);
    Assert.Contains("A", result.Diagnostics.DetectedCycles[0].Entities);
}
```

**Question**: How to verify fallback order is safe?

**Answer**: You CAN'T guarantee safety for cycles. Must abort or use deferrable constraints.

### 5.3 How to Test SMO Enrichment?

**Challenge**: Requires live SQL Server with manually-added FKs.

**Setup**:
1. Run full-export to generate model.json
2. Manually add FK to database: `ALTER TABLE Order ADD CONSTRAINT FK_NewConstraint FOREIGN KEY (CustomerId) REFERENCES Customer(Id)`
3. Re-run topological ordering with SMO enrichment
4. Verify new FK edge appears in graph

**Risk**: Test flakiness (DB state changes between runs).

**Mitigation**: Use transaction-scoped test database.

---

## 6. Failure Scenario: What Could Go Wrong?

### 6.1 Scenario: M1.0 Deploys, LoadHarness Fails

**Steps**:
1. Developer runs full-export with M1.0
2. Static seeds emitted in topological order (Role before User)
3. Dynamic data emitted with MERGE for static entities
4. LoadHarness applies static seeds: SUCCESS
5. LoadHarness applies dynamic data: **FK VIOLATION**

**Root Cause**: Dynamic MERGE ON clause uses wrong column order, fails to match existing static rows.

**Impact**: Production deployment blocked, manual intervention required.

**Rollback**: Revert to old export, apply alphabetical static seeds.

**Prevention**: Extensive integration testing with LoadHarness BEFORE deploying M1.0.

### 6.2 Scenario: Cycle Not Detected, Emission Corrupted

**Steps**:
1. Database has circular FK: User ↔ Department
2. M1.0 topological sort uses alphabetical fallback: Department, User
3. Static seed emission: INSERT INTO Department fails (HeadUserId references User.Id not yet inserted)

**Impact**: Static seed scripts are BROKEN, cannot load into fresh database.

**Rollback**: Difficult - data already emitted incorrectly.

**Prevention**: Detect cycles BEFORE emission, ABORT with clear error message.

### 6.3 Scenario: SMO Enrichment Query Hangs

**Steps**:
1. Source database has 10,000 tables, 50,000 FKs
2. SMO enrichment query on `sys.foreign_keys` takes 5 minutes (blocking locks)
3. Full-export times out, fails mid-pipeline

**Impact**: Export unusable, must re-run.

**Prevention**: Timeout SMO queries (30s), proceed without enrichment, log warning.

---

## 7. Codebase Search - Critical Sections to Review

### 7.1 Files to Examine BEFORE Implementation

```bash
# Find all static seed emission code
rg "IsStatic" --type csharp -A 5

# Find all dynamic insert emission code
rg "DynamicData|dynamic-insert" --type csharp -A 5

# Find LoadHarness script execution order logic
rg "LoadHarness|ExecuteScript" --type csharp -A 10

# Find FK metadata extraction
rg "ForeignKey|sys.foreign_keys" --type csharp -A 5

# Find entity iteration/ordering code
rg "OrderBy.*Entity|Sort.*Entity" --type csharp -A 3
```

### 7.2 Integration Points to Map

1. **Where are static seeds emitted?**
   - `src/Osm.Emission/StaticEntitySeedScriptGenerator.cs` (assumed)
   - Look for iteration over `IsStatic` entities

2. **Where are dynamic inserts emitted?**
   - `src/Osm.Emission/DynamicEntityDataProvider.cs` (assumed)
   - Look for iteration over `!IsStatic` entities

3. **How does LoadHarness execute scripts?**
   - `src/Osm.LoadHarness/LoadHarnessRunner.cs`
   - Check if it sorts or trusts manifest order

4. **Where is manifest created?**
   - `src/Osm.Pipeline/Runtime/FullExportRunManifest.cs`
   - Check if artifact paths are ordered

5. **Where are FKs extracted?**
   - `src/Osm.Pipeline/SqlExtraction/` (likely)
   - Check what SQL queries run to capture FK metadata

---

## 8. Phased Rollout Strategy (Risk Mitigation)

### Phase 0: Research & Validation (1-2 days)

- [ ] Search codebase for ALL static/dynamic emission code paths
- [ ] Verify LoadHarness execution order logic
- [ ] Check for hidden ordering assumptions
- [ ] Map ALL integration points

### Phase 1: Build Graph Infrastructure (2-3 days)

- [ ] Implement `DirectedGraph`, `EntityNode`, `FKEdge` data structures
- [ ] Implement Kahn's algorithm (`TopologicalSorter`)
- [ ] Unit test: linear chains, diamonds, no-edge tables
- [ ] Unit test: cycle detection
- [ ] NO emission changes yet - just graph building

### Phase 2: Add SMO Enrichment (1-2 days)

- [ ] Implement `DependencyGraphBuilder.EnrichWithSMOMetadataAsync()`
- [ ] Add timeout (30s) for SMO queries
- [ ] Test with real OutSystems database
- [ ] Verify manually-added FKs are captured

### Phase 3: Integrate with Pipeline (Non-Breaking) (2-3 days)

- [ ] Call `GlobalTopologicalOrderingService.ComputeOrderingAsync()` in pipeline
- [ ] Add `topological-ordering` stage to manifest
- [ ] Log ordering results (diagnostics) BUT DON'T USE FOR EMISSION YET
- [ ] Compare topological order vs alphabetical order (detect differences)
- [ ] Deploy to dev environment, monitor logs

### Phase 4: Static Seed Emission (Breaking Change) (2-3 days)

- [ ] Modify static seed emitter to accept pre-ordered list
- [ ] Emit TWO versions: `StaticSeeds/v1-alphabetical/` and `StaticSeeds/v2-topological/`
- [ ] Test LoadHarness with both versions
- [ ] Verify v2 loads successfully
- [ ] Deploy to dev, run integration tests

### Phase 5: Dynamic Data Emission (Breaking Change) (3-4 days)

- [ ] Modify dynamic emitter to process ALL entities
- [ ] Implement MERGE logic for static entities (idempotent)
- [ ] Test composite PKs, identity columns, triggers
- [ ] Integration test: Apply dynamic data after static seeds (verify idempotency)
- [ ] Integration test: Apply dynamic data alone (verify completeness)

### Phase 6: Gradual Rollout (2-3 weeks)

- [ ] Deploy to dev: Monitor for issues (1 week)
- [ ] Deploy to staging: Run full UAT-users pipeline (1 week)
- [ ] Deploy to production: Feature flag `--use-topological-ordering=true` (default: false)
- [ ] Monitor production for 1 week
- [ ] Flip feature flag to default: true
- [ ] Remove v1 (alphabetical) emission after 1 release cycle

**Total Estimated Time**: 6-9 days (Phase 0-5) + 2-3 weeks rollout

---

## 9. Abort Criteria (When to Stop)

**RED FLAGS - Stop implementation if**:

1. ❌ **Circular dependencies detected in >10% of production databases**
   - Indicates widespread schema design issues
   - Topological sort cannot fix this - needs deferrable constraints or SET IDENTITY_INSERT

2. ❌ **LoadHarness execution order is NOT based on manifest**
   - If LoadHarness has its own sorting, M1.0 is pointless
   - Must fix LoadHarness first

3. ❌ **Existing static seed files have complex manual edits**
   - If users heavily customize static seeds, reordering breaks workflows
   - Need migration tool or dual-version support

4. ❌ **MERGE idempotency fails in testing**
   - If MERGE cannot safely handle static duplicates, dynamic-only workflow breaks
   - Must use INSERT...WHERE NOT EXISTS or other approach

5. ❌ **SMO enrichment timeout rate >20%**
   - If enrichment frequently fails, graph is incomplete
   - Defeats purpose of M1.0

**YELLOW FLAGS - Proceed with caution if**:

1. ⚠️ **Cycles detected in <10% of databases**
   - Acceptable if we can abort emission with clear error
   - Document cycle resolution strategies

2. ⚠️ **External entity FK references exist**
   - Acceptable if we skip these edges gracefully
   - Log warnings for operator awareness

3. ⚠️ **Large schemas (1000+ entities) slow down sort**
   - Acceptable if <5s for typical exports
   - Optimize if becomes bottleneck

---

## 10. Open Questions for User/Team

1. **What is the CURRENT failure rate of static seed loading due to FK violations?**
   - If low (<1%), M1.0 may be solving a rare problem
   - If high (>10%), M1.0 is critical

2. **Are circular FK dependencies common in OutSystems apps?**
   - Need data from production databases
   - If common, M1.0 needs robust cycle handling (deferrable constraints)

3. **Do users manually edit static seed files?**
   - If yes, reordering causes merge conflicts
   - Need dual-version support or migration tool

4. **Does LoadHarness sort scripts or trust manifest order?**
   - **CRITICAL** - must verify before proceeding

5. **What SQL Server versions are in production?**
   - MERGE requires SQL Server 2008+
   - If older versions exist, need INSERT...WHERE NOT EXISTS fallback

6. **Are there any OutSystems-specific FK constraints we're missing?**
   - Example: Soft FKs (convention-based, not enforced by DB)
   - Need OutSystems domain expert input

---

## 11. Recommendation

**Proceed with M1.0, BUT**:

### ✅ MUST HAVE before implementation:
1. Search codebase, map ALL integration points
2. Verify LoadHarness execution order (trust manifest vs sort)
3. Test MERGE idempotency with real schemas
4. Plan dual-version emission (v1 alphabetical, v2 topological)
5. Add abort logic for circular dependencies (don't emit broken scripts)

### ✅ SHOULD HAVE:
1. Property-based testing for topological sort
2. Integration test with real OutSystems database
3. Feature flag for gradual rollout
4. Monitoring/telemetry for ordering diagnostics

### ✅ NICE TO HAVE:
1. Deferrable constraint generation for cycles
2. Visual graph output (DOT/GraphViz)
3. Ordering diff tool (compare v1 vs v2)

### ❌ RED LINE:
- **Do NOT deploy without LoadHarness integration testing**
- **Do NOT emit data for cyclic dependencies** (fail loudly instead)
- **Do NOT assume MERGE works without extensive testing**

---

**Next Steps**:
1. User confirms current static seed failure rate
2. Search codebase for integration points (Phase 0)
3. Create test database with known FK structure
4. Build graph infrastructure (Phase 1)
5. Re-evaluate after Phase 1 results

---

*Red Team Analysis Complete*
*Risk Level: HIGH*
*Recommendation: Proceed with extreme caution + phased rollout*
