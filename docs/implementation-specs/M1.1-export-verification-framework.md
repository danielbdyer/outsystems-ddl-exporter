# M1.1: Full-Export Verification Framework

**Status**: Specification (Revised)
**Milestone**: M1 - Export Artifact Verification
**Dependencies**: None (foundational)
**Estimated Complexity**: High (8-10 days)

---

## Executive Summary

### The Specific Problem

After the export pipeline generates artifacts (SSDT table definitions, static seed scripts, dynamic data scripts, manifest files), **there is no automated system to verify that the export completed successfully**. This creates serious risks:

- **Silent Generation Failures**: Files may be missing, truncated, or corrupted without detection
- **Manual Inspection Required**: Operators must manually browse output directories to confirm artifacts exist
- **Late Failure Detection**: Problems only discovered during SSDT build or LoadHarness deployment, not at generation time
- **No Machine-Readable Audit**: No structured evidence that export artifacts are complete and valid for CI/CD integration

**Example Failure**: Export pipeline crashes after generating 50 of 100 tables. Operator deploys partial export to SSDT → missing FK references → build failures.

### Recommended Solution

**File-Level Artifact Verification Framework**

Implement an automated post-generation verification system that validates:

1. **File Existence**: All manifest-declared artifact files exist at specified paths
2. **File Integrity**: Compute SHA-256 checksums, detect corruption/truncation
3. **Manifest Completeness**: Manifest accurately reflects all generated files
4. **Structural Validity**: Basic parsing validation (files are well-formed SQL)

This runs as a **separate phase** after artifact emission and produces `export-validation.json` containing pass/fail status and detailed discrepancies.

### How It Fixes the Problem

1. **Automated Validation**: No manual inspection, verification runs automatically after export
2. **Early Detection**: Catches missing/corrupt files immediately after generation, before deployment
3. **CI/CD Integration**: Machine-readable report enables automated quality gates
4. **Audit Trail**: Structured verification report provides compliance evidence
5. **Fast Failure**: Fail-fast on critical errors (missing DDL, corrupt manifest)

### Alternative Approaches Considered

**Alternative 1: Inline Verification During Emission**
- Validate files as they're written during pipeline execution
- **Rejected**: Slows down emission, complicates error handling, doesn't catch post-emission corruption

**Alternative 2: SSDT Build-Time Validation**
- Rely on SSDT build process to detect missing/invalid files
- **Rejected**: Fails too late (during deployment), cryptic error messages, doesn't validate dynamic data

**Alternative 3: Checksum-Only Validation**
- Just compute checksums without file existence checks
- **Rejected**: Incomplete (doesn't detect missing files), no completeness validation

**Alternative 4: Full Database Validation**
- Execute scripts against test database to prove validity
- **Rejected**: Too slow (requires database setup), that's M1.8's domain (database-level verification)

**Alternative 5: Directory Scanning (No Manifest)**
- Scan output directory and validate all `.sql` files found
- **Rejected**: Doesn't prove what SHOULD exist, can't detect missing artifacts, no structured metadata

**Why File-Level Verification Wins**: Fast (file system only), automated, integrates with CI/CD, provides audit trail, catches 90% of generation failures without database overhead.

---

## 1. Overview

### 1.1 Purpose

Implement a comprehensive export verification system that validates artifact integrity end-to-end, providing unfailing confidence that exports are complete and correct without re-running pipelines.

### 1.2 Goals

1. **Artifact Integrity**: Prove all declared artifacts exist and match expected fingerprints
2. **Export Completeness**: Validate emitted entity scripts match the model catalog
3. **Filesystem Verification**: Fast-fail when files are missing or corrupted
4. **Audit Trail**: Structured verification reports for compliance and debugging
5. **Manifest-Driven**: All verification driven by `FullExportRunManifest` metadata

### 1.3 Architectural Considerations

The verification framework is designed to integrate with the existing `FullExportApplicationService` pipeline without disrupting base class contracts. Verification runs **after manifest creation** as a separate phase, producing an independent `export-validation.json` artifact alongside the manifest. This approach:

- Avoids cascading async changes through `PipelineVerb` base classes
- Keeps manifest creation fast and synchronous (critical for performance)
- Allows verification to compute expensive checksums asynchronously without blocking emission
- Maintains separation of concerns (emission vs. verification)

The framework uses a plugin-style validator pattern, making it easy to add specialized validators (topological proof in M1.2, data integrity in M1.3) without modifying orchestration logic.

### 1.4 Non-Goals

- **Runtime verification** (not build-time proof generation)
- **Schema validation** (covered by SSDT import tests in M1.4)
- **Data integrity** (covered by M1.3)
- **Topological verification** (covered by M1.2)
- **Orphan file detection** (deferred to v2 - requires complex directory scanning)

---

## 2. Architecture

### 2.1 Component Overview

```
┌─────────────────────────────────────────────────────────────┐
│              FullExportApplicationService                    │
│  1. Run extraction → profile → build pipelines              │
│  2. Create manifest (sync, fast)                             │
│  3. Run verification orchestrator (async) ────┐              │
│  4. Return result with manifest + verification report        │
└──────────────────────────────────────────────────┬───────────┘
                                                   │
                                                   │ invokes
                                                   ▼
┌─────────────────────────────────────────────────────────────┐
│           ExportVerificationOrchestrator                     │
│  • Loads manifest from disk                                  │
│  • Creates ExportVerificationContext                         │
│  • Executes validators in priority order                     │
│  • Aggregates results into verification report               │
│  • Persists report to export-validation.json                 │
└────────────────────┬────────────────────────────────────────┘
                     │
                     │ creates
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              ExportVerificationContext                       │
│  • Manifest (loaded from disk)                               │
│  • Output root path                                          │
│  • Entity catalog (derived from manifest + model)            │
└────────────────────┬────────────────────────────────────────┘
                     │
                     │ feeds to
                     ▼
┌──────────────────────────────────────────────────┐
│         IExportValidator Interface               │
│  • ValidateAsync(context) -> ValidationResult    │
└──────────────────────────────────────────────────┘
                     │
        ┌────────────┼──────────────┬────────────┐
        ▼            ▼              ▼            ▼
┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
│ Manifest │  │Filesystem│  │ Checksum │  │ Complete-│
│Integrity │  │  Verify  │  │  Verify  │  │   ness   │
│Validator │  │ Validator│  │ Validator│  │ Validator│
└──────────┘  └──────────┘  └──────────┘  └──────────┘
                     │
                     │ produces
                     ▼
┌─────────────────────────────────────────────────────────────┐
│           ExportVerificationReport                           │
│  • Overall pass/fail status                                  │
│  • Per-stage verification results                            │
│  • Missing files / checksum mismatches                       │
│  • Recommended remediation actions                           │
│  • Serialized to: export-validation.json                     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Design Principles

1. **Fail-Fast**: Stop orchestrator on first critical error (missing DDL, corrupted manifest)
2. **Informative Failures**: Include file paths, expected vs. actual hashes, remediation steps
3. **Idempotent**: Running verification multiple times produces identical results
4. **Performance**: Verification completes in <5s for typical exports (100 entities)
5. **Extensible**: Easy to add new validators without changing orchestrator
6. **Post-Emission**: Runs after all artifacts are written (avoids blocking emission)

---

## 3. Data Models

### 3.1 ExportVerificationContext

**Location**: `src/Osm.Pipeline/Verification/ExportVerificationContext.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Immutable context providing all inputs needed for export verification.
/// Created by orchestrator after loading manifest from disk.
/// </summary>
public sealed record ExportVerificationContext(
    /// <summary>
    /// The manifest loaded from disk (already serialized)
    /// </summary>
    FullExportRunManifest Manifest,

    /// <summary>
    /// Path to the manifest file that was loaded
    /// </summary>
    string ManifestPath,

    /// <summary>
    /// Root output directory for SSDT artifacts
    /// </summary>
    string OutputRoot,

    /// <summary>
    /// Entity catalog derived from manifest stages (for completeness validation)
    /// Best-effort: based on emitted artifacts, not model promises
    /// </summary>
    ImmutableArray<EntityCatalogEntry> EntityCatalog,

    /// <summary>
    /// Timestamp when verification started
    /// </summary>
    DateTimeOffset VerificationStartedAtUtc
)
{
    public static ExportVerificationContext Create(
        FullExportRunManifest manifest,
        string manifestPath,
        string outputRoot,
        TimeProvider timeProvider)
    {
        var entityCatalog = DeriveEntityCatalogFromManifest(manifest);

        return new ExportVerificationContext(
            manifest,
            manifestPath,
            outputRoot,
            entityCatalog,
            timeProvider.GetUtcNow());
    }

    /// <summary>
    /// Derives expected entities from manifest stages (dynamic-insert, static-seed).
    /// This is best-effort based on what was actually emitted, not model promises.
    /// </summary>
    private static ImmutableArray<EntityCatalogEntry> DeriveEntityCatalogFromManifest(
        FullExportRunManifest manifest)
    {
        var builder = ImmutableArray.CreateBuilder<EntityCatalogEntry>();

        // Extract dynamic insert scripts from manifest
        var dynamicStage = manifest.Stages.FirstOrDefault(s => s.Name == "dynamic-insert");
        if (dynamicStage?.Artifacts.TryGetValue("scripts", out var dynamicScripts) == true
            && !string.IsNullOrWhiteSpace(dynamicScripts))
        {
            foreach (var scriptPath in dynamicScripts.Split(';', StringSplitOptions.RemoveEmptyEntries))
            {
                var entry = ParseScriptPathToEntry(scriptPath, hasDynamicData: true);
                if (entry != null)
                {
                    builder.Add(entry);
                }
            }
        }

        // Extract static seed scripts from manifest
        var staticStage = manifest.Stages.FirstOrDefault(s => s.Name == "static-seed");
        if (staticStage?.Artifacts.TryGetValue("scripts", out var staticScripts) == true
            && !string.IsNullOrWhiteSpace(staticScripts))
        {
            foreach (var scriptPath in staticScripts.Split(';', StringSplitOptions.RemoveEmptyEntries))
            {
                var entry = ParseScriptPathToEntry(scriptPath, hasStaticSeed: true);
                if (entry != null)
                {
                    // Merge with existing entry if already seen in dynamic
                    var existing = builder.FirstOrDefault(e =>
                        e.Schema == entry.Schema && e.TableName == entry.TableName);
                    if (existing != null)
                    {
                        builder.Remove(existing);
                        builder.Add(existing with { HasStaticSeed = true });
                    }
                    else
                    {
                        builder.Add(entry);
                    }
                }
            }
        }

        return builder.ToImmutable();
    }

    private static EntityCatalogEntry? ParseScriptPathToEntry(
        string scriptPath,
        bool hasDynamicData = false,
        bool hasStaticSeed = false)
    {
        // Example: "output/DynamicData/dbo.Order.dynamic.sql" → schema="dbo", table="Order"
        var fileName = Path.GetFileNameWithoutExtension(scriptPath);

        // Remove .dynamic or .static suffix
        fileName = fileName
            .Replace(".dynamic", "", StringComparison.OrdinalIgnoreCase)
            .Replace(".static", "", StringComparison.OrdinalIgnoreCase);

        // Parse schema.table format
        var parts = fileName.Split('.');
        if (parts.Length < 2)
        {
            return null; // Can't parse
        }

        var schema = parts[0];
        var table = parts[1];

        return new EntityCatalogEntry(
            Schema: schema,
            TableName: table,
            HasDynamicData: hasDynamicData,
            HasStaticSeed: hasStaticSeed);
    }
}

/// <summary>
/// Catalog entry representing an entity derived from emitted artifacts.
/// This is best-effort based on manifest metadata, not model promises.
/// </summary>
public sealed record EntityCatalogEntry(
    string Schema,
    string TableName,
    bool HasDynamicData,
    bool HasStaticSeed
);
```

### 3.2 IExportValidator Interface

**Location**: `src/Osm.Pipeline/Verification/IExportValidator.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Contract for validators that verify specific aspects of export integrity.
/// Implementations should be stateless and thread-safe.
/// Registered as SCOPED or TRANSIENT in DI (not singleton, to allow ILogger injection).
/// </summary>
public interface IExportValidator
{
    /// <summary>
    /// Unique identifier for this validator (e.g., "checksum", "manifest-integrity")
    /// </summary>
    string ValidatorName { get; }

    /// <summary>
    /// Human-readable description of what this validator checks
    /// </summary>
    string Description { get; }

    /// <summary>
    /// Execution order hint (lower runs first). Critical validators = 0-100.
    /// </summary>
    int Priority { get; }

    /// <summary>
    /// Execute validation against the export context.
    /// Should return quickly (&lt;1s for typical exports).
    /// </summary>
    Task<ValidationResult> ValidateAsync(
        ExportVerificationContext context,
        CancellationToken cancellationToken = default);
}
```

### 3.3 ValidationResult

**Location**: `src/Osm.Pipeline/Verification/ValidationResult.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Result from a single validator execution
/// </summary>
public sealed record ValidationResult(
    string ValidatorName,
    ValidationStatus Status,
    ImmutableArray<ValidationIssue> Issues,
    ValidationMetadata? Metadata = null,
    TimeSpan? Duration = null
)
{
    public static ValidationResult Success(
        string validatorName,
        TimeSpan? duration = null,
        ValidationMetadata? metadata = null)
        => new(validatorName, ValidationStatus.Pass, ImmutableArray<ValidationIssue>.Empty, metadata, duration);

    public static ValidationResult Failure(
        string validatorName,
        ImmutableArray<ValidationIssue> issues,
        TimeSpan? duration = null)
        => new(validatorName, ValidationStatus.Fail, issues, null, duration);

    public bool IsSuccess => Status == ValidationStatus.Pass;
    public bool HasCriticalIssues => Issues.Any(i => i.Severity == IssueSeverity.Critical);
}

public enum ValidationStatus
{
    Pass,
    Fail,
    Warning,
    Skipped
}

/// <summary>
/// Typed metadata from validator execution (avoids object? casting)
/// </summary>
public sealed record ValidationMetadata(
    int FilesVerified = 0,
    int MissingFiles = 0,
    int ChecksumMismatches = 0,
    int ExpectedEntities = 0,
    int EmittedScripts = 0,
    int MissingEntities = 0,
    IDictionary<string, string>? AdditionalData = null
);

/// <summary>
/// Specific issue discovered during validation
/// </summary>
public sealed record ValidationIssue(
    IssueSeverity Severity,
    string Message,
    string? FilePath = null,
    string? ExpectedValue = null,
    string? ActualValue = null,
    string? RecommendedAction = null
);

public enum IssueSeverity
{
    Info,       // Informational only
    Warning,    // Should investigate but not blocking
    Error,      // Blocking issue but export may be usable
    Critical    // Export is invalid and must not be deployed
}
```

### 3.4 ExportVerificationReport

**Location**: `src/Osm.Pipeline/Verification/ExportVerificationReport.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Comprehensive verification report aggregating all validator results.
/// Serialized to export-validation.json alongside manifest.
/// </summary>
public sealed record ExportVerificationReport(
    /// <summary>
    /// Overall verification status (rolls up all validators)
    /// </summary>
    VerificationStatus OverallStatus,

    /// <summary>
    /// When verification was executed
    /// </summary>
    DateTimeOffset VerifiedAtUtc,

    /// <summary>
    /// Total time spent on verification
    /// </summary>
    TimeSpan TotalDuration,

    /// <summary>
    /// Results from individual validators (ordered by execution)
    /// </summary>
    ImmutableArray<ValidationResult> ValidationResults,

    /// <summary>
    /// Summary statistics
    /// </summary>
    VerificationSummary Summary,

    /// <summary>
    /// Manifest reference (path to manifest that was verified)
    /// </summary>
    string ManifestPath,

    /// <summary>
    /// Output root that was verified
    /// </summary>
    string OutputRoot
)
{
    public bool IsSuccess => OverallStatus == VerificationStatus.Pass;

    public IEnumerable<ValidationIssue> AllIssues =>
        ValidationResults.SelectMany(r => r.Issues);

    public IEnumerable<ValidationIssue> CriticalIssues =>
        AllIssues.Where(i => i.Severity == IssueSeverity.Critical);
}

public enum VerificationStatus
{
    Pass,           // All validators passed
    PassWithWarnings, // All critical checks passed but warnings exist
    Fail,           // One or more validators failed
    Incomplete      // Verification could not complete (missing inputs)
}

/// <summary>
/// High-level verification statistics
/// </summary>
public sealed record VerificationSummary(
    int TotalValidators,
    int PassedValidators,
    int FailedValidators,
    int SkippedValidators,
    int TotalIssues,
    int CriticalIssues,
    int Errors,
    int Warnings,
    int FilesVerified,
    int MissingFiles,
    int ChecksumMismatches
);
```

---

## 4. Implementation Details

### 4.1 Core Validators

#### 4.1.1 ManifestIntegrityValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/ManifestIntegrityValidator.cs`

**Priority**: 0 (runs first - critical prerequisite)

**Purpose**: Validates that `DynamicArtifacts` and `StaticSeedArtifacts` collections are well-formed.

**Checks**:
- Manifest is not null/empty
- All declared artifacts have valid paths (absolute, non-empty)
- Stage collection contains expected stages (extract-model, build-ssdt)
- No duplicate artifact names
- Artifact content types are valid
- Stage artifacts reference only declared files

**Implementation**:
```csharp
public sealed class ManifestIntegrityValidator : IExportValidator
{
    private readonly ILogger<ManifestIntegrityValidator> _logger;

    public ManifestIntegrityValidator(ILogger<ManifestIntegrityValidator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public string ValidatorName => "manifest-integrity";
    public string Description => "Validates manifest structure and artifact declarations";
    public int Priority => 0;

    public Task<ValidationResult> ValidateAsync(
        ExportVerificationContext context,
        CancellationToken cancellationToken)
    {
        var sw = Stopwatch.StartNew();
        var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
        var manifest = context.Manifest;

        // Check 1: Manifest basics
        if (manifest.Stages.IsDefaultOrEmpty)
        {
            issues.Add(new ValidationIssue(
                IssueSeverity.Critical,
                "Manifest contains no stages",
                RecommendedAction: "Re-run full-export to generate valid manifest"));
            return Task.FromResult(ValidationResult.Failure(ValidatorName, issues.ToImmutable(), sw.Elapsed));
        }

        // Check 2: Artifact path validity
        foreach (var artifact in manifest.DynamicArtifacts.Concat(manifest.StaticSeedArtifacts))
        {
            if (string.IsNullOrWhiteSpace(artifact.Path))
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Critical,
                    $"Artifact '{artifact.Name}' has empty path"));
            }
            else if (!Path.IsPathFullyQualified(artifact.Path))
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Error,
                    $"Artifact '{artifact.Name}' has relative path: {artifact.Path}",
                    RecommendedAction: "Manifest should contain absolute paths"));
            }
        }

        // Check 3: Stage consistency
        var requiredStages = new[] { "extract-model", "build-ssdt" };
        foreach (var required in requiredStages)
        {
            if (!manifest.Stages.Any(s => s.Name == required))
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Warning,
                    $"Expected stage '{required}' not found in manifest"));
            }
        }

        // Check 4: Artifact uniqueness
        var duplicates = manifest.DynamicArtifacts
            .Select(a => a.Name)
            .GroupBy(n => n, StringComparer.OrdinalIgnoreCase)
            .Where(g => g.Count() > 1);

        foreach (var dup in duplicates)
        {
            issues.Add(new ValidationIssue(
                IssueSeverity.Error,
                $"Duplicate artifact name: {dup.Key}"));
        }

        sw.Stop();

        return Task.FromResult(issues.Count == 0
            ? ValidationResult.Success(ValidatorName, sw.Elapsed)
            : ValidationResult.Failure(ValidatorName, issues.ToImmutable(), sw.Elapsed));
    }
}
```

#### 4.1.2 FilesystemVerificationValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/FilesystemVerificationValidator.cs`

**Priority**: 10 (runs early)

**Purpose**: Proves all declared artifacts exist on filesystem with reasonable characteristics.

**Checks**:
- Every artifact in `DynamicArtifacts` exists
- Every artifact in `StaticSeedArtifacts` exists
- File sizes are reasonable (>0 bytes for scripts, <100MB for manifests)

**Implementation**:
```csharp
public sealed class FilesystemVerificationValidator : IExportValidator
{
    private readonly ILogger<FilesystemVerificationValidator> _logger;

    public FilesystemVerificationValidator(ILogger<FilesystemVerificationValidator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public string ValidatorName => "filesystem-verification";
    public string Description => "Validates all declared artifacts exist on filesystem";
    public int Priority => 10;

    public Task<ValidationResult> ValidateAsync(
        ExportVerificationContext context,
        CancellationToken cancellationToken)
    {
        var sw = Stopwatch.StartNew();
        var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
        var manifest = context.Manifest;
        var filesVerified = 0;
        var missingFiles = 0;

        // Verify all artifacts
        foreach (var artifact in manifest.DynamicArtifacts.Concat(manifest.StaticSeedArtifacts))
        {
            var fullPath = artifact.Path; // Already absolute per manifest contract

            if (!File.Exists(fullPath))
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Critical,
                    $"Missing artifact: {artifact.Name}",
                    FilePath: fullPath,
                    RecommendedAction: "Re-run full-export to regenerate missing artifacts"));
                missingFiles++;
                continue;
            }

            var fileInfo = new FileInfo(fullPath);

            // Size validation
            if (fileInfo.Length == 0)
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Error,
                    $"Artifact is empty: {artifact.Name}",
                    FilePath: fullPath,
                    RecommendedAction: "Verify entity has data; check for export errors"));
            }
            else if (fileInfo.Length > 100_000_000) // 100MB
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Warning,
                    $"Artifact is unusually large: {artifact.Name} ({fileInfo.Length / 1_000_000}MB)",
                    FilePath: fullPath));
            }

            filesVerified++;
        }

        sw.Stop();

        var metadata = new ValidationMetadata(
            FilesVerified: filesVerified,
            MissingFiles: missingFiles);

        return Task.FromResult(issues.Count == 0
            ? ValidationResult.Success(ValidatorName, sw.Elapsed, metadata)
            : ValidationResult.Failure(ValidatorName, issues.ToImmutable(), sw.Elapsed));
    }
}
```

#### 4.1.3 ChecksumValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/ChecksumValidator.cs`

**Priority**: 20

**Purpose**: Validates artifact integrity using SHA256 checksums computed during verification.

**Note**: This validator computes checksums asynchronously from disk. Future enhancement (M1.1.1) could cache checksums in a separate `export-fingerprints.json` file for faster subsequent verifications.

**Implementation**:
```csharp
public sealed class ChecksumValidator : IExportValidator
{
    private readonly ILogger<ChecksumValidator> _logger;

    public ChecksumValidator(ILogger<ChecksumValidator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public string ValidatorName => "checksum-verification";
    public string Description => "Computes SHA256 checksums for critical artifacts";
    public int Priority => 20;

    public async Task<ValidationResult> ValidateAsync(
        ExportVerificationContext context,
        CancellationToken cancellationToken)
    {
        var sw = Stopwatch.StartNew();
        var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
        var checksumMismatches = 0;

        // Find critical artifacts to checksum (SafeScript, manifest, etc.)
        var criticalArtifacts = context.Manifest.DynamicArtifacts
            .Where(a => IsCriticalArtifact(a.Name))
            .ToList();

        _logger.LogInformation(
            "Computing checksums for {ArtifactCount} critical artifacts",
            criticalArtifacts.Count);

        foreach (var artifact in criticalArtifacts)
        {
            if (!File.Exists(artifact.Path))
            {
                // Already reported by FilesystemVerificationValidator
                continue;
            }

            try
            {
                var checksum = await ComputeSha256Async(artifact.Path, cancellationToken);

                // Store checksum for future comparison (could persist to fingerprints file)
                _logger.LogDebug(
                    "Artifact {Name}: SHA256={Checksum}",
                    artifact.Name,
                    checksum);

                // Future: Compare against persisted fingerprints if available
            }
            catch (IOException ex)
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Error,
                    $"Failed to compute checksum for {artifact.Name}: {ex.Message}",
                    FilePath: artifact.Path));
                checksumMismatches++;
            }
        }

        sw.Stop();

        var metadata = new ValidationMetadata(ChecksumMismatches: checksumMismatches);

        return issues.Count == 0
            ? ValidationResult.Success(ValidatorName, sw.Elapsed, metadata)
            : ValidationResult.Failure(ValidatorName, issues.ToImmutable(), sw.Elapsed);
    }

    private static bool IsCriticalArtifact(string name)
    {
        // Checksum critical files: manifest, decision log, safe script
        var critical = new[] { "manifest", "decision-log", "opportunity-safe", "full-export-manifest" };
        return critical.Contains(name, StringComparer.OrdinalIgnoreCase);
    }

    private static async Task<string> ComputeSha256Async(string filePath, CancellationToken ct)
    {
        using var stream = new FileStream(
            filePath,
            FileMode.Open,
            FileAccess.Read,
            FileShare.Read,
            bufferSize: 65536, // 64KB buffer for perf
            useAsync: true);

        using var sha256 = SHA256.Create();
        var hashBytes = await sha256.ComputeHashAsync(stream, ct);
        return Convert.ToHexString(hashBytes);
    }
}
```

#### 4.1.4 CompletenessValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/CompletenessValidator.cs`

**Priority**: 30

**Purpose**: Proves emitted artifacts align with entity catalog (best-effort validation).

**Checks**:
- Cross-reference `EntityCatalog` (from manifest) against declared artifact paths
- Ensure scripts referenced in manifest actually exist
- Detect missing scripts for entities that should have data

**Implementation**:
```csharp
public sealed class CompletenessValidator : IExportValidator
{
    private readonly ILogger<CompletenessValidator> _logger;

    public CompletenessValidator(ILogger<CompletenessValidator> logger)
    {
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public string ValidatorName => "completeness-verification";
    public string Description => "Validates all expected entities have emitted artifacts";
    public int Priority => 30;

    public Task<ValidationResult> ValidateAsync(
        ExportVerificationContext context,
        CancellationToken cancellationToken)
    {
        var sw = Stopwatch.StartNew();
        var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
        var manifest = context.Manifest;

        // Find dynamic-insert stage
        var dynamicStage = manifest.Stages.FirstOrDefault(s => s.Name == "dynamic-insert");
        if (dynamicStage == null)
        {
            // No dynamic data expected - this is valid
            return Task.FromResult(ValidationResult.Success(
                ValidatorName,
                sw.Elapsed,
                new ValidationMetadata(
                    AdditionalData: new Dictionary<string, string> { ["reason"] = "No dynamic-insert stage" })));
        }

        // Extract emitted scripts from manifest
        if (!dynamicStage.Artifacts.TryGetValue("scripts", out var scriptsValue)
            || string.IsNullOrWhiteSpace(scriptsValue))
        {
            issues.Add(new ValidationIssue(
                IssueSeverity.Warning,
                "Dynamic-insert stage exists but has no scripts metadata"));
            return Task.FromResult(ValidationResult.Failure(ValidatorName, issues.ToImmutable(), sw.Elapsed));
        }

        var emittedScripts = scriptsValue
            .Split(';', StringSplitOptions.RemoveEmptyEntries)
            .Select(path => path.Trim())
            .Where(path => !string.IsNullOrWhiteSpace(path))
            .ToHashSet(StringComparer.OrdinalIgnoreCase);

        // Verify all emitted scripts exist
        var missingScripts = 0;
        foreach (var scriptPath in emittedScripts)
        {
            if (!File.Exists(scriptPath))
            {
                issues.Add(new ValidationIssue(
                    IssueSeverity.Error,
                    "Script declared in manifest but missing from filesystem",
                    FilePath: scriptPath,
                    RecommendedAction: "Re-run full-export"));
                missingScripts++;
            }
        }

        sw.Stop();

        var metadata = new ValidationMetadata(
            ExpectedEntities: context.EntityCatalog.Length,
            EmittedScripts: emittedScripts.Count,
            MissingEntities: missingScripts);

        return Task.FromResult(issues.Count == 0
            ? ValidationResult.Success(ValidatorName, sw.Elapsed, metadata)
            : ValidationResult.Failure(ValidatorName, issues.ToImmutable(), sw.Elapsed));
    }
}
```

### 4.2 ExportVerificationOrchestrator

**Location**: `src/Osm.Pipeline/Verification/ExportVerificationOrchestrator.cs`

**Purpose**: Coordinates validator execution and aggregates results.

**Key Responsibilities**:
1. Accept manifest path + output root
2. Load manifest from disk
3. Create verification context
4. Execute validators sequentially (sorted by priority)
5. Fail-fast on critical issues (stop orchestrator, produce partial report)
6. Aggregate results into `ExportVerificationReport`
7. Serialize report to `export-validation.json`

**Implementation**:
```csharp
public sealed class ExportVerificationOrchestrator
{
    private readonly IEnumerable<IExportValidator> _validators;
    private readonly ILogger<ExportVerificationOrchestrator> _logger;
    private readonly TimeProvider _timeProvider;

    public ExportVerificationOrchestrator(
        IEnumerable<IExportValidator> validators,
        ILogger<ExportVerificationOrchestrator> logger,
        TimeProvider? timeProvider = null)
    {
        _validators = validators ?? throw new ArgumentNullException(nameof(validators));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        _timeProvider = timeProvider ?? TimeProvider.System;
    }

    public async Task<ExportVerificationReport> VerifyAsync(
        string manifestPath,
        string outputRoot,
        CancellationToken cancellationToken = default)
    {
        var startTime = Stopwatch.GetTimestamp();

        // Load manifest from disk
        _logger.LogInformation("Loading manifest from {ManifestPath}", manifestPath);
        var manifest = await LoadManifestAsync(manifestPath, cancellationToken);

        // Create context
        var context = ExportVerificationContext.Create(
            manifest,
            manifestPath,
            outputRoot,
            _timeProvider);

        // Sort validators by priority
        var orderedValidators = _validators
            .OrderBy(v => v.Priority)
            .ToImmutableArray();

        _logger.LogInformation(
            "Starting export verification with {ValidatorCount} validators",
            orderedValidators.Length);

        var results = ImmutableArray.CreateBuilder<ValidationResult>();
        var shouldAbort = false;

        foreach (var validator in orderedValidators)
        {
            if (shouldAbort)
            {
                _logger.LogWarning(
                    "Skipping validator {ValidatorName} due to previous critical failure",
                    validator.ValidatorName);
                continue;
            }

            _logger.LogDebug(
                "Executing validator: {ValidatorName} (priority: {Priority})",
                validator.ValidatorName,
                validator.Priority);

            var validatorStart = Stopwatch.GetTimestamp();

            try
            {
                var result = await validator.ValidateAsync(context, cancellationToken);
                results.Add(result);

                var elapsed = Stopwatch.GetElapsedTime(validatorStart);
                _logger.LogInformation(
                    "Validator {ValidatorName} completed: {Status} ({Duration}ms)",
                    validator.ValidatorName,
                    result.Status,
                    elapsed.TotalMilliseconds);

                // Fail-fast: abort orchestrator on critical issues
                if (result.HasCriticalIssues)
                {
                    _logger.LogError(
                        "Validator {ValidatorName} found {CriticalCount} critical issue(s); aborting verification",
                        validator.ValidatorName,
                        result.Issues.Count(i => i.Severity == IssueSeverity.Critical));
                    shouldAbort = true;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Validator {ValidatorName} threw exception",
                    validator.ValidatorName);

                results.Add(ValidationResult.Failure(
                    validator.ValidatorName,
                    ImmutableArray.Create(new ValidationIssue(
                        IssueSeverity.Critical,
                        $"Validator threw exception: {ex.Message}",
                        RecommendedAction: "Check logs for full exception details"))));
                shouldAbort = true;
            }
        }

        var totalDuration = Stopwatch.GetElapsedTime(startTime);
        var report = BuildReport(
            context,
            results.ToImmutable(),
            totalDuration);

        // Persist report
        var reportPath = Path.Combine(outputRoot, "export-validation.json");
        await PersistReportAsync(report, reportPath, cancellationToken);

        _logger.LogInformation(
            "Export verification completed: {Status} ({IssueCount} issues, {Duration}ms)",
            report.OverallStatus,
            report.Summary.TotalIssues,
            totalDuration.TotalMilliseconds);

        return report;
    }

    private async Task<FullExportRunManifest> LoadManifestAsync(
        string manifestPath,
        CancellationToken cancellationToken)
    {
        if (!File.Exists(manifestPath))
        {
            throw new FileNotFoundException(
                $"Manifest file not found: {manifestPath}. Cannot verify export without manifest.");
        }

        using var stream = File.OpenRead(manifestPath);
        var manifest = await JsonSerializer.DeserializeAsync<FullExportRunManifest>(
            stream,
            cancellationToken: cancellationToken);

        if (manifest == null)
        {
            throw new InvalidOperationException(
                $"Failed to deserialize manifest from {manifestPath}");
        }

        return manifest;
    }

    private ExportVerificationReport BuildReport(
        ExportVerificationContext context,
        ImmutableArray<ValidationResult> results,
        TimeSpan totalDuration)
    {
        var summary = BuildSummary(results);
        var overallStatus = DetermineOverallStatus(results);

        return new ExportVerificationReport(
            overallStatus,
            context.VerificationStartedAtUtc,
            totalDuration,
            results,
            summary,
            context.ManifestPath,
            context.OutputRoot);
    }

    private VerificationSummary BuildSummary(ImmutableArray<ValidationResult> results)
    {
        var allIssues = results.SelectMany(r => r.Issues).ToList();

        // Aggregate metrics from all validators
        var filesVerified = results
            .Where(r => r.Metadata != null)
            .Sum(r => r.Metadata!.FilesVerified);

        var missingFiles = results
            .Where(r => r.Metadata != null)
            .Sum(r => r.Metadata!.MissingFiles);

        var checksumMismatches = results
            .Where(r => r.Metadata != null)
            .Sum(r => r.Metadata!.ChecksumMismatches);

        return new VerificationSummary(
            TotalValidators: results.Length,
            PassedValidators: results.Count(r => r.Status == ValidationStatus.Pass),
            FailedValidators: results.Count(r => r.Status == ValidationStatus.Fail),
            SkippedValidators: results.Count(r => r.Status == ValidationStatus.Skipped),
            TotalIssues: allIssues.Count,
            CriticalIssues: allIssues.Count(i => i.Severity == IssueSeverity.Critical),
            Errors: allIssues.Count(i => i.Severity == IssueSeverity.Error),
            Warnings: allIssues.Count(i => i.Severity == IssueSeverity.Warning),
            FilesVerified: filesVerified,
            MissingFiles: missingFiles,
            ChecksumMismatches: checksumMismatches);
    }

    private VerificationStatus DetermineOverallStatus(ImmutableArray<ValidationResult> results)
    {
        if (results.Any(r => r.Status == ValidationStatus.Fail || r.HasCriticalIssues))
            return VerificationStatus.Fail;

        if (results.SelectMany(r => r.Issues).Any(i => i.Severity == IssueSeverity.Warning))
            return VerificationStatus.PassWithWarnings;

        if (results.Any(r => r.Status == ValidationStatus.Skipped))
            return VerificationStatus.Incomplete;

        return VerificationStatus.Pass;
    }

    private async Task PersistReportAsync(
        ExportVerificationReport report,
        string reportPath,
        CancellationToken cancellationToken)
    {
        var directory = Path.GetDirectoryName(reportPath);
        if (!string.IsNullOrWhiteSpace(directory))
        {
            Directory.CreateDirectory(directory!);
        }

        var options = new JsonSerializerOptions
        {
            WriteIndented = true,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };

        using var stream = new FileStream(
            reportPath,
            FileMode.Create,
            FileAccess.Write,
            FileShare.None,
            bufferSize: 4096,
            useAsync: true);

        await JsonSerializer.SerializeAsync(stream, report, options, cancellationToken);

        _logger.LogInformation("Verification report written to {ReportPath}", reportPath);
    }
}
```

---

## Codebase Integration Guide

### Existing Infrastructure (Leverage These)

✅ **Manifest Structure** - Already Complete
- **File**: `src/Osm.Pipeline/Runtime/FullExportRunManifest.cs`
- **Properties**:
  - `DynamicArtifacts` (line 20) - ImmutableArray<FullExportManifestArtifact>
  - `StaticSeedArtifacts` (line 21) - ImmutableArray<FullExportManifestArtifact>
  - `Stages` (line 19) - Pipeline execution stages with metadata
- **Status**: Ready to use - M1.1 can read these directly

✅ **FullExportManifestArtifact** - Artifact Metadata
```csharp
public sealed record FullExportManifestArtifact(
    string Name,
    string Path,
    string ContentType
);
```
- **Location**: `src/Osm.Pipeline/Runtime/FullExportRunManifest.cs`
- **Usage**: Lists all generated files (SQL scripts, JSON, etc.)

✅ **Pipeline Logging** - Telemetry Infrastructure
- **File**: `src/Osm.Pipeline/Orchestration/PipelineExecutionLogBuilder.cs`
- **Status**: Can use `.Record()` pattern for verification events

### Required Changes

#### Change 1: Create Verification Directory

**Location**: `src/Osm.Pipeline/Verification/` (NEW DIRECTORY)

**Structure**:
```
src/Osm.Pipeline/Verification/
  ├─ ExportVerificationContext.cs
  ├─ IExportValidator.cs
  ├─ ValidationResult.cs
  ├─ ExportVerificationReport.cs
  ├─ ExportVerificationOrchestrator.cs
  └─ Validators/
      ├─ ManifestIntegrityValidator.cs
      ├─ FilesystemVerificationValidator.cs
      ├─ ChecksumValidator.cs
      └─ CompletenessValidator.cs
```

#### Change 2: Extend FullExportApplicationInput/Result (Optional)

**File**: `src/Osm.Pipeline/Application/FullExportApplicationService.cs`

**Option A** (CLI flag approach - recommended for MVP):
- Add `--verify-export` CLI flag (no application service changes)
- Run verification as separate post-processing step
- Verification runs AFTER full-export completes

**Option B** (integrated approach - for production):
- Add `bool EnableVerification` to `FullExportApplicationInput`
- Add `ExportVerificationReport? VerificationReport` to `FullExportApplicationResult`
- Verification runs IN pipeline (fails build if verification fails)

**MVP Recommendation**: Start with Option A (CLI flag), upgrade to Option B later

#### Change 3: Add CLI Verb or Flag

**File**: `src/Osm.Cli/Verbs/FullExportVerb.cs` (or similar)

**Option A - New Verb** (verify-export):
```csharp
// Usage: osm verify-export --manifest ./output/manifest.json --output ./output
public sealed class VerifyExportVerb
{
    [Value(0, Required = true, HelpText = "Path to manifest.json")]
    public string ManifestPath { get; set; }

    [Option('o', "output", Required = true, HelpText = "Output directory")]
    public string OutputDirectory { get; set; }
}
```

**Option B - Flag on full-export** (--verify):
```csharp
// Usage: osm full-export --verify ...
// Add to FullExportVerb:
[Option("verify", Default = false, HelpText = "Run export verification after build")]
public bool VerifyExport { get; set; }
```

**MVP Recommendation**: Option B (simpler - just add flag)

#### Change 4: DI Registration

**Find DI Container** (likely one of these):
- `src/Osm.Cli/Program.cs`
- `src/Osm.Pipeline/ServiceCollectionExtensions.cs`
- `src/Osm.Pipeline/Configuration/PipelineServiceRegistration.cs`

**Add Registrations**:
```csharp
// Validators (scoped per verification run)
services.AddScoped<IExportValidator, ManifestIntegrityValidator>();
services.AddScoped<IExportValidator, FilesystemVerificationValidator>();
services.AddScoped<IExportValidator, ChecksumValidator>();
services.AddScoped<IExportValidator, CompletenessValidator>();

// Orchestrator (scoped)
services.AddScoped<ExportVerificationOrchestrator>();

// Report serializer (singleton)
services.AddSingleton<ExportVerificationReportSerializer>();
```

**Note**: All validators implement `IExportValidator` - orchestrator auto-discovers via DI

### Testing Infrastructure

**New Test Files to Create**:
```
tests/Osm.Pipeline.Tests/Verification/
  ├─ ManifestIntegrityValidatorTests.cs
  ├─ FilesystemVerificationValidatorTests.cs
  ├─ ChecksumValidatorTests.cs
  ├─ CompletenessValidatorTests.cs
  └─ ExportVerificationOrchestratorTests.cs
```

**Test Fixtures Needed**:
- Mock `FullExportRunManifest` with sample artifacts
- Temporary file system with test SQL scripts
- SHA-256 checksum test data

**Integration Test** (optional for MVP):
- Run full-export → verify-export → assert report.OverallStatus == Pass
- Test missing file → assert report.OverallStatus == Fail
- Test corrupted file → assert checksum validator fails

### Critical Questions to Resolve Before Implementation

1. **CLI Architecture**:
   - ❓ Where are CLI verbs defined? (find `full-export` verb file)
   - ❓ Pattern for adding new verbs or flags?
   - ❓ How to access application services from verb handler?

2. **DI Container**:
   - ❓ Where is the main DI container setup? (Program.cs or elsewhere?)
   - ❓ How to register collection of `IExportValidator` for auto-discovery?

3. **File System Abstraction**:
   - ❓ Does codebase use `System.IO.Abstractions.IFileSystem`?
   - ❓ If YES: Validators should use `IFileSystem` for testability
   - ❓ If NO: Use `System.IO.File` directly

4. **Checksum Algorithm**:
   - ❓ Is there existing checksum utility in codebase?
   - ❓ If NO: Implement SHA-256 using `System.Security.Cryptography.SHA256`

### File Location Quick Reference

**Existing Files to Modify** (Optional):
```
src/Osm.Pipeline/Application/FullExportApplicationService.cs
  └─ Add verification call (if Option B integration)

src/Osm.Cli/Verbs/FullExportVerb.cs
  └─ Add --verify flag

??? (DI registration file - need to locate)
  └─ Add verification service registrations
```

**New Files to Create**:
```
src/Osm.Pipeline/Verification/
  ├─ ExportVerificationContext.cs (model, ~150 lines)
  ├─ IExportValidator.cs (interface, ~40 lines)
  ├─ ValidationResult.cs (model, ~80 lines)
  ├─ ExportVerificationReport.cs (model, ~90 lines)
  ├─ ExportVerificationOrchestrator.cs (orchestrator, ~250 lines)
  ├─ ExportVerificationReportSerializer.cs (serializer, ~50 lines)
  └─ Validators/
      ├─ ManifestIntegrityValidator.cs (~100 lines)
      ├─ FilesystemVerificationValidator.cs (~90 lines)
      ├─ ChecksumValidator.cs (~110 lines)
      └─ CompletenessValidator.cs (~95 lines)

tests/Osm.Pipeline.Tests/Verification/
  ├─ ManifestIntegrityValidatorTests.cs
  ├─ FilesystemVerificationValidatorTests.cs
  ├─ ChecksumValidatorTests.cs
  ├─ CompletenessValidatorTests.cs
  └─ ExportVerificationOrchestratorTests.cs
```

### Implementation Order (MVP)

**Phase 1: Core Data Models** (0.5 days)
1. Create `ExportVerificationContext.cs`
2. Create `IExportValidator.cs`
3. Create `ValidationResult.cs`
4. Create `ExportVerificationReport.cs`

**Phase 2: Validators** (2 days)
1. Implement `ManifestIntegrityValidator` (simplest - just JSON parse)
2. Implement `FilesystemVerificationValidator` (file exists checks)
3. Implement `CompletenessValidator` (manifest vs expected artifacts)
4. Implement `ChecksumValidator` (SHA-256 computation)

**Phase 3: Orchestrator** (1 day)
1. Implement `ExportVerificationOrchestrator`
2. Implement `ExportVerificationReportSerializer`
3. Add DI registrations

**Phase 4: CLI Integration** (0.5 days)
1. Add `--verify` flag to `full-export` verb
2. Wire up orchestrator call after build completes
3. Add error handling and logging

**Phase 5: Testing** (1 day)
1. Unit tests for each validator
2. Integration test (full pipeline)

**Total Estimate**: 5 days (parallel with M1.0 if desired)

---

## 5. Integration Points

### 5.1 FullExportApplicationService Integration

**Location**: `src/Osm.Pipeline/Application/FullExportApplicationService.cs`

**Modification**: Add verification step AFTER manifest creation.

```csharp
// In FullExportApplicationService.RunAsync()

// ... existing pipeline execution (extraction → profile → build) ...

// NEW: Run verification if enabled
ExportVerificationReport? verificationReport = null;
if (input.EnableVerification) // Add to FullExportApplicationInput
{
    var manifestPath = Path.Combine(buildOutputDirectory, FullExportVerb.RunManifestFileName);

    try
    {
        verificationReport = await _verificationOrchestrator.VerifyAsync(
            manifestPath,
            buildOutputDirectory,
            cancellationToken);

        // Fail build if verification failed
        if (verificationReport.OverallStatus == VerificationStatus.Fail)
        {
            _logger.LogError(
                "Export verification failed with {CriticalCount} critical issues",
                verificationReport.Summary.CriticalIssues);

            return Result<FullExportApplicationResult>.Failure(
                new OperationError(
                    "ExportVerificationFailed",
                    $"Export verification failed. See {Path.Combine(buildOutputDirectory, "export-validation.json")} for details."));
        }
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "Export verification threw exception");
        // Don't fail build on verification errors (verification is best-effort)
    }
}

// Return result with verification metadata
return new FullExportApplicationResult(
    // ... existing fields ...
    VerificationReport: verificationReport);
```

### 5.2 FullExportApplicationInput Extension

**Location**: `src/Osm.Pipeline/Application/FullExportApplicationInput.cs`

```csharp
public sealed record FullExportApplicationInput(
    // ... existing parameters ...

    // NEW: Enable verification (default: false for now, flip to true after stabilization)
    bool EnableVerification = false
);
```

### 5.3 FullExportApplicationResult Extension

**Location**: `src/Osm.Pipeline/Application/FullExportApplicationResult.cs`

```csharp
public sealed record FullExportApplicationResult(
    // ... existing fields ...

    // NEW: Verification report (null if verification not run)
    ExportVerificationReport? VerificationReport = null
);
```

### 5.4 CLI Integration

**Location**: `src/Osm.Cli/FullExportOptions.cs`

```csharp
public sealed record FullExportOptions
{
    // ... existing options ...

    [Option("--verify-export", Description = "Run export verification after emission (default: false)")]
    public bool VerifyExport { get; init; }
}
```

### 5.5 Dependency Injection Setup

**Location**: `src/Osm.Pipeline/PipelineServiceCollectionExtensions.cs`

```csharp
public static IServiceCollection AddExportVerification(this IServiceCollection services)
{
    // Register validators as SCOPED (allows ILogger injection, fresh instance per verification run)
    services.AddScoped<IExportValidator, ManifestIntegrityValidator>();
    services.AddScoped<IExportValidator, FilesystemVerificationValidator>();
    services.AddScoped<IExportValidator, ChecksumValidator>();
    services.AddScoped<IExportValidator, CompletenessValidator>();

    // Register orchestrator as SCOPED (matches validator lifetime)
    services.AddScoped<ExportVerificationOrchestrator>();

    return services;
}

// In Program.cs or Startup.cs
services.AddExportVerification();
```

---

## 6. Test Scenarios

### 6.1 Unit Tests

**Location**: `tests/Osm.Pipeline.Tests/Verification/`

#### ManifestIntegrityValidatorTests
```csharp
[Fact]
public async Task EmptyManifest_ReturnsFailure()
{
    var validator = new ManifestIntegrityValidator(NullLogger<ManifestIntegrityValidator>.Instance);
    var context = CreateContext(manifest: FullExportRunManifest.Empty);

    var result = await validator.ValidateAsync(context);

    Assert.Equal(ValidationStatus.Fail, result.Status);
    Assert.Contains(result.Issues, i => i.Severity == IssueSeverity.Critical);
}

[Fact]
public async Task ValidManifest_ReturnsSuccess()
{
    var validator = new ManifestIntegrityValidator(NullLogger<ManifestIntegrityValidator>.Instance);
    var context = CreateContext(manifest: CreateValidManifest());

    var result = await validator.ValidateAsync(context);

    Assert.Equal(ValidationStatus.Pass, result.Status);
    Assert.Empty(result.Issues);
}
```

#### FilesystemVerificationValidatorTests
```csharp
[Fact]
public async Task MissingArtifact_ReturnsCriticalFailure()
{
    var validator = new FilesystemVerificationValidator(NullLogger<FilesystemVerificationValidator>.Instance);
    var manifest = CreateManifestWithArtifact("test.sql", "/path/that/does/not/exist.sql");
    var context = CreateContext(manifest);

    var result = await validator.ValidateAsync(context);

    Assert.Equal(ValidationStatus.Fail, result.Status);
    Assert.Contains(result.Issues, i =>
        i.Severity == IssueSeverity.Critical &&
        i.Message.Contains("Missing artifact"));
}
```

#### ChecksumValidatorTests
```csharp
[Fact]
public async Task ComputesChecksumSuccessfully()
{
    var validator = new ChecksumValidator(NullLogger<ChecksumValidator>.Instance);
    var tempFile = CreateTempFileWithContent("test content");
    var manifest = CreateManifestWithArtifact("manifest", tempFile);
    var context = CreateContext(manifest);

    var result = await validator.ValidateAsync(context);

    Assert.Equal(ValidationStatus.Pass, result.Status);
    Assert.NotNull(result.Metadata);
}
```

### 6.2 Integration Tests

**Location**: `tests/Osm.Pipeline.Integration.Tests/Verification/`

#### ExportVerificationOrchestratorIntegrationTests
```csharp
[Fact]
public async Task FullPipeline_WithValidExport_AllValidatorsPass()
{
    // Arrange: Run full-export on fixture
    var fixture = await RunFullExportOnFixture("basic-model");
    var orchestrator = CreateOrchestrator();

    // Act
    var report = await orchestrator.VerifyAsync(
        fixture.ManifestPath,
        fixture.OutputRoot);

    // Assert
    Assert.Equal(VerificationStatus.Pass, report.OverallStatus);
    Assert.Empty(report.CriticalIssues);
    Assert.Equal(4, report.Summary.PassedValidators); // All 4 validators
}

[Fact]
public async Task FullPipeline_WithMissingFile_VerificationFails()
{
    // Arrange
    var fixture = await RunFullExportOnFixture("basic-model");

    // Corrupt: delete one dynamic script
    var scriptToDelete = GetFirstDynamicScript(fixture.ManifestPath);
    File.Delete(scriptToDelete);

    var orchestrator = CreateOrchestrator();

    // Act
    var report = await orchestrator.VerifyAsync(
        fixture.ManifestPath,
        fixture.OutputRoot);

    // Assert
    Assert.Equal(VerificationStatus.Fail, report.OverallStatus);
    Assert.True(report.Summary.MissingFiles > 0);
    Assert.Contains(report.AllIssues, i =>
        i.Severity == IssueSeverity.Critical &&
        i.Message.Contains("Missing artifact"));
}
```

### 6.3 End-to-End Test

**Location**: `tests/Osm.Etl.Integration.Tests/`

```csharp
[Fact]
public async Task FullExport_WithVerificationEnabled_ProducesValidReport()
{
    // Arrange
    var options = CreateFullExportOptions();
    options.VerifyExport = true;

    // Act
    var result = await _fullExportService.RunAsync(
        CreateApplicationInput(options),
        CancellationToken.None);

    // Assert
    Assert.True(result.IsSuccess);
    Assert.NotNull(result.Value.VerificationReport);

    var report = result.Value.VerificationReport;
    Assert.Equal(VerificationStatus.Pass, report.OverallStatus);
    Assert.Empty(report.CriticalIssues);

    // Verify report file exists
    var reportPath = Path.Combine(options.OutputRoot, "export-validation.json");
    Assert.True(File.Exists(reportPath));
}
```

---

## 7. Migration Path

### 7.1 Phased Rollout

**Phase 1: Foundation (Days 1-3)**
- Implement data models (Context, ValidationResult, Report, Metadata)
- Implement IExportValidator interface
- Implement ManifestIntegrityValidator (simplest)
- Add unit tests
- Wire up DI registration

**Phase 2: Core Validators (Days 3-5)**
- Implement FilesystemVerificationValidator
- Implement ChecksumValidator
- Implement CompletenessValidator
- Add unit tests for each validator

**Phase 3: Orchestration (Days 5-7)**
- Implement ExportVerificationOrchestrator
- Add integration tests
- Test fail-fast behavior
- Verify report serialization

**Phase 4: Integration (Days 7-9)**
- Integrate into FullExportApplicationService
- Add CLI flag: `--verify-export` (default: false)
- Wire up application input/result extensions
- Add E2E tests

**Phase 5: Stabilization & Rollout (Days 9-10)**
- Fix bugs from integration testing
- Performance profiling
- Update documentation
- Monitor production usage
- Flip default to `--verify-export=true` after 2 weeks

### 7.2 Backward Compatibility

- **Existing Exports**: Verification can run on old exports (manifest format unchanged)
- **CLI Default**: `--verify-export=false` initially; flip to `true` after stabilization
- **Report Format**: Include version field for future schema evolution
- **Graceful Degradation**: If verification fails with exception, log error but don't fail build

### 7.3 Performance Considerations

- **Checksum Buffering**: Use 64KB buffers for large file hashing
- **Async I/O**: All file operations use async APIs
- **Early Exit**: Fail-fast stops orchestrator on critical failure
- **Target**: <5s for 100-entity export, <30s for 1000-entity export
- **Parallelization**: Future enhancement - run independent validators concurrently

---

## 8. JSON Schema for Verification Report

**Location**: `schema/export-verification-report.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Export Verification Report",
  "type": "object",
  "required": ["overallStatus", "verifiedAtUtc", "validationResults", "summary"],
  "properties": {
    "overallStatus": {
      "type": "string",
      "enum": ["Pass", "PassWithWarnings", "Fail", "Incomplete"]
    },
    "verifiedAtUtc": {
      "type": "string",
      "format": "date-time"
    },
    "totalDuration": {
      "type": "string",
      "description": "Duration in ISO 8601 format (e.g., PT2.5S)"
    },
    "validationResults": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["validatorName", "status", "issues"],
        "properties": {
          "validatorName": { "type": "string" },
          "status": {
            "type": "string",
            "enum": ["Pass", "Fail", "Warning", "Skipped"]
          },
          "issues": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["severity", "message"],
              "properties": {
                "severity": {
                  "type": "string",
                  "enum": ["Info", "Warning", "Error", "Critical"]
                },
                "message": { "type": "string" },
                "filePath": { "type": "string" },
                "expectedValue": { "type": "string" },
                "actualValue": { "type": "string" },
                "recommendedAction": { "type": "string" }
              }
            }
          },
          "metadata": {
            "type": "object",
            "properties": {
              "filesVerified": { "type": "integer" },
              "missingFiles": { "type": "integer" },
              "checksumMismatches": { "type": "integer" },
              "expectedEntities": { "type": "integer" },
              "emittedScripts": { "type": "integer" },
              "missingEntities": { "type": "integer" }
            }
          },
          "duration": { "type": "string" }
        }
      }
    },
    "summary": {
      "type": "object",
      "required": [
        "totalValidators", "passedValidators", "failedValidators",
        "totalIssues", "criticalIssues", "filesVerified"
      ],
      "properties": {
        "totalValidators": { "type": "integer" },
        "passedValidators": { "type": "integer" },
        "failedValidators": { "type": "integer" },
        "skippedValidators": { "type": "integer" },
        "totalIssues": { "type": "integer" },
        "criticalIssues": { "type": "integer" },
        "errors": { "type": "integer" },
        "warnings": { "type": "integer" },
        "filesVerified": { "type": "integer" },
        "missingFiles": { "type": "integer" },
        "checksumMismatches": { "type": "integer" }
      }
    },
    "manifestPath": { "type": "string" },
    "outputRoot": { "type": "string" }
  }
}
```

---

## 9. Open Questions & Future Enhancements

### 9.1 Resolved Decisions

1. **Checksum Algorithm**: SHA256 (industry standard, adequate for file integrity)
2. **Validator Lifetime**: Scoped (allows ILogger injection)
3. **Fail-Fast vs. Complete**: Fail-fast on critical issues (operator feedback friendly)
4. **Verification Timing**: Post-manifest (avoids async cascade)
5. **Orphan Detection**: Deferred to v2 (requires complex directory scanning)

### 9.2 Future Enhancements (M1.1.1+)

1. **Checksum Caching**: Persist checksums to `export-fingerprints.json`, compare on subsequent runs
2. **Parallel Validators**: Run independent validators concurrently for perf
3. **Orphan Detection**: Add directory scanner with configurable patterns
4. **Incremental Verification**: Support verifying only changed artifacts
5. **Remote Storage**: Support verifying exports on S3/Azure Blob

---

## 10. Success Criteria

✅ **Functional**
- All 4 core validators implemented and passing tests
- Orchestrator executes validators in priority order, fails fast on critical issues
- Verification report serializes to valid JSON
- Integration with FullExportApplicationService complete
- CLI flag `--verify-export` works end-to-end

✅ **Quality**
- Unit test coverage >90% for validators
- Integration tests cover happy path + 3 failure modes
- E2E test proves end-to-end verification works

✅ **Performance**
- Verification completes in <5s for 100-entity export
- Checksum computation uses buffered async I/O
- No memory leaks with large files (100MB+)

✅ **Documentation**
- JSON schema published for verification report
- Integration guide updated in this spec
- Migration path documented

---

## 11. Related Specifications

- **M1.2**: Topological proof generation (adds TopologicalOrderValidator)
- **M1.3**: Data integrity verification (adds DataIntegrityValidator)
- **M3.1**: Manifest extensions for UAT-users (adds UatUsersVerificationValidator)

---

*Specification Author: Claude (AI Assistant)*
*Last Updated: 2025-11-18 (Revised after codebase walkthrough)*
*Status: Ready for Implementation*
