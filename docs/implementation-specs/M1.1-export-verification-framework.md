# M1.1: Full-Export Verification Framework

**Status**: Specification
**Milestone**: M1 - Export Artifact Verification
**Dependencies**: None (foundational)
**Estimated Complexity**: High (8-10 days)

---

## 1. Overview

### 1.1 Purpose

Implement a comprehensive export verification system that validates artifact integrity end-to-end, providing unfailing confidence that exports are complete and correct without re-running pipelines.

### 1.2 Goals

1. **Artifact Integrity**: Prove all declared artifacts exist and match expected fingerprints
2. **Export Completeness**: Validate emitted entity scripts match the model catalog
3. **Filesystem Verification**: Fast-fail when files are missing or corrupted
4. **Audit Trail**: Structured verification reports for compliance and debugging
5. **Manifest-Driven**: All verification driven by `FullExportRunManifest` metadata

### 1.3 Non-Goals

- **Runtime verification** (not build-time proof generation)
- **Schema validation** (covered by SSDT import tests in M1.4)
- **Data integrity** (covered by M1.3)
- **Topological verification** (covered by M1.2)

---

## 2. Architecture

### 2.1 Component Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    FullExportVerb                           │
│  (orchestrates verification during full-export execution)   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     │ creates
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              ExportVerificationContext                       │
│  • Manifest reference                                        │
│  • Artifact catalog (dynamic + static seed)                  │
│  • Output root paths                                         │
│  • Stage fingerprints (extraction, profile, emission)        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     │ feeds
                     ▼
┌─────────────────────────────────────────────────────────────┐
│           ExportVerificationOrchestrator                     │
│  • Coordinates verification pipeline                         │
│  • Executes validators in dependency order                   │
│  • Aggregates results into verification report               │
└────────────────────┬────────────────────────────────────────┘
                     │
                     │ invokes
                     ▼
┌──────────────────────────────────────────────────┬──────────┐
│         IExportValidator Interface               │          │
│  • ValidateAsync(context) -> ValidationResult    │          │
└──────────────────────────────────────────────────┘          │
                     │                                         │
        ┌────────────┼──────────────┬────────────┐            │
        ▼            ▼              ▼            ▼            │
┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│ Checksum │  │ Manifest │  │ Complete-│  │ Artifact │      │
│ Validator│  │ Validator│  │   ness   │  │   Size   │      │
│          │  │          │  │ Validator│  │ Validator│      │
└──────────┘  └──────────┘  └──────────┘  └──────────┘      │
                                                              │
                     │                                         │
                     │ produces                                │
                     ▼                                         │
┌─────────────────────────────────────────────────────────────┐
│           ExportVerificationReport                           │
│  • Overall pass/fail status                                  │
│  • Per-stage verification results                            │
│  • Missing files / checksum mismatches                       │
│  • Orphaned files (emitted but not declared)                 │
│  • Recommended remediation actions                           │
│  • Serialized to: export-validation.json                     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Design Principles

1. **Fail-Fast**: Stop on first critical error (missing DDL, corrupted manifest)
2. **Informative Failures**: Include file paths, expected vs. actual hashes, line numbers
3. **Idempotent**: Running verification multiple times produces identical results
4. **Performance**: Verification completes in <5s for typical exports (100 entities)
5. **Extensible**: Easy to add new validators without changing orchestrator

---

## 3. Data Models

### 3.1 ExportVerificationContext

**Location**: `src/Osm.Pipeline/Verification/ExportVerificationContext.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Immutable context providing all inputs needed for export verification.
/// Created by FullExportVerb after successful emission.
/// </summary>
public sealed record ExportVerificationContext(
    /// <summary>
    /// The manifest produced by full-export, containing artifact catalog
    /// </summary>
    FullExportRunManifest Manifest,

    /// <summary>
    /// Root output directory for SSDT artifacts
    /// </summary>
    string OutputRoot,

    /// <summary>
    /// Optional: fingerprints per stage for hash verification
    /// </summary>
    ImmutableDictionary<string, StageFingerprint> StageFingerprints,

    /// <summary>
    /// Entity catalog from model (for completeness validation)
    /// </summary>
    ImmutableArray<EntityCatalogEntry> EntityCatalog,

    /// <summary>
    /// Timestamp when verification started
    /// </summary>
    DateTimeOffset VerificationStartedAtUtc
)
{
    public static ExportVerificationContext Create(
        FullExportRunManifest manifest,
        string outputRoot,
        OsmModel model,
        TimeProvider timeProvider)
    {
        var entityCatalog = BuildEntityCatalog(model);
        var stageFingerprints = ComputeStageFingerprints(manifest);

        return new ExportVerificationContext(
            manifest,
            outputRoot,
            stageFingerprints,
            entityCatalog,
            timeProvider.GetUtcNow());
    }

    private static ImmutableArray<EntityCatalogEntry> BuildEntityCatalog(OsmModel model)
    {
        // Extract all entities from model as catalog for completeness checking
        // Maps: Module.Entity -> expected physical table name
    }

    private static ImmutableDictionary<string, StageFingerprint> ComputeStageFingerprints(
        FullExportRunManifest manifest)
    {
        // Extract fingerprints from manifest stages
        // Used for hash verification of emitted files
    }
}

/// <summary>
/// Catalog entry representing an expected entity in the export
/// </summary>
public sealed record EntityCatalogEntry(
    string Module,
    string LogicalName,
    string Schema,
    string PhysicalTableName,
    bool ExpectsStaticSeed,
    bool ExpectsDynamicData
);

/// <summary>
/// Fingerprint metadata per export stage (extraction, profile, build, etc.)
/// </summary>
public sealed record StageFingerprint(
    string StageName,
    string? Hash,
    int? RowCount,
    int? EntityCount,
    DateTimeOffset? CapturedAtUtc
);
```

### 3.2 IExportValidator Interface

**Location**: `src/Osm.Pipeline/Verification/IExportValidator.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Contract for validators that verify specific aspects of export integrity.
/// Implementations should be stateless and thread-safe.
/// </summary>
public interface IExportValidator
{
    /// <summary>
    /// Unique identifier for this validator (e.g., "checksum", "manifest-integrity")
    /// </summary>
    string ValidatorName { get; }

    /// <summary>
    /// Human-readable description of what this validator checks
    /// </summary>
    string Description { get; }

    /// <summary>
    /// Execution order hint (lower runs first). Critical validators = 0-100.
    /// </summary>
    int Priority { get; }

    /// <summary>
    /// Execute validation against the export context.
    /// Should return quickly (&lt;1s for typical exports).
    /// </summary>
    Task<ValidationResult> ValidateAsync(
        ExportVerificationContext context,
        CancellationToken cancellationToken = default);
}
```

### 3.3 ValidationResult

**Location**: `src/Osm.Pipeline/Verification/ValidationResult.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Result from a single validator execution
/// </summary>
public sealed record ValidationResult(
    string ValidatorName,
    ValidationStatus Status,
    ImmutableArray<ValidationIssue> Issues,
    ImmutableDictionary<string, object?>? Metadata = null,
    TimeSpan? Duration = null
)
{
    public static ValidationResult Success(
        string validatorName,
        TimeSpan? duration = null,
        ImmutableDictionary<string, object?>? metadata = null)
        => new(validatorName, ValidationStatus.Pass, ImmutableArray<ValidationIssue>.Empty, metadata, duration);

    public static ValidationResult Failure(
        string validatorName,
        ImmutableArray<ValidationIssue> issues,
        TimeSpan? duration = null)
        => new(validatorName, ValidationStatus.Fail, issues, null, duration);

    public bool IsSuccess => Status == ValidationStatus.Pass;
    public bool HasCriticalIssues => Issues.Any(i => i.Severity == IssueSeverity.Critical);
}

public enum ValidationStatus
{
    Pass,
    Fail,
    Warning,
    Skipped
}

/// <summary>
/// Specific issue discovered during validation
/// </summary>
public sealed record ValidationIssue(
    IssueSeverity Severity,
    string Message,
    string? FilePath = null,
    string? ExpectedValue = null,
    string? ActualValue = null,
    string? RecommendedAction = null
);

public enum IssueSeverity
{
    Info,       // Informational only
    Warning,    // Should investigate but not blocking
    Error,      // Blocking issue but export may be usable
    Critical    // Export is invalid and must not be deployed
}
```

### 3.4 ExportVerificationReport

**Location**: `src/Osm.Pipeline/Verification/ExportVerificationReport.cs`

```csharp
namespace Osm.Pipeline.Verification;

/// <summary>
/// Comprehensive verification report aggregating all validator results.
/// Serialized to export-validation.json alongside manifest.
/// </summary>
public sealed record ExportVerificationReport(
    /// <summary>
    /// Overall verification status (rolls up all validators)
    /// </summary>
    VerificationStatus OverallStatus,

    /// <summary>
    /// When verification was executed
    /// </summary>
    DateTimeOffset VerifiedAtUtc,

    /// <summary>
    /// Total time spent on verification
    /// </summary>
    TimeSpan TotalDuration,

    /// <summary>
    /// Results from individual validators (ordered by execution)
    /// </summary>
    ImmutableArray<ValidationResult> ValidationResults,

    /// <summary>
    /// Summary statistics
    /// </summary>
    VerificationSummary Summary,

    /// <summary>
    /// Manifest reference (path to manifest that was verified)
    /// </summary>
    string ManifestPath,

    /// <summary>
    /// Output root that was verified
    /// </summary>
    string OutputRoot
)
{
    public bool IsSuccess => OverallStatus == VerificationStatus.Pass;

    public IEnumerable<ValidationIssue> AllIssues =>
        ValidationResults.SelectMany(r => r.Issues);

    public IEnumerable<ValidationIssue> CriticalIssues =>
        AllIssues.Where(i => i.Severity == IssueSeverity.Critical);
}

public enum VerificationStatus
{
    Pass,           // All validators passed
    PassWithWarnings, // All critical checks passed but warnings exist
    Fail,           // One or more validators failed
    Incomplete      // Verification could not complete (missing inputs)
}

/// <summary>
/// High-level verification statistics
/// </summary>
public sealed record VerificationSummary(
    int TotalValidators,
    int PassedValidators,
    int FailedValidators,
    int SkippedValidators,
    int TotalIssues,
    int CriticalIssues,
    int Errors,
    int Warnings,
    int FilesVerified,
    int MissingFiles,
    int ChecksumMismatches,
    int OrphanedFiles
);
```

---

## 4. Implementation Details

### 4.1 Core Validators

#### 4.1.1 ManifestIntegrityValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/ManifestIntegrityValidator.cs`

**Priority**: 0 (runs first - critical prerequisite)

**Purpose**: Validates that `DynamicArtifacts` and `StaticSeedArtifacts` collections are consistent with manifest stages.

**Checks**:
- Manifest is not null/empty
- All declared artifacts have valid paths (absolute, non-empty)
- Stage collection contains expected stages (extract-model, build-ssdt, etc.)
- No duplicate artifact names
- Artifact content types are valid
- Stage artifacts reference only declared files

**Pseudocode**:
```csharp
public async Task<ValidationResult> ValidateAsync(
    ExportVerificationContext context,
    CancellationToken ct)
{
    var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
    var manifest = context.Manifest;

    // Check 1: Manifest basics
    if (manifest.Stages.IsDefaultOrEmpty)
    {
        issues.Add(Critical("Manifest contains no stages"));
        return Failure(issues);
    }

    // Check 2: Artifact path validity
    foreach (var artifact in manifest.DynamicArtifacts.Concat(manifest.StaticSeedArtifacts))
    {
        if (string.IsNullOrWhiteSpace(artifact.Path))
        {
            issues.Add(Critical($"Artifact '{artifact.Name}' has empty path"));
        }
        else if (!Path.IsPathFullyQualified(artifact.Path))
        {
            issues.Add(Error($"Artifact '{artifact.Name}' has relative path: {artifact.Path}"));
        }
    }

    // Check 3: Stage consistency
    var expectedStages = new[] { "extract-model", "build-ssdt" };
    foreach (var expected in expectedStages)
    {
        if (!manifest.Stages.Any(s => s.Name == expected))
        {
            issues.Add(Warning($"Expected stage '{expected}' not found in manifest"));
        }
    }

    // Check 4: Artifact uniqueness
    var names = manifest.DynamicArtifacts.Select(a => a.Name).ToList();
    var duplicates = names.GroupBy(n => n).Where(g => g.Count() > 1);
    foreach (var dup in duplicates)
    {
        issues.Add(Error($"Duplicate artifact name: {dup.Key}"));
    }

    return issues.Count == 0 ? Success() : Failure(issues);
}
```

#### 4.1.2 FilesystemVerificationValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/FilesystemVerificationValidator.cs`

**Priority**: 10 (runs early)

**Purpose**: Proves all declared artifacts exist on filesystem with expected characteristics.

**Checks**:
- Every artifact in `DynamicArtifacts` exists
- Every artifact in `StaticSeedArtifacts` exists
- File sizes are reasonable (>0 bytes for scripts, <100MB for manifests)
- File timestamps are after manifest generation time (consistency check)
- Optional: detect orphaned files (files in output directory not declared in manifest)

**Pseudocode**:
```csharp
public async Task<ValidationResult> ValidateAsync(
    ExportVerificationContext context,
    CancellationToken ct)
{
    var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
    var manifest = context.Manifest;
    var filesVerified = 0;
    var missingFiles = 0;

    // Verify dynamic artifacts
    foreach (var artifact in manifest.DynamicArtifacts)
    {
        var fullPath = ResolveArtifactPath(artifact.Path, context.OutputRoot);

        if (!File.Exists(fullPath))
        {
            issues.Add(Critical(
                $"Missing artifact: {artifact.Name}",
                filePath: fullPath,
                recommendedAction: "Re-run full-export to regenerate missing artifacts"));
            missingFiles++;
            continue;
        }

        var fileInfo = new FileInfo(fullPath);

        // Size validation
        if (fileInfo.Length == 0)
        {
            issues.Add(Error(
                $"Artifact is empty: {artifact.Name}",
                filePath: fullPath));
        }
        else if (fileInfo.Length > 100_000_000) // 100MB
        {
            issues.Add(Warning(
                $"Artifact is unusually large: {artifact.Name} ({fileInfo.Length / 1_000_000}MB)",
                filePath: fullPath));
        }

        // Timestamp validation (should be recent)
        if (manifest.GeneratedAtUtc != DateTimeOffset.MinValue)
        {
            var manifestTime = manifest.GeneratedAtUtc;
            var fileTime = fileInfo.LastWriteTimeUtc;

            if (fileTime < manifestTime.AddMinutes(-5)) // Allow 5min clock skew
            {
                issues.Add(Warning(
                    $"Artifact is older than manifest: {artifact.Name}",
                    filePath: fullPath,
                    expectedValue: manifestTime.ToString("O"),
                    actualValue: fileTime.ToString("O")));
            }
        }

        filesVerified++;
    }

    // Repeat for static seed artifacts...

    var metadata = ImmutableDictionary.CreateBuilder<string, object?>();
    metadata["filesVerified"] = filesVerified;
    metadata["missingFiles"] = missingFiles;

    return issues.Count == 0
        ? Success(metadata: metadata.ToImmutable())
        : Failure(issues);
}
```

#### 4.1.3 ChecksumValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/ChecksumValidator.cs`

**Priority**: 20

**Purpose**: Validates artifact integrity using SHA256 checksums stored in manifest.

**Extension Required**: Modify `FullExportRunManifest` to capture per-stage hashes.

**Checks**:
- Compute SHA256 hash of each emitted artifact
- Compare against hash stored in manifest (if present)
- Report mismatches as critical errors
- If manifest doesn't contain hashes, skip gracefully with warning

**Pseudocode**:
```csharp
public async Task<ValidationResult> ValidateAsync(
    ExportVerificationContext context,
    CancellationToken ct)
{
    if (!context.StageFingerprints.Any(f => !string.IsNullOrEmpty(f.Value.Hash)))
    {
        // No checksums in manifest, skip validation
        return ValidationResult.Success(ValidatorName, metadata:
            ImmutableDictionary.Create<string, object?>()
                .Add("reason", "No checksums in manifest"));
    }

    var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
    var checksumMismatches = 0;

    foreach (var (stageName, fingerprint) in context.StageFingerprints)
    {
        if (string.IsNullOrWhiteSpace(fingerprint.Hash))
            continue;

        // Find corresponding artifact
        var artifact = FindArtifactForStage(context.Manifest, stageName);
        if (artifact == null)
            continue;

        var filePath = ResolveArtifactPath(artifact.Path, context.OutputRoot);
        if (!File.Exists(filePath))
        {
            // Already reported by FilesystemVerificationValidator
            continue;
        }

        var actualHash = await ComputeSha256Async(filePath, ct);

        if (!string.Equals(actualHash, fingerprint.Hash, StringComparison.OrdinalIgnoreCase))
        {
            issues.Add(Critical(
                $"Checksum mismatch for {stageName} artifact",
                filePath: filePath,
                expectedValue: fingerprint.Hash,
                actualValue: actualHash,
                recommendedAction: "File may be corrupted; re-run full-export"));
            checksumMismatches++;
        }
    }

    var metadata = ImmutableDictionary.Create<string, object?>()
        .Add("checksumMismatches", checksumMismatches);

    return issues.Count == 0 ? Success(metadata: metadata) : Failure(issues);
}

private async Task<string> ComputeSha256Async(string filePath, CancellationToken ct)
{
    using var stream = File.OpenRead(filePath);
    using var sha256 = SHA256.Create();
    var hashBytes = await sha256.ComputeHashAsync(stream, ct);
    return Convert.ToHexString(hashBytes);
}
```

#### 4.1.4 CompletenessValidator

**Location**: `src/Osm.Pipeline/Verification/Validators/CompletenessValidator.cs`

**Priority**: 30

**Purpose**: Proves every entity in the model has corresponding emitted artifacts (no missing entities).

**Checks**:
- Cross-reference `EntityCatalog` (from model) against emitted dynamic INSERT scripts
- Ensure every entity with data has a `*.dynamic.sql` file
- Ensure every static seed entity has a corresponding seed script
- Detect orphaned scripts (emitted but not in model)

**Pseudocode**:
```csharp
public async Task<ValidationResult> ValidateAsync(
    ExportVerificationContext context,
    CancellationToken ct)
{
    var issues = ImmutableArray.CreateBuilder<ValidationIssue>();
    var manifest = context.Manifest;

    // Find dynamic-insert stage
    var dynamicStage = manifest.Stages.FirstOrDefault(s => s.Name == "dynamic-insert");
    if (dynamicStage == null)
    {
        // No dynamic data expected
        return Success(metadata: ImmutableDictionary.Create<string, object?>()
            .Add("reason", "No dynamic-insert stage in manifest"));
    }

    // Extract emitted scripts from manifest
    var emittedScripts = ExtractScriptPaths(dynamicStage);
    var emittedEntities = emittedScripts
        .Select(path => ExtractEntityNameFromScriptPath(path))
        .ToHashSet(StringComparer.OrdinalIgnoreCase);

    // Check: every catalog entry expecting dynamic data has a script
    var missingEntities = context.EntityCatalog
        .Where(e => e.ExpectsDynamicData)
        .Where(e => !emittedEntities.Contains(e.PhysicalTableName))
        .ToList();

    foreach (var missing in missingEntities)
    {
        issues.Add(Error(
            $"Missing dynamic script for entity: {missing.Module}.{missing.LogicalName}",
            expectedValue: $"{missing.PhysicalTableName}.dynamic.sql",
            recommendedAction: "Verify entity has data; re-run full-export if needed"));
    }

    // Check: detect orphaned scripts (emitted but not in catalog)
    var catalogEntities = context.EntityCatalog
        .Select(e => e.PhysicalTableName)
        .ToHashSet(StringComparer.OrdinalIgnoreCase);

    var orphanedScripts = emittedEntities
        .Where(e => !catalogEntities.Contains(e))
        .ToList();

    foreach (var orphan in orphanedScripts)
    {
        issues.Add(Warning(
            $"Orphaned script (not in model catalog): {orphan}.dynamic.sql",
            recommendedAction: "Verify model extraction included all entities"));
    }

    var metadata = ImmutableDictionary.Create<string, object?>()
        .Add("expectedEntities", context.EntityCatalog.Length)
        .Add("emittedScripts", emittedEntities.Count)
        .Add("missingEntities", missingEntities.Count)
        .Add("orphanedScripts", orphanedScripts.Count);

    return issues.Count == 0 ? Success(metadata: metadata) : Failure(issues);
}
```

### 4.2 ExportVerificationOrchestrator

**Location**: `src/Osm.Pipeline/Verification/ExportVerificationOrchestrator.cs`

**Purpose**: Coordinates validator execution and aggregates results.

**Key Responsibilities**:
1. Register validators (DI or explicit collection)
2. Sort validators by priority
3. Execute validators sequentially (respect dependencies)
4. Aggregate results into `ExportVerificationReport`
5. Serialize report to `export-validation.json`

**Pseudocode**:
```csharp
public sealed class ExportVerificationOrchestrator
{
    private readonly ImmutableArray<IExportValidator> _validators;
    private readonly ILogger<ExportVerificationOrchestrator> _logger;

    public ExportVerificationOrchestrator(
        IEnumerable<IExportValidator> validators,
        ILogger<ExportVerificationOrchestrator> logger)
    {
        _validators = validators
            .OrderBy(v => v.Priority)
            .ToImmutableArray();
        _logger = logger;
    }

    public async Task<ExportVerificationReport> VerifyAsync(
        ExportVerificationContext context,
        CancellationToken ct = default)
    {
        var startTime = Stopwatch.GetTimestamp();
        var results = ImmutableArray.CreateBuilder<ValidationResult>();

        _logger.LogInformation(
            "Starting export verification with {ValidatorCount} validators",
            _validators.Length);

        foreach (var validator in _validators)
        {
            _logger.LogDebug(
                "Executing validator: {ValidatorName} (priority: {Priority})",
                validator.ValidatorName,
                validator.Priority);

            var validatorStart = Stopwatch.GetTimestamp();

            try
            {
                var result = await validator.ValidateAsync(context, ct);
                results.Add(result);

                var elapsed = Stopwatch.GetElapsedTime(validatorStart);
                _logger.LogInformation(
                    "Validator {ValidatorName} completed: {Status} ({Duration}ms)",
                    validator.ValidatorName,
                    result.Status,
                    elapsed.TotalMilliseconds);

                // Fail-fast on critical issues
                if (result.HasCriticalIssues)
                {
                    _logger.LogError(
                        "Validator {ValidatorName} found critical issues; aborting verification",
                        validator.ValidatorName);
                    break;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex,
                    "Validator {ValidatorName} threw exception",
                    validator.ValidatorName);

                results.Add(ValidationResult.Failure(
                    validator.ValidatorName,
                    ImmutableArray.Create(new ValidationIssue(
                        IssueSeverity.Critical,
                        $"Validator threw exception: {ex.Message}"))));
                break;
            }
        }

        var totalDuration = Stopwatch.GetElapsedTime(startTime);
        var report = BuildReport(
            context,
            results.ToImmutable(),
            totalDuration);

        return report;
    }

    private ExportVerificationReport BuildReport(
        ExportVerificationContext context,
        ImmutableArray<ValidationResult> results,
        TimeSpan totalDuration)
    {
        var summary = BuildSummary(results);
        var overallStatus = DetermineOverallStatus(results);

        return new ExportVerificationReport(
            overallStatus,
            context.VerificationStartedAtUtc,
            totalDuration,
            results,
            summary,
            ManifestPath: Path.Combine(context.OutputRoot, "full-export-manifest.json"),
            context.OutputRoot);
    }

    private VerificationSummary BuildSummary(ImmutableArray<ValidationResult> results)
    {
        var totalIssues = results.SelectMany(r => r.Issues).ToList();

        return new VerificationSummary(
            TotalValidators: results.Length,
            PassedValidators: results.Count(r => r.Status == ValidationStatus.Pass),
            FailedValidators: results.Count(r => r.Status == ValidationStatus.Fail),
            SkippedValidators: results.Count(r => r.Status == ValidationStatus.Skipped),
            TotalIssues: totalIssues.Count,
            CriticalIssues: totalIssues.Count(i => i.Severity == IssueSeverity.Critical),
            Errors: totalIssues.Count(i => i.Severity == IssueSeverity.Error),
            Warnings: totalIssues.Count(i => i.Severity == IssueSeverity.Warning),
            FilesVerified: ExtractMetric(results, "filesVerified"),
            MissingFiles: ExtractMetric(results, "missingFiles"),
            ChecksumMismatches: ExtractMetric(results, "checksumMismatches"),
            OrphanedFiles: ExtractMetric(results, "orphanedFiles"));
    }

    private VerificationStatus DetermineOverallStatus(ImmutableArray<ValidationResult> results)
    {
        if (results.Any(r => r.Status == ValidationStatus.Fail || r.HasCriticalIssues))
            return VerificationStatus.Fail;

        if (results.SelectMany(r => r.Issues).Any(i => i.Severity == IssueSeverity.Warning))
            return VerificationStatus.PassWithWarnings;

        if (results.Any(r => r.Status == ValidationStatus.Skipped))
            return VerificationStatus.Incomplete;

        return VerificationStatus.Pass;
    }
}
```

---

## 5. Integration Points

### 5.1 FullExportVerb Integration

**Location**: `src/Osm.Pipeline/Runtime/Verbs/FullExportVerb.cs`

**Modification**: Add verification step after successful emission.

```csharp
// In FullExportVerb.ExecuteAsync()

// ... existing emission logic ...

// NEW: Run verification
if (options.EnableVerification) // new CLI flag: --enable-verification
{
    var verificationContext = ExportVerificationContext.Create(
        manifest,
        outputRoot,
        result.ApplicationResult.Extraction.ExtractionResult.Model,
        _timeProvider);

    var orchestrator = _serviceProvider.GetRequiredService<ExportVerificationOrchestrator>();
    var verificationReport = await orchestrator.VerifyAsync(
        verificationContext,
        cancellationToken);

    // Serialize report
    var reportPath = Path.Combine(outputRoot, "export-validation.json");
    await SerializeReportAsync(verificationReport, reportPath);

    _logger.LogInformation(
        "Export verification completed: {Status} ({IssueCount} issues)",
        verificationReport.OverallStatus,
        verificationReport.Summary.TotalIssues);

    // Fail build if verification failed
    if (verificationReport.OverallStatus == VerificationStatus.Fail)
    {
        throw new InvalidOperationException(
            $"Export verification failed with {verificationReport.Summary.CriticalIssues} critical issues. " +
            $"See {reportPath} for details.");
    }
}
```

### 5.2 FullExportRunManifest Extensions

**Location**: `src/Osm.Pipeline/Runtime/FullExportRunManifest.cs`

**Modification**: Add checksum and metadata fields to support verification.

```csharp
// Add to FullExportStageManifest
public sealed record FullExportStageManifest(
    string Name,
    DateTimeOffset? StartedAtUtc,
    DateTimeOffset? CompletedAtUtc,
    TimeSpan? Duration,
    ImmutableArray<string> Warnings,
    ImmutableDictionary<string, string?> Artifacts,

    // NEW: Checksum for verification
    string? Checksum = null,

    // NEW: Row/entity counts for verification
    int? RowCount = null,
    int? EntityCount = null
);

// Modification to CreateBuildStage / CreateDynamicInsertStage etc.
private static FullExportStageManifest CreateBuildStage(BuildSsdtApplicationResult result)
{
    // ... existing logic ...

    // NEW: Compute checksum of SafeScript.sql if exists
    string? checksum = null;
    if (!string.IsNullOrWhiteSpace(pipelineResult.SafeScriptPath) &&
        File.Exists(pipelineResult.SafeScriptPath))
    {
        checksum = ComputeSha256(pipelineResult.SafeScriptPath);
    }

    return new FullExportStageManifest(
        Name: "build-ssdt",
        // ... existing parameters ...
        Checksum: checksum,
        RowCount: null, // Not applicable for DDL
        EntityCount: pipelineResult.EmittedEntityCount);
}
```

### 5.3 Dependency Injection Setup

**Location**: `src/Osm.Cli/Program.cs` or `src/Osm.Pipeline/PipelineServiceCollectionExtensions.cs`

```csharp
public static IServiceCollection AddExportVerification(this IServiceCollection services)
{
    services.AddSingleton<IExportValidator, ManifestIntegrityValidator>();
    services.AddSingleton<IExportValidator, FilesystemVerificationValidator>();
    services.AddSingleton<IExportValidator, ChecksumValidator>();
    services.AddSingleton<IExportValidator, CompletenessValidator>();

    services.AddSingleton<ExportVerificationOrchestrator>();

    return services;
}
```

---

## 6. Test Scenarios

### 6.1 Unit Tests

**Location**: `tests/Osm.Pipeline.Tests/Verification/`

#### ManifestIntegrityValidatorTests
- `EmptyManifest_ReturnsFailure()`
- `MissingRequiredStages_ReturnsWarning()`
- `DuplicateArtifactNames_ReturnsError()`
- `RelativeArtifactPaths_ReturnsError()`
- `ValidManifest_ReturnsSuccess()`

#### FilesystemVerificationValidatorTests
- `MissingArtifact_ReturnsCriticalFailure()`
- `EmptyArtifact_ReturnsError()`
- `OversizedArtifact_ReturnsWarning()`
- `StaleArtifact_ReturnsWarning()` (older than manifest)
- `AllArtifactsPresent_ReturnsSuccess()`

#### ChecksumValidatorTests
- `ChecksumMismatch_ReturnsCriticalFailure()`
- `NoChecksumsInManifest_ReturnsSkipped()`
- `AllChecksumsMatch_ReturnsSuccess()`

#### CompletenessValidatorTests
- `MissingEntityScript_ReturnsError()`
- `OrphanedScript_ReturnsWarning()`
- `AllEntitiesPresent_ReturnsSuccess()`

### 6.2 Integration Tests

**Location**: `tests/Osm.Pipeline.Integration.Tests/Verification/`

#### ExportVerificationOrchestratorIntegrationTests
- `FullPipeline_WithValidExport_AllValidatorsPass()`
  - Run full-export on fixture
  - Execute orchestrator
  - Assert: OverallStatus = Pass, no issues

- `FullPipeline_WithMissingFile_VerificationFails()`
  - Run full-export
  - Delete one .dynamic.sql file
  - Execute orchestrator
  - Assert: OverallStatus = Fail, MissingFiles > 0

- `FullPipeline_WithCorruptedChecksum_VerificationFails()`
  - Run full-export
  - Modify SafeScript.sql (append comment)
  - Execute orchestrator
  - Assert: ChecksumMismatches > 0

### 6.3 End-to-End Test

**Location**: `tests/Osm.Etl.Integration.Tests/`

#### FullExportWithVerificationE2ETests
```csharp
[Fact]
public async Task FullExport_WithVerificationEnabled_ProducesValidReport()
{
    // Arrange
    var options = CreateFullExportOptions();
    options.EnableVerification = true;

    // Act
    var result = await _fullExportService.ExecuteAsync(options);

    // Assert
    Assert.True(result.Success);

    var reportPath = Path.Combine(options.OutputRoot, "export-validation.json");
    Assert.True(File.Exists(reportPath));

    var report = await DeserializeReportAsync(reportPath);
    Assert.Equal(VerificationStatus.Pass, report.OverallStatus);
    Assert.Empty(report.CriticalIssues);
}
```

---

## 7. Migration Path

### 7.1 Phased Rollout

**Phase 1: Foundation (Week 1)**
- Implement data models (Context, ValidationResult, Report)
- Implement IExportValidator interface
- Implement ManifestIntegrityValidator (simplest validator)
- Add unit tests

**Phase 2: Core Validators (Week 1-2)**
- Implement FilesystemVerificationValidator
- Implement ChecksumValidator (requires manifest extensions)
- Implement CompletenessValidator
- Add unit tests for each

**Phase 3: Orchestration (Week 2)**
- Implement ExportVerificationOrchestrator
- Wire up DI registration
- Add integration tests

**Phase 4: Integration (Week 2)**
- Integrate into FullExportVerb
- Add CLI flag: `--enable-verification` (default: false initially)
- Update FullExportRunManifest with checksums
- Add E2E tests

**Phase 5: Documentation & Rollout (Week 3)**
- Update docs/full-export-artifact-contract.md
- Add operator guide for interpreting verification reports
- Enable `--enable-verification` by default
- Monitor production usage

### 7.2 Backward Compatibility

- **Existing Manifests**: Validators gracefully skip when checksums absent
- **CLI Default**: `--enable-verification=false` initially; flip to `true` after stabilization
- **Report Format**: Version field in report allows future schema evolution

### 7.3 Performance Considerations

- **Checksum Computation**: Use buffered streams (64KB buffers)
- **Parallel Validation**: If validators are independent, run in parallel (future optimization)
- **Early Exit**: Stop on first critical failure (fail-fast)
- **Target**: <5s for 100-entity export, <30s for 1000-entity export

---

## 8. JSON Schema for Verification Report

**Location**: `schema/export-verification-report.schema.json`

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Export Verification Report",
  "type": "object",
  "required": ["overallStatus", "verifiedAtUtc", "validationResults", "summary"],
  "properties": {
    "overallStatus": {
      "type": "string",
      "enum": ["Pass", "PassWithWarnings", "Fail", "Incomplete"]
    },
    "verifiedAtUtc": {
      "type": "string",
      "format": "date-time"
    },
    "totalDuration": {
      "type": "string",
      "description": "Duration in ISO 8601 format (e.g., PT2.5S)"
    },
    "validationResults": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["validatorName", "status", "issues"],
        "properties": {
          "validatorName": { "type": "string" },
          "status": {
            "type": "string",
            "enum": ["Pass", "Fail", "Warning", "Skipped"]
          },
          "issues": {
            "type": "array",
            "items": {
              "type": "object",
              "required": ["severity", "message"],
              "properties": {
                "severity": {
                  "type": "string",
                  "enum": ["Info", "Warning", "Error", "Critical"]
                },
                "message": { "type": "string" },
                "filePath": { "type": "string" },
                "expectedValue": { "type": "string" },
                "actualValue": { "type": "string" },
                "recommendedAction": { "type": "string" }
              }
            }
          },
          "metadata": { "type": "object" },
          "duration": { "type": "string" }
        }
      }
    },
    "summary": {
      "type": "object",
      "required": [
        "totalValidators", "passedValidators", "failedValidators",
        "totalIssues", "criticalIssues", "filesVerified"
      ],
      "properties": {
        "totalValidators": { "type": "integer" },
        "passedValidators": { "type": "integer" },
        "failedValidators": { "type": "integer" },
        "skippedValidators": { "type": "integer" },
        "totalIssues": { "type": "integer" },
        "criticalIssues": { "type": "integer" },
        "errors": { "type": "integer" },
        "warnings": { "type": "integer" },
        "filesVerified": { "type": "integer" },
        "missingFiles": { "type": "integer" },
        "checksumMismatches": { "type": "integer" },
        "orphanedFiles": { "type": "integer" }
      }
    },
    "manifestPath": { "type": "string" },
    "outputRoot": { "type": "string" }
  }
}
```

---

## 9. Open Questions

1. **Checksum Algorithm**: SHA256 sufficient, or need SHA512 for compliance?
2. **Parallel Validation**: Run validators in parallel if no dependencies? (Perf optimization)
3. **Incremental Verification**: Support verifying only changed artifacts? (Future)
4. **Remote Verification**: Support verifying exports on remote filesystems (S3, Azure Blob)?
5. **Retention Policy**: How long to keep verification reports? (Document in operator guide)

---

## 10. Success Criteria

✅ **Functional**
- All 4 core validators implemented and passing tests
- Orchestrator executes validators in priority order
- Verification report serializes to valid JSON
- Integration with FullExportVerb complete

✅ **Quality**
- Unit test coverage >90% for validators
- Integration tests cover happy path + 3 failure modes
- E2E test proves end-to-end verification works

✅ **Performance**
- Verification completes in <5s for 100-entity export
- Checksum computation uses buffered I/O (no OOM on large files)

✅ **Documentation**
- JSON schema published for verification report
- Operator guide explains how to interpret reports
- Migration path documented

---

## 11. Related Specifications

- **M1.2**: Topological proof generation (adds topological validator)
- **M1.3**: Data integrity verification (adds data parity validator)
- **M3.1**: Manifest extensions for UAT-users (adds transformation metadata)

---

*Specification Author: Claude (AI Assistant)*
*Last Updated: 2025-11-18*
*Status: Ready for Implementation*
