# M2.4: UAT-Users Integration Tests

**Status**: DEFERRED VERIFICATION
**Dependencies**: M2.1 (UAT-Users Verification Framework), M2.2 (INSERT Transformation Implementation), M2.3 (Transformation Verification)
**Priority**: üü° Enhanced Quality (ship after M2.2/M2.3 adoption)

---

## Executive Summary

### The Specific Problem

The UAT-users pipeline has **unit tests for individual components** but **lacks comprehensive end-to-end integration tests**. This creates risks:

- **Edge Case Failures**: No tests for empty maps, 100% orphans, GUID user IDs, or unicode user names
- **Idempotence Unknown**: Can't verify rerunning pipeline produces identical artifacts
- **Error Handling Gaps**: Missing files, invalid targets, malformed CSVs may cause unclear failures
- **Full-Export Integration Untested**: `--enable-uat-users` flag integration not verified end-to-end
- **Cross-Mode Consistency Unknown**: Can't verify INSERT and UPDATE modes produce equivalent results

**Current gap**: Unit tests prove individual steps work, but **don't prove the entire pipeline produces correct results** under edge conditions or when integrated with full-export.

**Example**: UAT-users works with simple numeric user IDs (unit tested) but fails with GUID user IDs (not tested). Production uses GUIDs ‚Üí pipeline failure on first run.

### Recommended Solution

**Comprehensive Integration Test Suite**

Build end-to-end integration tests that cover real-world scenarios:

1. **Edge Case Tests**: Empty maps, 100% orphans, no orphans, GUID IDs, unicode names, special characters
2. **Idempotence Tests**: Verify rerunning pipeline produces byte-identical artifacts (stable hashes)
3. **Error Handling Tests**: Malformed CSVs, missing files, invalid targets, DB connection failures
4. **Full-Export Integration Tests**: Verify `--enable-uat-users` works end-to-end with full-export pipeline
5. **Cross-Mode Equivalence Tests**: Prove INSERT and UPDATE modes transform same data identically

Tests use M2.1/M2.3 verifiers as **test oracles** to prove correctness automatically.

### How It Fixes the Problem

1. **Edge Case Coverage**: Catches failures with GUID IDs, unicode, special cases before production
2. **Idempotence Proof**: Verifies deterministic output (critical for version control, CI/CD)
3. **Clear Error Messages**: Tests prove error handling provides actionable diagnostics
4. **Integration Confidence**: Proves full-export integration works end-to-end
5. **Cross-Mode Validation**: Ensures INSERT and UPDATE modes produce equivalent results

### Alternative Approaches Considered

**Alternative 1: Unit Tests Only**
- Just test individual components, skip integration tests
- **Rejected**: Doesn't catch integration bugs, edge cases, or end-to-end failures

**Alternative 2: Manual Testing**
- Rely on manual QA testing before each release
- **Rejected**: Doesn't scale, error-prone, slow feedback, can't catch regressions

**Alternative 3: Production Monitoring**
- Let production usage find bugs, fix reactively
- **Rejected**: Fails too late, wastes deployment time, damages user confidence

**Alternative 4: Sample-Based Testing**
- Test only happy path scenarios, skip edge cases
- **Rejected**: Edge cases are common in production (GUIDs, unicode, empty maps)

**Alternative 5: Database-Only Integration Tests**
- Test by loading to actual database, skip artifact validation
- **Rejected**: Too slow, requires database setup, doesn't test artifact generation

**Why Comprehensive Integration Tests Win**: Fast feedback (file-based), catches edge cases, proves idempotence, automated (runs in CI/CD), provides regression protection.

### Solution Approach

Build **comprehensive integration test suite** that:
- Tests UAT-users pipeline end-to-end with realistic scenarios
- Covers edge cases (empty inventories, 100% orphans, no orphans, etc.)
- Verifies idempotence (rerun produces identical artifacts)
- Tests error handling (missing files, invalid maps, DB connection failures)
- Validates full-export integration (`--enable-uat-users`)
- Uses M2.1/M2.3 verifiers as test oracles

**This provides confidence that UAT-users works correctly under all conditions.**

### MVP Scope (M2.4)

**Ship This First**:
- ‚úÖ End-to-end pipeline tests (discovery ‚Üí validation ‚Üí emission)
- ‚úÖ Edge case tests (empty maps, 100% orphans, no orphans, GUIDs, numeric IDs)
- ‚úÖ Idempotence tests (rerun produces identical output)
- ‚úÖ Error handling tests (malformed CSV, missing files, invalid targets)
- ‚úÖ Full-export integration tests (`--enable-uat-users`)
- ‚úÖ Cross-mode equivalence tests (INSERT vs UPDATE)

**Defer to Later**:
- üîµ Performance/stress tests (10k+ orphans, 1M+ rows) - M4.1
- üîµ Historical regression tests - M4.x

### Key Findings

**Already Exists** ‚úÖ:
- Unit tests for pipeline steps (`tests/Osm.Pipeline.Tests/UatUsers/*Tests.cs`)
- Scenario test (`UatUsersPipelineScenarioTests.cs` - 1 test)
- Test fixtures in `tests/Fixtures/`

**Missing** ‚ùå:
- Comprehensive edge case coverage
- Idempotence test suite
- Error recovery tests
- Full-export integration tests
- Cross-mode equivalence tests
- Oracle-driven tests (using M2.1/M2.3 verifiers)

---

## Critical Path Analysis

### Why This Matters

**Without integration tests**:
- Edge cases discovered in production (not during development)
- Idempotence bugs cause non-deterministic output
- Error handling gaps cause unclear failures
- Full-export integration issues found late
- No confidence in cross-mode equivalence

**With integration tests**:
- Edge cases caught during CI/CD
- Idempotence proven (artifacts stable across runs)
- Clear error messages for all failure modes
- Full-export integration verified automatically
- Cross-mode equivalence guaranteed

### Timeline Considerations

- M2.4 should ship **after** M2.1/M2.3 (uses verifiers as oracles)
- Recommended before production UAT-users adoption
- Can develop in parallel with M3.* (different domains)

### Dependencies and Parallelization

**Depends On**:
- M2.1 (verification framework - used as test oracle)
- M2.3 (transformation verification - used as test oracle)

**Enables**:
- Confident production rollout of UAT-users
- Regression testing for future changes

**Can Parallel With**:
- M3.* (manifest integration, load harness)

---

## Problem Statement

### Current Behavior

**Existing tests**:
- Individual step tests (ValidateUserMapStepTests, EmitArtifactsStepTests, etc.)
- One end-to-end scenario test (`UatUsersPipelineScenarioTests.BasicScenario`)
- Focused on happy path, minimal edge case coverage

**Gaps**:
- No tests for empty maps, 100% orphans, or zero orphans
- No idempotence verification (artifacts change on rerun?)
- No error handling tests (what if CSV malformed?)
- No full-export integration tests
- No cross-mode equivalence tests (INSERT vs UPDATE)

### Desired State

**Comprehensive test suite** covering:

1. **Edge Cases**:
   - Empty user map (no orphans)
   - 100% orphans (all QA users missing from UAT)
   - Mixed ID types (GUID, numeric, text)
   - Special characters in user names

2. **Idempotence**:
   - Rerun produces identical artifacts (same hash)
   - Timestamps omitted in idempotent mode
   - File modification times unchanged

3. **Error Handling**:
   - Malformed CSV (missing columns, duplicates)
   - Missing files (map file, inventory files)
   - Invalid targets (not in UAT inventory)
   - DB connection failures

4. **Full-Export Integration**:
   - `--enable-uat-users` triggers UAT-users pipeline
   - Artifacts embedded in full-export manifest
   - Transformation applied to INSERT generation

5. **Cross-Mode Equivalence**:
   - Same transformation map produces equivalent INSERT and UPDATE artifacts
   - M2.3 verifier confirms equivalence

### Gap Analysis

| Test Category | Current Coverage | Desired Coverage | Gap |
|---------------|------------------|------------------|-----|
| Edge cases | ~10% | 100% | Need 15+ scenarios |
| Idempotence | 0% | 100% | Need full suite |
| Error handling | ~20% | 100% | Need error scenarios |
| Full-export integration | 0% | 100% | Need integration tests |
| Cross-mode equivalence | 0% | 100% | Need equivalence tests |

---

## Architecture

### Test Structure

```
tests/Osm.Pipeline.Tests/UatUsers/Integration/
  ‚îÇ
  ‚îú‚îÄ‚ñ∫ EdgeCaseTests/
  ‚îÇ   ‚îú‚îÄ EmptyMapTests.cs (no orphans)
  ‚îÇ   ‚îú‚îÄ AllOrphansTests.cs (100% orphans)
  ‚îÇ   ‚îú‚îÄ MixedIdTypeTests.cs (GUID, numeric, text)
  ‚îÇ   ‚îî‚îÄ SpecialCharactersTests.cs (unicode, quotes)
  ‚îÇ
  ‚îú‚îÄ‚ñ∫ IdempotenceTests/
  ‚îÇ   ‚îú‚îÄ RerunIdenticalOutputTests.cs (artifacts unchanged)
  ‚îÇ   ‚îú‚îÄ TimestampOmissionTests.cs (idempotent mode)
  ‚îÇ   ‚îî‚îÄ FileModTimeTests.cs (files not rewritten)
  ‚îÇ
  ‚îú‚îÄ‚ñ∫ ErrorHandlingTests/
  ‚îÇ   ‚îú‚îÄ MalformedCsvTests.cs (missing columns, bad data)
  ‚îÇ   ‚îú‚îÄ MissingFilesTests.cs (file not found errors)
  ‚îÇ   ‚îú‚îÄ InvalidTargetsTests.cs (targets not in UAT)
  ‚îÇ   ‚îî‚îÄ DbConnectionTests.cs (connection failures)
  ‚îÇ
  ‚îú‚îÄ‚ñ∫ FullExportIntegrationTests/
  ‚îÇ   ‚îú‚îÄ EnableUatUsersTests.cs (--enable-uat-users)
  ‚îÇ   ‚îú‚îÄ ManifestIntegrationTests.cs (artifacts in manifest)
  ‚îÇ   ‚îî‚îÄ InsertTransformationTests.cs (transformations in INSERTs)
  ‚îÇ
  ‚îî‚îÄ‚ñ∫ CrossModeEquivalenceTests/
      ‚îú‚îÄ InsertUpdateEquivalenceTests.cs (both modes produce same results)
      ‚îî‚îÄ VerifierOracleTests.cs (M2.3 verifier confirms equivalence)
```

### Test Oracle Pattern

Use M2.1/M2.3 verifiers as test oracles:

```csharp
[Test]
public async Task FullPipeline_HappyPath_PassesVerification()
{
    // Arrange: Run pipeline
    var context = await RunPipelineAsync(...);

    // Act: Verify artifacts using M2.1 verifier
    var verifier = new UatUsersVerifier(...);
    var verificationResult = await verifier.VerifyAsync(context.ArtifactRoot, ...);

    // Assert: Verification passes
    Assert.That(verificationResult.IsValid, Is.True);
    Assert.That(verificationResult.MapVerification.UnmappedCount, Is.EqualTo(0));
}
```

**Pattern**: Every integration test should use M2.1/M2.3 verifiers to prove correctness.

---

## Codebase Integration Guide ‚≠ê

### Existing Infrastructure (Leverage These)

#### ‚úÖ **Existing Scenario Test** - Pattern to Follow
- **File**: `tests/Osm.Pipeline.Tests/UatUsers/UatUsersPipelineScenarioTests.cs`
- **Method**: `BasicScenario()` (single test)
- **Status**: Expand this pattern to cover edge cases
- **Pattern**:
  ```csharp
  [Test]
  public async Task BasicScenario()
  {
      // Arrange: Set up model, inventories, connection
      var model = ...;
      var qaInventory = ...;
      var uatInventory = ...;

      // Act: Run pipeline
      var context = new UatUsersContext(...);
      var pipeline = new UatUsersPipeline();
      await pipeline.ExecuteAsync(context, CancellationToken.None);

      // Assert: Verify artifacts
      Assert.That(context.Artifacts.Exists(...), Is.True);
  }
  ```

#### ‚úÖ **Step Tests** - Reuse Fixtures
- **Files**: `tests/Osm.Pipeline.Tests/UatUsers/*StepTests.cs`
- **Fixtures**: Test data, mock inventories, sample CSVs
- **Status**: Reuse test fixtures for integration tests

#### ‚úÖ **M2.1 Verifier** - Use as Oracle
- **File**: `src/Osm.Pipeline/UatUsers/Verification/UatUsersVerifier.cs` (from M2.1)
- **Status**: Use in integration tests to prove correctness
- **Pattern**: Every test runs verifier and asserts `IsValid == true`

#### ‚úÖ **M2.3 Transformation Verifier** - Use as Oracle
- **File**: `src/Osm.Pipeline/UatUsers/Verification/InsertTransformationVerifier.cs` (from M2.3)
- **Status**: Use in full-export integration tests to verify transformations

---

### Required Changes

#### Change 1: Create Integration Test Infrastructure
**Location**: `tests/Osm.Pipeline.Tests/UatUsers/Integration/` (NEW DIRECTORY)

**Base Class**: `UatUsersIntegrationTestBase.cs`
```csharp
public abstract class UatUsersIntegrationTestBase
{
    protected async Task<UatUsersContext> RunPipelineAsync(
        IUserSchemaGraph schemaGraph,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> qaInventory,
        IReadOnlyDictionary<UserIdentifier, UserInventoryRecord> uatInventory,
        string outputDirectory,
        IReadOnlyList<UserMappingEntry>? userMap = null)
    {
        var artifacts = new UatUsersArtifacts(outputDirectory);
        var context = new UatUsersContext(
            schemaGraph,
            artifacts,
            Mock.Of<IDbConnectionFactory>(),
            "dbo",
            "User",
            "Id",
            null,
            artifacts.GetDefaultUserMapPath(),
            Path.Combine(outputDirectory, "uat_users.csv"),
            Path.Combine(outputDirectory, "qa_users.csv"),
            null,
            null,
            fromLiveMetadata: false,
            "test-fingerprint");

        // Write inventories to disk
        await WriteInventoriesAsync(context, qaInventory, uatInventory);

        // Write user map if provided
        if (userMap != null)
        {
            await WriteUserMapAsync(context, userMap);
        }

        // Run pipeline
        var pipeline = new UatUsersPipeline();
        await pipeline.ExecuteAsync(context, CancellationToken.None);

        return context;
    }

    protected async Task<bool> VerifyArtifactsAsync(string artifactRoot, ...)
    {
        var verifier = new UatUsersVerifier(...);
        var result = await verifier.VerifyAsync(artifactRoot, ...);
        return result.IsValid;
    }
}
```

**Pattern**: Provides common setup/teardown, helper methods for running pipeline and verifying results

---

#### Change 2: Edge Case Tests

**File**: `tests/Osm.Pipeline.Tests/UatUsers/Integration/EdgeCaseTests.cs` (NEW)

```csharp
[TestFixture]
public sealed class EdgeCaseTests : UatUsersIntegrationTestBase
{
    [Test]
    public async Task EmptyMap_NoOrphans_Succeeds()
    {
        // Arrange: QA and UAT inventories identical (no orphans)
        var qaInventory = CreateInventory(new[] { 100, 101, 102 });
        var uatInventory = CreateInventory(new[] { 100, 101, 102 });

        // Act: Run pipeline
        var context = await RunPipelineAsync(..., qaInventory, uatInventory, ...);

        // Assert: No orphans discovered
        Assert.That(context.OrphanUserIds, Is.Empty);
        Assert.That(context.UserMap, Is.Empty);

        // Verify artifacts
        var isValid = await VerifyArtifactsAsync(context.Artifacts.Root, ...);
        Assert.That(isValid, Is.True);
    }

    [Test]
    public async Task AllOrphans_100Percent_Succeeds()
    {
        // Arrange: QA has users [100..200], UAT has users [300..400] (no overlap)
        var qaInventory = CreateInventory(Enumerable.Range(100, 100));
        var uatInventory = CreateInventory(Enumerable.Range(300, 100));

        // Provide complete mapping (100‚Üí300, 101‚Üí301, ...)
        var userMap = Enumerable.Range(0, 100)
            .Select(i => new UserMappingEntry(
                new UserIdentifier(100 + i),
                new UserIdentifier(300 + i),
                "Mapped via test"))
            .ToList();

        // Act: Run pipeline
        var context = await RunPipelineAsync(..., qaInventory, uatInventory, ..., userMap);

        // Assert: All 100 orphans mapped
        Assert.That(context.OrphanUserIds.Count, Is.EqualTo(100));
        Assert.That(context.UserMap.Count, Is.EqualTo(100));

        // Verify transformations
        var transformationVerifier = new InsertTransformationVerifier();
        var result = transformationVerifier.Verify(...);
        Assert.That(result.OrphansEliminated, Is.EqualTo(100));
        Assert.That(result.OrphansRemaining, Is.EqualTo(0));
    }

    [Test]
    public async Task MixedIdTypes_Guid_Succeeds()
    {
        // Arrange: GUID user IDs
        var qaInventory = CreateInventory(new[] {
            Guid.Parse("00000000-0000-0000-0000-000000000001"),
            Guid.Parse("00000000-0000-0000-0000-000000000002")
        });
        var uatInventory = CreateInventory(new[] {
            Guid.Parse("00000000-0000-0000-0000-000000000003"),
            Guid.Parse("00000000-0000-0000-0000-000000000004")
        });

        // Map GUID orphan 001‚Üí003
        var userMap = new[] {
            new UserMappingEntry(
                new UserIdentifier(Guid.Parse("00000000-0000-0000-0000-000000000001")),
                new UserIdentifier(Guid.Parse("00000000-0000-0000-0000-000000000003")),
                "GUID mapping")
        };

        // Act: Run pipeline
        var context = await RunPipelineAsync(..., qaInventory, uatInventory, ..., userMap);

        // Assert: GUID mapping applied
        Assert.That(context.UserMap.Count, Is.EqualTo(1));

        // Verify SQL script uses UNIQUEIDENTIFIER type
        var sqlScript = File.ReadAllText(Path.Combine(context.Artifacts.Root, "uat-users", "02_apply_user_remap.sql"));
        Assert.That(sqlScript, Does.Contain("UNIQUEIDENTIFIER"));
    }

    [Test]
    public async Task SpecialCharacters_Unicode_Succeeds()
    {
        // Arrange: Users with unicode names (√©, √±, ‰∏≠Êñá)
        var qaInventory = CreateInventory(
            new[] { 100 },
            names: new[] { "Jos√© Garc√≠a" });
        var uatInventory = CreateInventory(
            new[] { 200 },
            names: new[] { "Mar√≠a L√≥pez" });

        var userMap = new[] {
            new UserMappingEntry(
                new UserIdentifier(100),
                new UserIdentifier(200),
                "Unicode test: Jos√©‚ÜíMar√≠a")
        };

        // Act: Run pipeline
        var context = await RunPipelineAsync(..., qaInventory, uatInventory, ..., userMap);

        // Assert: Artifacts handle unicode correctly
        var previewCsv = File.ReadAllText(Path.Combine(context.Artifacts.Root, "uat-users", "01_preview.csv"));
        Assert.That(previewCsv, Does.Contain("Jos√© Garc√≠a"));
        Assert.That(previewCsv, Does.Contain("Mar√≠a L√≥pez"));
    }
}
```

**Pattern**: Test edge cases with realistic data, verify using M2.1/M2.3 oracles

---

#### Change 3: Idempotence Tests

**File**: `tests/Osm.Pipeline.Tests/UatUsers/Integration/IdempotenceTests.cs` (NEW)

```csharp
[TestFixture]
public sealed class IdempotenceTests : UatUsersIntegrationTestBase
{
    [Test]
    public async Task Rerun_IdenticalOutput_Succeeds()
    {
        // Arrange: Set up pipeline
        var qaInventory = CreateInventory(new[] { 100, 101 });
        var uatInventory = CreateInventory(new[] { 200, 201 });
        var userMap = new[] {
            new UserMappingEntry(new UserIdentifier(100), new UserIdentifier(200), "Test")
        };

        // Act: Run pipeline twice
        var context1 = await RunPipelineAsync(..., qaInventory, uatInventory, ..., userMap);
        var context2 = await RunPipelineAsync(..., qaInventory, uatInventory, ..., userMap);

        // Assert: Artifacts identical
        var sqlScript1 = File.ReadAllText(Path.Combine(context1.Artifacts.Root, "uat-users", "02_apply_user_remap.sql"));
        var sqlScript2 = File.ReadAllText(Path.Combine(context2.Artifacts.Root, "uat-users", "02_apply_user_remap.sql"));

        // Compare hashes (timestamps omitted in idempotent mode)
        var hash1 = ComputeSha256(sqlScript1);
        var hash2 = ComputeSha256(sqlScript2);
        Assert.That(hash1, Is.EqualTo(hash2));
    }

    [Test]
    public async Task IdempotentEmission_SkipsUnchangedFiles_Succeeds()
    {
        // Arrange: Run pipeline with idempotent emission enabled
        var outputDir = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString());
        var context1 = await RunPipelineAsync(..., idempotentEmission: true);

        var sqlPath = Path.Combine(context1.Artifacts.Root, "uat-users", "02_apply_user_remap.sql");
        var modTime1 = File.GetLastWriteTimeUtc(sqlPath);

        // Wait 1 second
        await Task.Delay(1000);

        // Act: Rerun with same inputs
        var context2 = await RunPipelineAsync(..., idempotentEmission: true);
        var modTime2 = File.GetLastWriteTimeUtc(sqlPath);

        // Assert: File not rewritten (same modification time)
        Assert.That(modTime2, Is.EqualTo(modTime1));
    }
}
```

**Pattern**: Verify deterministic output, hash comparison, file modification time checks

---

#### Change 4: Error Handling Tests

**File**: `tests/Osm.Pipeline.Tests/UatUsers/Integration/ErrorHandlingTests.cs` (NEW)

```csharp
[TestFixture]
public sealed class ErrorHandlingTests : UatUsersIntegrationTestBase
{
    [Test]
    public void MalformedCsv_MissingIdColumn_Throws()
    {
        // Arrange: CSV missing 'Id' column
        var csvPath = Path.Combine(Path.GetTempPath(), "malformed.csv");
        File.WriteAllText(csvPath, "Username,Email\ntest,test@example.com");

        // Act & Assert: Loading CSV throws
        Assert.ThrowsAsync<InvalidOperationException>(async () =>
        {
            await UserInventoryLoader.LoadFromCsvAsync(csvPath);
        });
    }

    [Test]
    public void InvalidTarget_NotInUatInventory_Throws()
    {
        // Arrange: User map with target not in UAT inventory
        var qaInventory = CreateInventory(new[] { 100 });
        var uatInventory = CreateInventory(new[] { 200 });
        var userMap = new[] {
            new UserMappingEntry(
                new UserIdentifier(100),
                new UserIdentifier(999), // 999 not in UAT inventory!
                "Invalid target")
        };

        // Act & Assert: Validation throws
        Assert.ThrowsAsync<InvalidOperationException>(async () =>
        {
            await RunPipelineAsync(..., qaInventory, uatInventory, ..., userMap);
        });
    }

    [Test]
    public void MissingUserMap_RequiredMapping_Throws()
    {
        // Arrange: Orphans discovered but no user map provided
        var qaInventory = CreateInventory(new[] { 100 });
        var uatInventory = CreateInventory(new[] { 200 });

        // Act & Assert: Validation throws (orphan 100 not mapped)
        Assert.ThrowsAsync<InvalidOperationException>(async () =>
        {
            await RunPipelineAsync(..., qaInventory, uatInventory, ..., userMap: null);
        });
    }
}
```

**Pattern**: Test error conditions, verify exceptions thrown with clear messages

---

#### Change 5: Full-Export Integration Tests

**File**: `tests/Osm.Pipeline.Tests/UatUsers/Integration/FullExportIntegrationTests.cs` (NEW)

```csharp
[TestFixture]
public sealed class FullExportIntegrationTests
{
    [Test]
    public async Task EnableUatUsers_ArtifactsInManifest_Succeeds()
    {
        // Arrange: Run full-export with --enable-uat-users
        var request = new FullExportRequest(..., enableUatUsers: true, ...);

        // Act: Run full-export pipeline
        var result = await FullExportPipeline.ExecuteAsync(request, ...);

        // Assert: Manifest includes UAT-users artifacts
        Assert.That(result.Manifest.Stages.Any(s => s.Name == "uat-users"), Is.True);
        Assert.That(result.Manifest.DynamicArtifacts.Any(a => a.Name == "uat-users-map"), Is.True);
    }

    [Test]
    public async Task EnableUatUsers_InsertTransformationsApplied_Succeeds()
    {
        // Arrange: Run full-export with UAT-users enabled
        var request = new FullExportRequest(..., enableUatUsers: true, ...);
        var transformationMap = new Dictionary<UserIdentifier, UserIdentifier>
        {
            [new UserIdentifier(100)] = new UserIdentifier(200)
        };

        // Act: Run full-export
        var result = await FullExportPipeline.ExecuteAsync(request, ...);

        // Assert: INSERT scripts contain transformed values
        var insertScript = File.ReadAllText(result.DynamicInsertScriptPaths.First());
        Assert.That(insertScript, Does.Not.Contain("100")); // Orphan eliminated
        Assert.That(insertScript, Does.Contain("200"));      // Target present

        // Verify using M2.3 transformation verifier
        var verifier = new InsertTransformationVerifier();
        var verificationResult = verifier.Verify(insertScript, ..., transformationMap, ...);
        Assert.That(verificationResult.OrphansRemaining, Is.EqualTo(0));
    }
}
```

**Pattern**: Test full-export integration, verify INSERT transformations using M2.3 oracle

---

#### Change 6: Cross-Mode Equivalence Tests

**File**: `tests/Osm.Pipeline.Tests/UatUsers/Integration/CrossModeEquivalenceTests.cs` (NEW)

```csharp
[TestFixture]
public sealed class CrossModeEquivalenceTests
{
    [Test]
    public async Task InsertUpdateModes_SameTransformations_Succeeds()
    {
        // Arrange: Same transformation map for both modes
        var transformationMap = new Dictionary<UserIdentifier, UserIdentifier>
        {
            [new UserIdentifier(100)] = new UserIdentifier(200),
            [new UserIdentifier(101)] = new UserIdentifier(201)
        };

        // Act 1: Generate INSERT scripts (full-export mode)
        var insertResult = await GenerateInsertScriptsAsync(transformationMap, ...);

        // Act 2: Generate UPDATE scripts (standalone mode)
        var updateResult = await GenerateUpdateScriptsAsync(transformationMap, ...);

        // Assert: M2.3 cross-mode validator confirms equivalence
        var validator = new CrossModeValidator();
        var validationResult = validator.Validate(insertResult, updateResult);

        Assert.That(validationResult.IsValid, Is.True);
        Assert.That(validationResult.TransformationsEquivalent, Is.True);
        Assert.That(validationResult.Discrepancies, Is.Empty);
    }

    [Test]
    public async Task BothModes_NullPreservation_Succeeds()
    {
        // Arrange: Source data with NULLs
        var sourceData = new[] {
            new { Id = 1, CreatedBy = (int?)100 },
            new { Id = 2, CreatedBy = (int?)null }, // NULL
            new { Id = 3, CreatedBy = (int?)101 }
        };

        var transformationMap = new Dictionary<UserIdentifier, UserIdentifier>
        {
            [new UserIdentifier(100)] = new UserIdentifier(200),
            [new UserIdentifier(101)] = new UserIdentifier(201)
        };

        // Act 1: INSERT mode
        var insertScript = await GenerateInsertScriptAsync(sourceData, transformationMap);

        // Act 2: UPDATE mode
        var updateScript = await GenerateUpdateScriptAsync(transformationMap);

        // Assert: Both modes preserve NULLs
        // INSERT: NULL literal in VALUES
        Assert.That(insertScript, Does.Contain("NULL"));

        // UPDATE: WHERE ... IS NOT NULL guard
        Assert.That(updateScript, Does.Contain("WHERE") && Does.Contain("IS NOT NULL"));

        // Verify using M2.3 NULL preservation verifier
        var verifier = new NullPreservationVerifier();
        var insertResult = verifier.Verify(TransformationMode.Insert, insertScript, ...);
        var updateResult = verifier.Verify(TransformationMode.Update, updateScript, ...);

        Assert.That(insertResult.IsValid, Is.True);
        Assert.That(updateResult.IsValid, Is.True);
    }
}
```

**Pattern**: Compare INSERT and UPDATE modes, verify equivalence using M2.3 validators

---

### Testing Infrastructure

**No new infrastructure needed** - uses existing test frameworks and M2.1/M2.3 verifiers.

**Test Execution**:
```bash
# Run all UAT-users integration tests
dotnet test --filter FullyQualifiedName~UatUsers.Integration

# Run specific test category
dotnet test --filter FullyQualifiedName~EdgeCaseTests
dotnet test --filter FullyQualifiedName~IdempotenceTests
```

---

### File Location Quick Reference

**Existing Files to Reference**:
```
tests/Osm.Pipeline.Tests/UatUsers/
  ‚îú‚îÄ UatUsersPipelineScenarioTests.cs (pattern to follow)
  ‚îú‚îÄ ValidateUserMapStepTests.cs (fixtures to reuse)
  ‚îî‚îÄ SqlScriptEmitterTests.cs (test patterns)

src/Osm.Pipeline/UatUsers/Verification/
  ‚îú‚îÄ UatUsersVerifier.cs (M2.1 - use as oracle)
  ‚îú‚îÄ InsertTransformationVerifier.cs (M2.3 - use as oracle)
  ‚îú‚îÄ UpdateScriptSimulator.cs (M2.3 - use as oracle)
  ‚îî‚îÄ CrossModeValidator.cs (M2.3 - use as oracle)
```

**New Files to Create**:
```
tests/Osm.Pipeline.Tests/UatUsers/Integration/
  ‚îú‚îÄ UatUsersIntegrationTestBase.cs (base class)
  ‚îú‚îÄ EdgeCaseTests.cs (empty map, all orphans, GUID, unicode)
  ‚îú‚îÄ IdempotenceTests.cs (rerun, file mod times)
  ‚îú‚îÄ ErrorHandlingTests.cs (malformed CSV, invalid targets)
  ‚îú‚îÄ FullExportIntegrationTests.cs (--enable-uat-users)
  ‚îî‚îÄ CrossModeEquivalenceTests.cs (INSERT vs UPDATE)
```

---

## Implementation Details

### Phase 1: Test Infrastructure

Create `UatUsersIntegrationTestBase.cs`:
- Common setup/teardown
- Helper methods (`RunPipelineAsync`, `VerifyArtifactsAsync`)
- Test fixture generators (`CreateInventory`, `CreateUserMap`)

---

### Phase 2: Edge Case Tests

Implement `EdgeCaseTests.cs`:
- Empty map (no orphans)
- All orphans (100% QA users missing from UAT)
- Mixed ID types (GUID, numeric)
- Special characters (unicode)

---

### Phase 3: Idempotence Tests

Implement `IdempotenceTests.cs`:
- Rerun produces identical output (hash comparison)
- Idempotent emission skips unchanged files (mod time check)

---

### Phase 4: Error Handling Tests

Implement `ErrorHandlingTests.cs`:
- Malformed CSV (missing columns)
- Invalid targets (not in UAT inventory)
- Missing user map (required mappings)

---

### Phase 5: Full-Export Integration Tests

Implement `FullExportIntegrationTests.cs`:
- `--enable-uat-users` triggers pipeline
- Artifacts in manifest
- INSERT transformations applied (verify with M2.3)

---

### Phase 6: Cross-Mode Equivalence Tests

Implement `CrossModeEquivalenceTests.cs`:
- INSERT vs UPDATE equivalence (M2.3 validator)
- NULL preservation (both modes)

---

## Test Scenarios

### Scenario 1: Empty Map (No Orphans)
**Given**: QA and UAT inventories identical
**When**: Run pipeline
**Expected**: No orphans, empty map, artifacts valid

---

### Scenario 2: All Orphans (100%)
**Given**: QA users 100-200, UAT users 300-400 (no overlap)
**When**: Run pipeline with complete mapping
**Expected**: All 100 orphans mapped, transformations applied

---

### Scenario 3: GUID User IDs
**Given**: GUID-based user identifiers
**When**: Run pipeline
**Expected**: SQL uses UNIQUEIDENTIFIER type, transformations work

---

### Scenario 4: Idempotence
**Given**: Run pipeline twice with identical inputs
**When**: Compare artifacts
**Expected**: Identical hashes, file mod times unchanged

---

### Scenario 5: Invalid Target
**Given**: User map maps orphan to ID not in UAT inventory
**When**: Run pipeline
**Expected**: Validation throws clear error

---

### Scenario 6: Full-Export Integration
**Given**: `full-export --enable-uat-users`
**When**: Run full-export
**Expected**: UAT-users artifacts in manifest, INSERT transformations applied

---

### Scenario 7: Cross-Mode Equivalence
**Given**: Same transformation map in both modes
**When**: Generate INSERT and UPDATE scripts
**Expected**: M2.3 validator confirms equivalence

---

## Migration Path

### Non-Breaking Changes
- M2.4 adds tests; doesn't modify production code
- CI/CD can adopt tests incrementally

### Rollout Strategy

**Phase 1**: Deploy test infrastructure
**Phase 2**: Add tests to CI/CD pipeline (required for merges)
**Phase 3**: Expand coverage based on production findings

### Backward Compatibility
- 100% backward compatible (tests only)

---

## Success Metrics

M2.4 is successful if:

‚úÖ 95%+ code coverage for UAT-users pipeline

‚úÖ All edge cases tested (empty map, 100% orphans, GUID, unicode)

‚úÖ Idempotence proven (artifacts deterministic)

‚úÖ Error handling tested (all failure modes have tests)

‚úÖ Full-export integration verified

‚úÖ Cross-mode equivalence proven

‚úÖ CI/CD gates merges on test pass

‚úÖ Tests run in <30 seconds

‚úÖ Zero flaky tests (100% reliable)

---

*Generated: 2025-11-19*
*Status: Ready for implementation*
*Follows M1.*/M2.* spec pattern with comprehensive test strategy*
