# M1.7: Topological Ordering Proof Generation (Full Observability)

**Date**: 2025-11-18
**Status**: DEFERRED - Nice-to-have observability feature
**Dependencies**: M1.0 (Global Topological Ordering), M1.2 (Basic proof validation)
**Priority**: ðŸ”µ Ship when operators request proof artifacts for documentation/auditing

## Executive Summary

This specification defines a **topological ordering proof system** that makes FK dependency ordering observable, verifiable, and debuggable. It generates artifacts that prove the emitted entity order satisfies all FK constraints, enabling operators to:

1. **Verify correctness**: Prove that parent entities appear before child entities
2. **Debug failures**: Understand why FK violations occur (cycles, missing edges, incorrect order)
3. **Visualize dependencies**: See the complete dependency graph for the export
4. **Audit compliance**: Demonstrate that ordering meets business requirements

**Key Artifacts**:
- `ordering-proof.json` - Machine-readable proof with full dependency graph
- `ordering-report.md` - Human-readable report with dependency visualization
- `ordering-violations.json` - Any detected ordering issues (empty on success)

## Problem Statement

### Current State

**M1.0 generates topologically sorted entity orders** but provides limited observability:
- Ordering happens inside `EntityDependencySorter.SortByForeignKeys()`
- Telemetry logs basic metrics (node count, edge count, cycle detected)
- No artifact proving the order is correct
- Debugging FK violations requires manual code inspection

**Example M1.0 Log Output**:
```
staticData.seed.generated: ordering.nodes=42, ordering.edges=87,
  ordering.cycleDetected=false, ordering.fallbackApplied=false
```

**Questions operators cannot answer**:
- Which specific FKs created the dependency edges?
- What is the complete dependency graph?
- Why did entity X come before entity Y?
- If a cycle was detected, which entities are in the cycle?
- What is the topological depth of each entity?

### Proposed Solution

**Emit proof artifacts** alongside the ordered data files that:

1. **Document every dependency**: Record all FK relationships that influenced ordering
2. **Prove ordering correctness**: For each entity, list all dependencies and verify they appear earlier
3. **Detect violations**: Flag any FK dependencies where child appears before parent
4. **Visualize graph**: Generate human-readable dependency tree/graph
5. **Enable debugging**: Provide actionable diagnostics for cycles, missing edges, and ordering violations

**Workflow**:
```
1. EntityDependencySorter.SortByForeignKeys() runs (M1.0)
2. TopologicalProofGenerator captures ordering metadata
3. Proof artifacts emitted to {OutputDirectory}/Proofs/
4. Operators inspect proof to verify correctness
5. If violations exist, report shows exact FK causing issue
```

## Architecture

### Component Overview

```
BuildSsdtBootstrapSnapshotStep (M1.0)
  â†“ (uses)
EntityDependencySorter.SortByForeignKeys()
  â†“ (produces)
EntityDependencySortResult {
  Tables: ImmutableArray<StaticEntityTableData>
  TopologicalOrderingApplied: bool
  Mode: EntityDependencyOrderingMode
  NodeCount, EdgeCount, MissingEdgeCount, CycleDetected, etc.
}
  â†“ (consumed by - NEW)
TopologicalProofGenerator
  â†“ (emits)
Proof Artifacts:
  - ordering-proof.json
  - ordering-report.md
  - ordering-violations.json (if issues detected)
```

### Data Models

#### OrderingProof (JSON artifact)

```csharp
public sealed record OrderingProof(
    OrderingProofMetadata Metadata,
    ImmutableArray<EntityOrderingProofEntry> Entities,
    ImmutableArray<DependencyEdge> Dependencies,
    ImmutableArray<OrderingViolation> Violations,
    GraphStatistics Statistics);

public sealed record OrderingProofMetadata(
    string GeneratedUtc,
    string Algorithm,  // "Kahn" or "Alphabetical"
    bool TopologicalOrderingApplied,
    bool CycleDetected,
    bool AlphabeticalFallbackApplied,
    int TotalEntities,
    string Context);  // "BootstrapSnapshot", "StaticSeeds", "DynamicData"

public sealed record EntityOrderingProofEntry(
    int TopologicalPosition,  // 0-based index in final order
    string Schema,
    string TableName,
    string Module,
    bool IsStatic,
    int TopologicalDepth,  // Max dependency chain length to this node
    ImmutableArray<string> DirectDependencies,  // Tables this entity depends on
    ImmutableArray<string> DirectDependents,   // Tables that depend on this entity
    ImmutableArray<DependencyChain> CriticalPaths);  // Longest dependency chains

public sealed record DependencyEdge(
    string SourceSchema,
    string SourceTable,
    string TargetSchema,
    string TargetTable,
    string ConstraintName,
    ImmutableArray<ForeignKeyColumn> Columns,
    EdgeClassification Classification);

public enum EdgeClassification
{
    Normal,           // Regular FK dependency
    SelfReferencing,  // FK to same table
    Junction,         // Part of many-to-many junction table
    CrossBoundary,    // Static â†’ Regular or vice versa
    Missing           // FK exists in model but target entity not in dataset
}

public sealed record DependencyChain(
    ImmutableArray<string> Path,  // ["Role", "User", "Session"]
    int Length);

public sealed record OrderingViolation(
    string ViolationType,  // "ChildBeforeParent", "MissingParent", "CycleDetected"
    string ChildSchema,
    string ChildTable,
    int ChildPosition,
    string ParentSchema,
    string ParentTable,
    int ParentPosition,  // -1 if missing
    string ConstraintName,
    string Explanation);

public sealed record GraphStatistics(
    int TotalNodes,
    int TotalEdges,
    int MissingEdges,
    int ConnectedComponents,
    int MaxDepth,
    double AverageDegree);
```

#### OrderingReport (Markdown artifact)

Human-readable report with sections:
1. **Summary**: Algorithm used, entity count, pass/fail status
2. **Dependency Graph**: ASCII tree or table showing parentâ†’child relationships
3. **Topological Layers**: Entities grouped by depth (layer 0 = no dependencies, layer 1 = depends on layer 0, etc.)
4. **Violations**: Detailed list of any ordering issues
5. **Statistics**: Graph metrics (max depth, average degree, etc.)
6. **Full Entity List**: All entities with their dependencies and position

**Example Report**:
```markdown
# Topological Ordering Proof Report

**Generated**: 2025-11-18 23:45:00 UTC
**Algorithm**: Kahn (topological sort with cycle detection)
**Context**: Bootstrap Snapshot (all entities)
**Status**: âœ… PASS - All FK dependencies satisfied

## Summary

- Total Entities: 87 (42 static, 45 regular)
- Total Dependencies: 143 FK relationships
- Topological Depth: 5 layers
- Ordering Applied: Global topological sort
- Violations: 0

## Topological Layers

### Layer 0 (No Dependencies) - 12 entities
- dbo.OSSYS_ROLE
- dbo.OSSYS_PERMISSION_TYPE
- dbo.OSSYS_DEPARTMENT
- ...

### Layer 1 (Depends on Layer 0) - 23 entities
- dbo.OSSYS_USER (depends on: ROLE, DEPARTMENT)
- dbo.OSSYS_PERMISSION (depends on: ROLE, PERMISSION_TYPE)
- ...

### Layer 2 (Depends on Layer 0-1) - 31 entities
- dbo.OSSYS_SESSION (depends on: USER)
- dbo.OSSYS_AUDIT_LOG (depends on: USER)
- ...

## Dependency Visualization

```
ROLE (0)
â”œâ”€â”€ USER (1)
â”‚   â”œâ”€â”€ SESSION (2)
â”‚   â”œâ”€â”€ AUDIT_LOG (2)
â”‚   â””â”€â”€ USER_DEPARTMENT (3) [junction]
â”œâ”€â”€ PERMISSION (1)
â”‚   â””â”€â”€ ROLE_PERMISSION (2) [junction]
â””â”€â”€ ROLE_HIERARCHY (1) [self-ref]

DEPARTMENT (0)
â”œâ”€â”€ USER (1)
â””â”€â”€ USER_DEPARTMENT (3) [junction]
```

## Full Entity Order

| Position | Schema | Table | Depth | Dependencies | Dependents |
|----------|--------|-------|-------|--------------|------------|
| 0 | dbo | OSSYS_ROLE | 0 | - | USER, PERMISSION, ROLE_HIERARCHY |
| 1 | dbo | OSSYS_DEPARTMENT | 0 | - | USER, USER_DEPARTMENT |
| 2 | dbo | OSSYS_USER | 1 | ROLE, DEPARTMENT | SESSION, AUDIT_LOG |
| ... | ... | ... | ... | ... | ... |

## Violations

None detected. All FK dependencies are satisfied by the ordering.
```

## Implementation

### Change 1: Enhance EntityDependencySortResult

**File**: `src/Osm.Emission/Seeds/EntityDependencySorter.cs`

**Current** (line 86-96):
```csharp
public sealed record EntityDependencySortResult(
    ImmutableArray<StaticEntityTableData> Tables,
    bool TopologicalOrderingApplied,
    EntityDependencyOrderingMode Mode,
    int NodeCount,
    int EdgeCount,
    int MissingEdgeCount,
    bool CycleDetected,
    bool AlphabeticalFallbackApplied);
```

**Enhanced**:
```csharp
public sealed record EntityDependencySortResult(
    ImmutableArray<StaticEntityTableData> Tables,
    bool TopologicalOrderingApplied,
    EntityDependencyOrderingMode Mode,
    int NodeCount,
    int EdgeCount,
    int MissingEdgeCount,
    bool CycleDetected,
    bool AlphabeticalFallbackApplied,

    // NEW: Detailed proof metadata
    ImmutableDictionary<TableKey, int> TopologicalPositions,  // Table â†’ 0-based position
    ImmutableDictionary<TableKey, int> TopologicalDepths,     // Table â†’ max dependency chain length
    ImmutableArray<DependencyEdge> Edges,                     // All FK relationships
    ImmutableArray<DependencyEdge> MissingEdges,              // FKs with missing targets
    ImmutableArray<TableKey> CycleNodes);                     // Tables involved in cycles (if detected)
```

**Changes to `SortByForeignKeys()`**:
- Capture `TopologicalPositions` from final ordered array
- Calculate `TopologicalDepths` using BFS from roots
- Return full `Edges` array (currently internal to `BuildDependencyGraph()`)
- Return `MissingEdges` (currently logged but not returned)
- Return `CycleNodes` (currently detected but not exposed)

### Change 2: Create TopologicalProofGenerator

**New File**: `src/Osm.Emission/Verification/TopologicalProofGenerator.cs`

```csharp
public sealed class TopologicalProofGenerator
{
    private readonly OsmModel _model;

    public TopologicalProofGenerator(OsmModel model)
    {
        _model = model ?? throw new ArgumentNullException(nameof(model));
    }

    public OrderingProof GenerateProof(
        EntityDependencySortResult sortResult,
        string context)  // "BootstrapSnapshot", "StaticSeeds", "DynamicData"
    {
        var metadata = new OrderingProofMetadata(
            GeneratedUtc: DateTime.UtcNow.ToString("o"),
            Algorithm: sortResult.TopologicalOrderingApplied ? "Kahn" : "Alphabetical",
            TopologicalOrderingApplied: sortResult.TopologicalOrderingApplied,
            CycleDetected: sortResult.CycleDetected,
            AlphabeticalFallbackApplied: sortResult.AlphabeticalFallbackApplied,
            TotalEntities: sortResult.Tables.Length,
            Context: context);

        var entities = BuildEntityProofEntries(sortResult);
        var violations = DetectOrderingViolations(sortResult, entities);
        var statistics = CalculateGraphStatistics(sortResult);

        return new OrderingProof(
            metadata,
            entities,
            sortResult.Edges,
            violations,
            statistics);
    }

    private ImmutableArray<EntityOrderingProofEntry> BuildEntityProofEntries(
        EntityDependencySortResult sortResult)
    {
        var builder = ImmutableArray.CreateBuilder<EntityOrderingProofEntry>(sortResult.Tables.Length);

        for (int i = 0; i < sortResult.Tables.Length; i++)
        {
            var table = sortResult.Tables[i];
            var tableKey = TableKey.From(table.Definition);

            var directDependencies = GetDirectDependencies(tableKey, sortResult.Edges);
            var directDependents = GetDirectDependents(tableKey, sortResult.Edges);
            var criticalPaths = CalculateCriticalPaths(tableKey, sortResult);

            var depth = sortResult.TopologicalDepths.TryGetValue(tableKey, out var d) ? d : -1;

            builder.Add(new EntityOrderingProofEntry(
                TopologicalPosition: i,
                Schema: table.Definition.Schema,
                TableName: table.Definition.PhysicalName,
                Module: table.Definition.Module,
                IsStatic: table.Definition.IsStatic,
                TopologicalDepth: depth,
                DirectDependencies: directDependencies,
                DirectDependents: directDependents,
                CriticalPaths: criticalPaths));
        }

        return builder.MoveToImmutable();
    }

    private ImmutableArray<OrderingViolation> DetectOrderingViolations(
        EntityDependencySortResult sortResult,
        ImmutableArray<EntityOrderingProofEntry> entities)
    {
        var violations = ImmutableArray.CreateBuilder<OrderingViolation>();

        foreach (var edge in sortResult.Edges)
        {
            var childPosition = FindEntityPosition(entities, edge.SourceSchema, edge.SourceTable);
            var parentPosition = FindEntityPosition(entities, edge.TargetSchema, edge.TargetTable);

            if (parentPosition == -1)
            {
                // Missing parent
                violations.Add(new OrderingViolation(
                    ViolationType: "MissingParent",
                    ChildSchema: edge.SourceSchema,
                    ChildTable: edge.SourceTable,
                    ChildPosition: childPosition,
                    ParentSchema: edge.TargetSchema,
                    ParentTable: edge.TargetTable,
                    ParentPosition: -1,
                    ConstraintName: edge.ConstraintName,
                    Explanation: $"FK '{edge.ConstraintName}' references table '{edge.TargetSchema}.{edge.TargetTable}' which is not in the dataset"));
            }
            else if (childPosition < parentPosition)
            {
                // Child appears before parent - VIOLATION!
                violations.Add(new OrderingViolation(
                    ViolationType: "ChildBeforeParent",
                    ChildSchema: edge.SourceSchema,
                    ChildTable: edge.SourceTable,
                    ChildPosition: childPosition,
                    ParentSchema: edge.TargetSchema,
                    ParentTable: edge.TargetTable,
                    ParentPosition: parentPosition,
                    ConstraintName: edge.ConstraintName,
                    Explanation: $"Entity '{edge.SourceSchema}.{edge.SourceTable}' (position {childPosition}) depends on '{edge.TargetSchema}.{edge.TargetTable}' (position {parentPosition}) via FK '{edge.ConstraintName}', but appears earlier in the order"));
            }
        }

        // Check for cycles
        if (sortResult.CycleDetected && !sortResult.CycleNodes.IsDefaultOrEmpty)
        {
            var cycleExplanation = $"Cycle detected involving tables: {string.Join(", ", sortResult.CycleNodes.Select(k => $"{k.Schema}.{k.Name}"))}";

            foreach (var node in sortResult.CycleNodes)
            {
                var position = FindEntityPosition(entities, node.Schema, node.Name);
                violations.Add(new OrderingViolation(
                    ViolationType: "CycleDetected",
                    ChildSchema: node.Schema,
                    ChildTable: node.Name,
                    ChildPosition: position,
                    ParentSchema: node.Schema,
                    ParentTable: node.Name,
                    ParentPosition: position,
                    ConstraintName: "<cycle>",
                    Explanation: cycleExplanation));
            }
        }

        return violations.ToImmutable();
    }

    private GraphStatistics CalculateGraphStatistics(EntityDependencySortResult sortResult)
    {
        var maxDepth = sortResult.TopologicalDepths.IsEmpty ? 0 : sortResult.TopologicalDepths.Values.Max();
        var totalDegree = sortResult.Edges.Length * 2;  // Each edge contributes 1 to in-degree and 1 to out-degree
        var averageDegree = sortResult.NodeCount == 0 ? 0.0 : (double)totalDegree / sortResult.NodeCount;

        return new GraphStatistics(
            TotalNodes: sortResult.NodeCount,
            TotalEdges: sortResult.EdgeCount,
            MissingEdges: sortResult.MissingEdgeCount,
            ConnectedComponents: CalculateConnectedComponents(sortResult),
            MaxDepth: maxDepth,
            AverageDegree: averageDegree);
    }

    // Helper methods for dependency analysis, critical path calculation, etc.
    // ...
}
```

### Change 3: Emit Proof Artifacts

**New Step**: `BuildSsdtOrderingProofStep.cs` (runs after bootstrap/static/dynamic data generation)

```csharp
public sealed class BuildSsdtOrderingProofStep : IBuildSsdtStep<BootstrapSnapshotGenerated, OrderingProofGenerated>
{
    private readonly TopologicalProofGenerator _proofGenerator;
    private readonly OrderingReportWriter _reportWriter;

    public async Task<Result<OrderingProofGenerated>> ExecuteAsync(
        BootstrapSnapshotGenerated state,
        CancellationToken cancellationToken)
    {
        var proofsDirectory = Path.Combine(state.Request.OutputDirectory, "Proofs");
        Directory.CreateDirectory(proofsDirectory);

        // Generate proof from bootstrap snapshot ordering
        var bootstrapProof = _proofGenerator.GenerateProof(
            state.BootstrapOrdering,
            "BootstrapSnapshot");

        // Emit JSON proof
        var proofPath = Path.Combine(proofsDirectory, "ordering-proof.json");
        await WriteProofAsync(proofPath, bootstrapProof, cancellationToken);

        // Emit human-readable report
        var reportPath = Path.Combine(proofsDirectory, "ordering-report.md");
        await _reportWriter.WriteAsync(reportPath, bootstrapProof, cancellationToken);

        // Emit violations (if any)
        if (!bootstrapProof.Violations.IsDefaultOrEmpty)
        {
            var violationsPath = Path.Combine(proofsDirectory, "ordering-violations.json");
            await WriteViolationsAsync(violationsPath, bootstrapProof.Violations, cancellationToken);
        }

        state.Log.Record(
            "ordering.proof.generated",
            bootstrapProof.Violations.IsDefaultOrEmpty
                ? "Ordering proof generated - no violations detected"
                : $"Ordering proof generated - {bootstrapProof.Violations.Length} violations detected",
            new PipelineLogMetadataBuilder()
                .WithPath("proof", proofPath)
                .WithPath("report", reportPath)
                .WithCount("violations", bootstrapProof.Violations.Length)
                .Build());

        return Result<OrderingProofGenerated>.Success(new OrderingProofGenerated(
            state,
            proofPath,
            reportPath,
            bootstrapProof.Violations));
    }
}
```

### Change 4: Update Output Directory Structure

**New Structure** (updated from M1.0):
```
{OutputDirectory}/
â”œâ”€â”€ Modules/
â”œâ”€â”€ Bootstrap/
â”‚   â””â”€â”€ AllEntitiesIncludingStatic.bootstrap.sql
â”œâ”€â”€ BaselineSeeds/
â”œâ”€â”€ Proofs/                           â† NEW
â”‚   â”œâ”€â”€ ordering-proof.json          â† Machine-readable proof
â”‚   â”œâ”€â”€ ordering-report.md           â† Human-readable report
â”‚   â””â”€â”€ ordering-violations.json     â† Only if violations detected
â””â”€â”€ PostDeployment-Bootstrap.sql
```

## Integration with M1.0

**M1.0 Bootstrap Snapshot Generation** becomes:

```csharp
// In BuildSsdtBootstrapSnapshotStep.cs:

// 1. Global topological sort (existing)
var ordering = EntityDependencySorter.SortByForeignKeys(
    allEntities,
    model,
    namingOverrides,
    sortOptions);

// 2. Generate MERGE script (existing)
var bootstrapScript = GenerateBootstrapScript(ordering.Tables, state);

// 3. Write bootstrap snapshot (existing)
await File.WriteAllTextAsync(bootstrapPath, bootstrapScript, Utf8NoBom, cancellationToken);

// 4. NEW: Pass ordering result to next step for proof generation
return state with {
    BootstrapSnapshotPath = bootstrapPath,
    BootstrapOrdering = ordering  // â† NEW: Store ordering result
};
```

**Pipeline Execution Order**:
```
BuildSsdtStaticSeedStep
  â†“
BuildSsdtDynamicInsertStep
  â†“
BuildSsdtBootstrapSnapshotStep (M1.0) â† Generates bootstrap with topological order
  â†“
BuildSsdtOrderingProofStep (M1.2) â† NEW: Proves ordering correctness
  â†“
BuildSsdtPostDeploymentTemplateStep (M1.0)
```

## Use Cases

### Use Case 1: Verify Bootstrap Snapshot Order

**Operator Action**: After generating bootstrap snapshot, review proof to ensure correctness

**Steps**:
1. Run `osm full-export --output ./MyApp`
2. Open `MyApp/Proofs/ordering-report.md`
3. Check "Status" line: âœ… PASS or âŒ FAIL
4. If FAIL, review "Violations" section to see specific FK issues
5. If PASS, review "Topological Layers" to understand entity grouping

**Expected Output** (PASS):
```markdown
# Topological Ordering Proof Report

**Status**: âœ… PASS - All FK dependencies satisfied
...
```

**Expected Output** (FAIL):
```markdown
# Topological Ordering Proof Report

**Status**: âŒ FAIL - 3 ordering violations detected

## Violations

1. **ChildBeforeParent**: Entity 'dbo.OSSYS_USER' (position 5) depends on 'dbo.OSSYS_ROLE' (position 12) via FK 'FK_USER_ROLE', but appears earlier in the order
   - **Action Required**: This is a bug in topological sort - report to developers

2. **MissingParent**: FK 'FK_SESSION_USER' references table 'dbo.OSSYS_USER' which is not in the dataset
   - **Action Required**: Ensure all referenced tables are included in export
...
```

### Use Case 2: Debug FK Violation During SSDT Deployment

**Scenario**: SSDT deployment fails with FK constraint violation

**Operator Action**:
1. Open `Proofs/ordering-report.md`
2. Search for the failing table name (e.g., "OSSYS_SESSION")
3. Review "Full Entity Order" table to see position and dependencies
4. Check if any dependencies appear later in the order
5. If violation exists in proof, file bug report with proof artifact

**Example Debugging**:
```markdown
## Full Entity Order

| Position | Schema | Table | Depth | Dependencies | Dependents |
|----------|--------|-------|-------|--------------|------------|
| 15 | dbo | OSSYS_SESSION | 2 | USER (pos 5) | - |

â†’ OSSYS_SESSION at position 15 depends on USER at position 5 âœ…
â†’ No violation - USER appears before SESSION
â†’ FK violation must be caused by something else (data issue, constraint issue, etc.)
```

### Use Case 3: Understand Dependency Graph

**Operator Action**: Visualize how entities depend on each other

**Steps**:
1. Open `Proofs/ordering-report.md`
2. Review "Dependency Visualization" section (ASCII tree)
3. Review "Topological Layers" to see entity grouping by depth

**Example**:
```
ROLE (depth 0)
â”œâ”€â”€ USER (depth 1)
â”‚   â”œâ”€â”€ SESSION (depth 2)
â”‚   â””â”€â”€ AUDIT_LOG (depth 2)
â””â”€â”€ PERMISSION (depth 1)

â†’ ROLE has no dependencies (depth 0, layer 0)
â†’ USER depends on ROLE (depth 1, layer 1)
â†’ SESSION depends on USER (depth 2, layer 2)
```

## Test Scenarios

### Test 1: Simple Linear Dependency

```csharp
[Fact]
public void GenerateProof_WithLinearDependency_ProducesCorrectDepthAndOrder()
{
    // Arrange: Role â†’ User â†’ Session
    var model = CreateModelWithLinearDependencies();
    var sortResult = EntityDependencySorter.SortByForeignKeys(entities, model);
    var generator = new TopologicalProofGenerator(model);

    // Act
    var proof = generator.GenerateProof(sortResult, "Test");

    // Assert
    Assert.Empty(proof.Violations);
    Assert.Equal(0, proof.Entities.Single(e => e.TableName == "ROLE").TopologicalDepth);
    Assert.Equal(1, proof.Entities.Single(e => e.TableName == "USER").TopologicalDepth);
    Assert.Equal(2, proof.Entities.Single(e => e.TableName == "SESSION").TopologicalDepth);

    // Verify order
    var rolePos = proof.Entities.Single(e => e.TableName == "ROLE").TopologicalPosition;
    var userPos = proof.Entities.Single(e => e.TableName == "USER").TopologicalPosition;
    Assert.True(rolePos < userPos);  // Parent before child
}
```

### Test 2: Cycle Detection

```csharp
[Fact]
public void GenerateProof_WithCycle_ReportsViolations()
{
    // Arrange: A â†’ B â†’ C â†’ A (cycle)
    var model = CreateModelWithCycle();
    var sortResult = EntityDependencySorter.SortByForeignKeys(entities, model);
    var generator = new TopologicalProofGenerator(model);

    // Act
    var proof = generator.GenerateProof(sortResult, "Test");

    // Assert
    Assert.NotEmpty(proof.Violations);
    Assert.Contains(proof.Violations, v => v.ViolationType == "CycleDetected");
    Assert.True(proof.Metadata.CycleDetected);
    Assert.True(proof.Metadata.AlphabeticalFallbackApplied);
}
```

### Test 3: Missing Parent Detection

```csharp
[Fact]
public void GenerateProof_WithMissingParent_ReportsViolation()
{
    // Arrange: User â†’ Role, but Role not in dataset
    var model = CreateModelWithMissingParent();
    var sortResult = EntityDependencySorter.SortByForeignKeys(entities, model);
    var generator = new TopologicalProofGenerator(model);

    // Act
    var proof = generator.GenerateProof(sortResult, "Test");

    // Assert
    var violation = Assert.Single(proof.Violations);
    Assert.Equal("MissingParent", violation.ViolationType);
    Assert.Equal("ROLE", violation.ParentTable);
    Assert.Equal(-1, violation.ParentPosition);
}
```

### Test 4: Junction Table Deferral

```csharp
[Fact]
public void GenerateProof_WithJunctionTable_ShowsCorrectDepth()
{
    // Arrange: User (depth 0), Role (depth 0), UserRole (junction, depth 1)
    var model = CreateModelWithJunctionTable();
    var sortResult = EntityDependencySorter.SortByForeignKeys(entities, model);
    var generator = new TopologicalProofGenerator(model);

    // Act
    var proof = generator.GenerateProof(sortResult, "Test");

    // Assert
    var junctionEntry = proof.Entities.Single(e => e.TableName == "USER_ROLE");
    Assert.Equal(1, junctionEntry.TopologicalDepth);
    Assert.Contains("USER", junctionEntry.DirectDependencies);
    Assert.Contains("ROLE", junctionEntry.DirectDependencies);
}
```

## Success Criteria

1. âœ… `ordering-proof.json` emitted for bootstrap snapshot
2. âœ… `ordering-report.md` is human-readable and contains all sections
3. âœ… Violations correctly detected (child before parent, missing parent, cycles)
4. âœ… Topological depths calculated correctly
5. âœ… Dependency visualization shows parentâ†’child relationships
6. âœ… Proof artifacts can be used to debug FK violations
7. âœ… All tests pass

## Future Enhancements (Out of Scope for M1.2)

### M2.2: Proof for UAT-Users Transformations
- Generate proof for UAT-users FK remapping
- Show before/after dependency graphs
- Verify transformations preserve ordering

### M3.2: Load Harness Integration
- Validate proof during LoadHarness execution
- Fail fast if violations detected before applying scripts
- Compare actual execution order vs. proof order

### M4.1: Performance Optimization
- Cache dependency calculations
- Incremental proof generation for large exports
- Parallel proof generation for per-module seeds

---

**Status**: Ready for implementation after M1.0 is complete
**Dependencies**: Requires M1.0 `EntityDependencySortResult` enhancements
